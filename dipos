#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                              ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ïë
‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó ‚ïë
‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïë
‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïë
‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                    üöÄ DIPO STUDIO v2.0 - Code Editor                        ‚ïë
‚ïë                    üì± Telegram: @MARADANIL                                   ‚ïë
‚ïë                    üì¢ Channel: https://t.me/DIPO_OFFICIAL                    ‚ïë
‚ïë                                                                              ‚ïë
‚ïë     Copyright (c) 2024 DIPO Studio. All rights reserved.                    ‚ïë
‚ïë     Licensed under proprietary license. Unauthorized copying prohibited.    ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""

import os
import sys
import re
import json
import time
import curses
import locale
import shutil
import hashlib
import base64
import subprocess
import threading
import traceback
from pathlib import Path
from datetime import datetime
from collections import deque
from typing import List, Dict, Tuple, Optional, Any, Callable

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –í–ï–†–°–ò–Ø –ò –ú–ï–¢–ê–î–ê–ù–ù–´–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

__version__ = "2.0.0"
__author__ = "DIPO Team"
__telegram__ = "@MARADANIL"
__channel__ = "https://t.me/DIPO_OFFICIAL"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–†–û–í–ï–†–ö–ê –õ–ò–¶–ï–ù–ó–ò–ò (–ó–ê–©–ò–¢–ê –ö–û–î–ê)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class LicenseProtection:
    """–ó–∞—â–∏—Ç–∞ –∫–æ–¥–∞ –æ—Ç –Ω–µ—Å–∞–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞"""
    
    _SECRET_HASH = "d1p0_s3cr3t_k3y_2024"
    _LICENSE_FILE = os.path.expanduser("~/.dipo/license.key")
    
    @classmethod
    def verify(cls) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–µ–Ω–∑–∏–∏"""
        return True  # –î–ª—è open-source –≤–µ—Ä—Å–∏–∏ –≤—Å–µ–≥–¥–∞ True
    
    @classmethod
    def get_machine_id(cls) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –º–∞—à–∏–Ω—ã"""
        data = f"{os.getlogin()}-{os.uname().nodename}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–õ–ê–¢–§–û–†–ú–´
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Platform:
    """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π"""
    
    IS_TERMUX = os.path.exists('/data/data/com.termux')
    IS_ANDROID = IS_TERMUX
    IS_LINUX = sys.platform.startswith('linux') and not IS_TERMUX
    IS_MACOS = sys.platform == 'darwin'
    IS_WINDOWS = sys.platform == 'win32'
    IS_MOBILE = IS_TERMUX  # –ú–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
    
    @classmethod
    def get_name(cls) -> str:
        if cls.IS_TERMUX:
            return "Termux (Android)"
        elif cls.IS_LINUX:
            return "Linux"
        elif cls.IS_MACOS:
            return "macOS"
        elif cls.IS_WINDOWS:
            return "Windows"
        return "Unknown"
    
    @classmethod
    def get_home(cls) -> str:
        return os.path.expanduser("~")
    
    @classmethod
    def get_config_dir(cls) -> str:
        return os.path.join(cls.get_home(), ".dipo")
    
    @classmethod
    def supports_256_colors(cls) -> bool:
        term = os.environ.get('TERM', '')
        return '256color' in term or 'truecolor' in term or cls.IS_TERMUX

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ö–û–ù–°–¢–ê–ù–¢–´
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
CONFIG_DIR = Platform.get_config_dir()
PLUGINS_DIR = os.path.join(CONFIG_DIR, "plugins")
THEMES_DIR = os.path.join(CONFIG_DIR, "themes")
SESSIONS_DIR = os.path.join(CONFIG_DIR, "sessions")
RECOVERY_DIR = os.path.join(CONFIG_DIR, "recovery")
AI_CONFIG_FILE = os.path.join(CONFIG_DIR, "ai_config.json")
SETTINGS_FILE = os.path.join(CONFIG_DIR, "settings.json")

# –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
for d in [CONFIG_DIR, PLUGINS_DIR, THEMES_DIR, SESSIONS_DIR, RECOVERY_DIR]:
    os.makedirs(d, exist_ok=True)

# –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
MAX_UNDO_HISTORY = 1000
MAX_CLIPBOARD_HISTORY = 50
AUTOSAVE_INTERVAL = 60  # —Å–µ–∫—É–Ω–¥—ã
MAX_FILE_SIZE_MB = 50

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –¶–í–ï–¢–û–í–ê–Ø –ü–ê–õ–ò–¢–†–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Colors:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–≤–µ—Ç–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞"""
    
    # –ë–∞–∑–æ–≤—ã–µ —Ü–≤–µ—Ç–∞ curses
    BLACK = 0
    RED = 1
    GREEN = 2
    YELLOW = 3
    BLUE = 4
    MAGENTA = 5
    CYAN = 6
    WHITE = 7
    
    # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞ (256-color)
    ORANGE = 208
    PINK = 205
    PURPLE = 141
    LIME = 118
    TEAL = 30
    GOLD = 220
    SILVER = 250
    CORAL = 209
    VIOLET = 135
    
    # DIPO Brand Colors
    DIPO_PRIMARY = PURPLE  # –§–∏–æ–ª–µ—Ç–æ–≤—ã–π - –æ—Å–Ω–æ–≤–Ω–æ–π
    DIPO_SECONDARY = BLUE  # –°–∏–Ω–∏–π
    DIPO_ACCENT = YELLOW   # –ñ—ë–ª—Ç—ã–π
    DIPO_ERROR = RED       # –ö—Ä–∞—Å–Ω—ã–π
    DIPO_SUCCESS = GREEN   # –ó–µ–ª—ë–Ω—ã–π
    
    _pairs_initialized = False
    _pair_counter = 1
    _color_pairs: Dict[Tuple[int, int], int] = {}
    
    @classmethod
    def init(cls, stdscr):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–æ–≤—ã—Ö –ø–∞—Ä"""
        if cls._pairs_initialized:
            return
        
        curses.start_color()
        curses.use_default_colors()
        
        # –ë–∞–∑–æ–≤—ã–µ –ø–∞—Ä—ã
        pairs = [
            (cls.WHITE, -1),      # 1: –ë–µ–ª—ã–π –Ω–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–º
            (cls.GREEN, -1),      # 2: –ó–µ–ª—ë–Ω—ã–π
            (cls.YELLOW, -1),     # 3: –ñ—ë–ª—Ç—ã–π
            (cls.BLUE, -1),       # 4: –°–∏–Ω–∏–π
            (cls.MAGENTA, -1),    # 5: –ú–∞–≥–µ–Ω—Ç–∞
            (cls.CYAN, -1),       # 6: –¶–∏–∞–Ω
            (cls.RED, -1),        # 7: –ö—Ä–∞—Å–Ω—ã–π
            (cls.BLACK, cls.WHITE),   # 8: –ß—ë—Ä–Ω—ã–π –Ω–∞ –±–µ–ª–æ–º
            (cls.WHITE, cls.BLUE),    # 9: –ë–µ–ª—ã–π –Ω–∞ —Å–∏–Ω–µ–º
            (cls.BLACK, cls.YELLOW),  # 10: –ß—ë—Ä–Ω—ã–π –Ω–∞ –∂—ë–ª—Ç–æ–º
            (cls.WHITE, cls.RED),     # 11: –ë–µ–ª—ã–π –Ω–∞ –∫—Ä–∞—Å–Ω–æ–º
            (cls.WHITE, cls.GREEN),   # 12: –ë–µ–ª—ã–π –Ω–∞ –∑–µ–ª—ë–Ω–æ–º
            (cls.WHITE, cls.MAGENTA), # 13: –ë–µ–ª—ã–π –Ω–∞ –º–∞–≥–µ–Ω—Ç–µ
            (cls.YELLOW, cls.BLUE),   # 14: –ñ—ë–ª—Ç—ã–π –Ω–∞ —Å–∏–Ω–µ–º
            (cls.BLACK, cls.CYAN),    # 15: –ß—ë—Ä–Ω—ã–π –Ω–∞ —Ü–∏–∞–Ω–µ
        ]
        
        for i, (fg, bg) in enumerate(pairs, 1):
            try:
                curses.init_pair(i, fg, bg)
                cls._color_pairs[(fg, bg)] = i
                cls._pair_counter = i + 1
            except:
                pass
        
        cls._pairs_initialized = True
    
    @classmethod
    def get_pair(cls, fg: int, bg: int = -1) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ü–≤–µ—Ç–æ–≤—É—é –ø–∞—Ä—É"""
        key = (fg, bg)
        if key in cls._color_pairs:
            return curses.color_pair(cls._color_pairs[key])
        
        try:
            curses.init_pair(cls._pair_counter, fg, bg)
            cls._color_pairs[key] = cls._pair_counter
            cls._pair_counter += 1
            return curses.color_pair(cls._color_pairs[key])
        except:
            return curses.color_pair(1)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –¢–ï–ú–´ –û–§–û–†–ú–õ–ï–ù–ò–Ø
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

THEMES = {
    "cosmos": {
        "name": "üåå –ö–æ—Å–º–æ—Å",
        "description": "–¢—ë–º–Ω–∞—è —Ç–µ–º–∞ —Å —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–º–∏ –∞–∫—Ü–µ–Ω—Ç–∞–º–∏",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.BLUE,
        "header_fg": Colors.WHITE,
        "footer_bg": Colors.MAGENTA,
        "footer_fg": Colors.WHITE,
        "line_num": Colors.CYAN,
        "current_line_bg": Colors.BLUE,
        "selection_bg": Colors.MAGENTA,
        "cursor_bg": Colors.WHITE,
        "keyword": Colors.MAGENTA,
        "string": Colors.GREEN,
        "comment": Colors.CYAN,
        "number": Colors.YELLOW,
        "function": Colors.BLUE,
        "class_name": Colors.CYAN,
        "operator": Colors.WHITE,
        "error": Colors.RED,
        "warning": Colors.YELLOW,
        "success": Colors.GREEN,
    },
    "matrix": {
        "name": "üíö –ú–∞—Ç—Ä–∏—Ü–∞",
        "description": "–ó–µ–ª—ë–Ω—ã–π –∫–æ–¥ –Ω–∞ —á—ë—Ä–Ω–æ–º —Ñ–æ–Ω–µ",
        "bg": -1,
        "fg": Colors.GREEN,
        "header_bg": Colors.GREEN,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.GREEN,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.GREEN,
        "keyword": Colors.GREEN,
        "string": Colors.GREEN,
        "comment": Colors.GREEN,
        "number": Colors.GREEN,
        "function": Colors.GREEN,
        "class_name": Colors.GREEN,
    },
    "dracula": {
        "name": "üßõ –î—Ä–∞–∫—É–ª–∞",
        "description": "–ü–æ–ø—É–ª—è—Ä–Ω–∞—è —Ç—ë–º–Ω–∞—è —Ç–µ–º–∞",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.MAGENTA,
        "header_fg": Colors.WHITE,
        "footer_bg": Colors.BLUE,
        "footer_fg": Colors.WHITE,
        "line_num": Colors.CYAN,
        "keyword": Colors.MAGENTA,
        "string": Colors.YELLOW,
        "comment": Colors.CYAN,
        "number": Colors.GREEN,
        "function": Colors.GREEN,
        "class_name": Colors.CYAN,
    },
    "monokai": {
        "name": "üé® Monokai",
        "description": "–ö–ª–∞—Å—Å–∏–∫–∞ –∏–∑ Sublime Text",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.YELLOW,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.GREEN,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.YELLOW,
        "keyword": Colors.RED,
        "string": Colors.YELLOW,
        "comment": Colors.CYAN,
        "number": Colors.MAGENTA,
        "function": Colors.GREEN,
        "class_name": Colors.GREEN,
    },
    "nord": {
        "name": "‚ùÑÔ∏è Nord",
        "description": "–•–æ–ª–æ–¥–Ω—ã–µ —Å–∫–∞–Ω–¥–∏–Ω–∞–≤—Å–∫–∏–µ —Ç–æ–Ω–∞",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.CYAN,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.BLUE,
        "footer_fg": Colors.WHITE,
        "line_num": Colors.CYAN,
        "keyword": Colors.CYAN,
        "string": Colors.GREEN,
        "comment": Colors.BLUE,
        "number": Colors.MAGENTA,
    },
    "sunset": {
        "name": "üåÖ –ó–∞–∫–∞—Ç",
        "description": "–¢—ë–ø–ª—ã–µ –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –∏ –∫—Ä–∞—Å–Ω—ã–µ —Ç–æ–Ω–∞",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.RED,
        "header_fg": Colors.WHITE,
        "footer_bg": Colors.YELLOW,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.YELLOW,
        "keyword": Colors.RED,
        "string": Colors.YELLOW,
        "comment": Colors.MAGENTA,
    },
    "ocean": {
        "name": "üåä –û–∫–µ–∞–Ω",
        "description": "–ì–æ–ª—É–±—ã–µ –∏ –±–∏—Ä—é–∑–æ–≤—ã–µ –æ—Ç—Ç–µ–Ω–∫–∏",
        "bg": -1,
        "fg": Colors.CYAN,
        "header_bg": Colors.BLUE,
        "header_fg": Colors.WHITE,
        "footer_bg": Colors.CYAN,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.BLUE,
        "keyword": Colors.BLUE,
        "string": Colors.CYAN,
    },
    "forest": {
        "name": "üå≤ –õ–µ—Å",
        "description": "–ó–µ–ª—ë–Ω—ã–µ –∏ –∫–æ—Ä–∏—á–Ω–µ–≤—ã–µ —Ç–æ–Ω–∞",
        "bg": -1,
        "fg": Colors.GREEN,
        "header_bg": Colors.GREEN,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.YELLOW,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.GREEN,
        "keyword": Colors.GREEN,
        "string": Colors.YELLOW,
    },
    "high_contrast": {
        "name": "üëÅÔ∏è –ö–æ–Ω—Ç—Ä–∞—Å—Ç",
        "description": "–í—ã—Å–æ–∫–∏–π –∫–æ–Ω—Ç—Ä–∞—Å—Ç –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏",
        "bg": Colors.BLACK,
        "fg": Colors.WHITE,
        "header_bg": Colors.WHITE,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.WHITE,
        "footer_fg": Colors.BLACK,
        "line_num": Colors.YELLOW,
        "keyword": Colors.YELLOW,
        "string": Colors.GREEN,
        "comment": Colors.CYAN,
    },
    "solarized_dark": {
        "name": "‚òÄÔ∏è Solarized Dark",
        "description": "–ù–∞—É—á–Ω–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞",
        "bg": -1,
        "fg": Colors.WHITE,
        "header_bg": Colors.CYAN,
        "header_fg": Colors.BLACK,
        "footer_bg": Colors.BLUE,
        "footer_fg": Colors.WHITE,
        "line_num": Colors.CYAN,
        "keyword": Colors.GREEN,
        "string": Colors.CYAN,
    }
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ú–û–ë–ò–õ–¨–ù–´–ï –ö–û–ú–ê–ù–î–´ (–î–õ–Ø –¢–ï–õ–ï–§–û–ù–û–í –ë–ï–ó F-–ö–õ–ê–í–ò–®)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

MOBILE_COMMANDS = {
    # –ö–æ–º–∞–Ω–¥—ã –≤–≤–æ–¥—è—Ç—Å—è —á–µ—Ä–µ–∑ : (–∫–∞–∫ –≤ Vim, –Ω–æ –ø—Ä–æ—â–µ)
    ":s": "save",           # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
    ":q": "quit",           # –í—ã–π—Ç–∏
    ":w": "save",           # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞)
    ":wq": "save_quit",     # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏
    ":q!": "force_quit",    # –í—ã–π—Ç–∏ –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    ":h": "help",           # –°–ø—Ä–∞–≤–∫–∞ (F1)
    ":z": "zen",            # –†–µ–∂–∏–º Zen (F2)
    ":t": "theme",          # –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É (F4)
    ":r": "run",            # –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥ (F5)
    ":f": "files",          # –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ (F6)
    ":l": "lint",           # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ (F7)
    ":g": "goto",           # –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ
    ":find": "search",      # –ü–æ–∏—Å–∫
    ":replace": "replace",  # –ó–∞–º–µ–Ω–∞
    ":ai": "ai_menu",       # AI –º–µ–Ω—é
    ":ai setup": "ai_setup", # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ AI
    ":build": "build_apk",  # –°–±–æ—Ä–∫–∞ APK
    ":git": "git_menu",     # Git –º–µ–Ω—é
    ":new": "new_file",     # –ù–æ–≤—ã–π —Ñ–∞–π–ª
    ":open": "open_file",   # –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª
    ":close": "close_tab",  # –ó–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É
    ":tabs": "show_tabs",   # –ü–æ–∫–∞–∑–∞—Ç—å –≤–∫–ª–∞–¥–∫–∏
    ":plugins": "plugins",  # –ü–ª–∞–≥–∏–Ω—ã
    ":settings": "settings", # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
    ":undo": "undo",        # –û—Ç–º–µ–Ω–∏—Ç—å
    ":redo": "redo",        # –ü–æ–≤—Ç–æ—Ä–∏—Ç—å
    ":copy": "copy",        # –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
    ":paste": "paste",      # –í—Å—Ç–∞–≤–∏—Ç—å
    ":cut": "cut",          # –í—ã—Ä–µ–∑–∞—Ç—å
    ":comment": "comment",  # –ö–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
    ":format": "format",    # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å
    ":fold": "fold",        # –°–≤–µ—Ä–Ω—É—Ç—å –±–ª–æ–∫
    ":unfold": "unfold",    # –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –±–ª–æ–∫
    ":mini": "minimap",     # –ú–∏–Ω–∏-–∫–∞—Ä—Ç–∞
    ":term": "terminal",    # –¢–µ—Ä–º–∏–Ω–∞–ª
    ":snippet": "snippets", # –°–Ω–∏–ø–ø–µ—Ç—ã
    ":bookmark": "bookmark", # –ó–∞–∫–ª–∞–¥–∫–∞
    ":doctor": "doctor",    # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
}

# –û–ø–∏—Å–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥ –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏
MOBILE_COMMANDS_HELP = {
    ":s / :w": "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª",
    ":q": "üö™ –í—ã–π—Ç–∏",
    ":wq": "üíæüö™ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏",
    ":h": "‚ùì –°–ø—Ä–∞–≤–∫–∞",
    ":r": "‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥",
    ":f": "üìÇ –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤",
    ":t": "üé® –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É",
    ":ai": "ü§ñ AI –ø–æ–º–æ—â–Ω–∏–∫",
    ":build": "üì¶ –°–±–æ—Ä–∫–∞ APK",
    ":git": "üåø Git –æ–ø–µ—Ä–∞—Ü–∏–∏",
    ":find": "üîç –ü–æ–∏—Å–∫",
    ":g 42": "üìç –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ 42",
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –Ø–ó–´–ö–ò –ü–†–û–ì–†–ê–ú–ú–ò–†–û–í–ê–ù–ò–Ø (30+ —è–∑—ã–∫–æ–≤ —Å –ø–æ–ª–Ω–æ–π –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

LANGUAGES = {
    "python": {
        "name": "Python",
        "icon": "üêç",
        "extensions": [".py", ".pyw", ".pyi", ".pyx"],
        "run": "python3 {file}",
        "comment": "#",
        "comment_multi": ['"""', '"""'],
        "indent": 4,
        "keywords": [
            "False", "None", "True", "and", "as", "assert", "async", "await",
            "break", "class", "continue", "def", "del", "elif", "else", "except",
            "finally", "for", "from", "global", "if", "import", "in", "is",
            "lambda", "nonlocal", "not", "or", "pass", "raise", "return", "try",
            "while", "with", "yield", "match", "case", "type"
        ],
        "builtins": [
            "abs", "aiter", "all", "any", "anext", "ascii", "bin", "bool",
            "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod",
            "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate",
            "eval", "exec", "filter", "float", "format", "frozenset", "getattr",
            "globals", "hasattr", "hash", "help", "hex", "id", "input", "int",
            "isinstance", "issubclass", "iter", "len", "list", "locals", "map",
            "max", "memoryview", "min", "next", "object", "oct", "open", "ord",
            "pow", "print", "property", "range", "repr", "reversed", "round",
            "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum",
            "super", "tuple", "type", "vars", "zip", "__import__"
        ],
        "types": ["str", "int", "float", "bool", "list", "dict", "set", "tuple", "bytes"],
        "snippets": {
            "def": "def ${1:name}(${2:args}):\n    ${3:pass}",
            "class": "class ${1:Name}:\n    def __init__(self):\n        ${2:pass}",
            "if": "if ${1:condition}:\n    ${2:pass}",
            "for": "for ${1:item} in ${2:items}:\n    ${3:pass}",
            "while": "while ${1:condition}:\n    ${2:pass}",
            "try": "try:\n    ${1:pass}\nexcept ${2:Exception} as e:\n    ${3:pass}",
            "with": "with ${1:expr} as ${2:var}:\n    ${3:pass}",
            "main": 'if __name__ == "__main__":\n    ${1:main()}',
            "async": "async def ${1:name}(${2:args}):\n    ${3:pass}",
            "lambda": "lambda ${1:x}: ${2:x}",
            "list_comp": "[${1:x} for ${2:x} in ${3:items}]",
            "dict_comp": "{${1:k}: ${2:v} for ${1:k}, ${2:v} in ${3:items}.items()}",
            "dataclass": "@dataclass\nclass ${1:Name}:\n    ${2:field}: ${3:type}",
        }
    },
    "javascript": {
        "name": "JavaScript",
        "icon": "üìú",
        "extensions": [".js", ".mjs", ".cjs", ".jsx"],
        "run": "node {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "async", "await", "break", "case", "catch", "class", "const",
            "continue", "debugger", "default", "delete", "do", "else", "export",
            "extends", "finally", "for", "function", "if", "import", "in",
            "instanceof", "let", "new", "return", "static", "super", "switch",
            "this", "throw", "try", "typeof", "var", "void", "while", "with",
            "yield", "enum", "implements", "interface", "package", "private",
            "protected", "public", "null", "undefined", "true", "false", "NaN"
        ],
        "builtins": [
            "console", "document", "window", "Array", "Object", "String",
            "Number", "Boolean", "Function", "Symbol", "Map", "Set", "WeakMap",
            "WeakSet", "Promise", "Proxy", "Reflect", "JSON", "Math", "Date",
            "RegExp", "Error", "parseInt", "parseFloat", "isNaN", "isFinite",
            "encodeURI", "decodeURI", "setTimeout", "setInterval", "fetch",
            "require", "module", "exports", "Buffer", "process"
        ],
        "snippets": {
            "fn": "function ${1:name}(${2:args}) {\n    ${3}\n}",
            "afn": "async function ${1:name}(${2:args}) {\n    ${3}\n}",
            "arrow": "const ${1:name} = (${2:args}) => {\n    ${3}\n}",
            "class": "class ${1:Name} {\n    constructor(${2:args}) {\n        ${3}\n    }\n}",
            "for": "for (let ${1:i} = 0; ${1:i} < ${2:len}; ${1:i}++) {\n    ${3}\n}",
            "foreach": "${1:arr}.forEach((${2:item}) => {\n    ${3}\n})",
            "if": "if (${1:condition}) {\n    ${2}\n}",
            "try": "try {\n    ${1}\n} catch (${2:error}) {\n    ${3}\n}",
            "promise": "new Promise((resolve, reject) => {\n    ${1}\n})",
            "fetch": "fetch('${1:url}')\n    .then(res => res.json())\n    .then(data => {\n        ${2}\n    })",
            "log": "console.log(${1})",
            "import": "import { ${1} } from '${2}'",
            "export": "export { ${1} }",
        }
    },
    "typescript": {
        "name": "TypeScript",
        "icon": "üí†",
        "extensions": [".ts", ".tsx", ".mts", ".cts"],
        "run": "npx ts-node {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "abstract", "any", "as", "async", "await", "boolean", "break",
            "case", "catch", "class", "const", "constructor", "continue",
            "declare", "default", "delete", "do", "else", "enum", "export",
            "extends", "false", "finally", "for", "from", "function", "get",
            "if", "implements", "import", "in", "infer", "instanceof",
            "interface", "is", "keyof", "let", "module", "namespace", "never",
            "new", "null", "number", "object", "of", "package", "private",
            "protected", "public", "readonly", "return", "set", "static",
            "string", "super", "switch", "symbol", "this", "throw", "true",
            "try", "type", "typeof", "undefined", "unique", "unknown", "var",
            "void", "while", "with", "yield"
        ],
    },
    "html": {
        "name": "HTML",
        "icon": "üåê",
        "extensions": [".html", ".htm", ".xhtml"],
        "run": "termux-open {file}" if Platform.IS_TERMUX else "open {file}",
        "comment": "",
        "comment_multi": ["<!--", "-->"],
        "indent": 2,
        "keywords": [],
        "tags": [
            "html", "head", "body", "div", "span", "p", "a", "img", "ul", "ol",
            "li", "table", "tr", "td", "th", "form", "input", "button", "select",
            "option", "textarea", "label", "header", "footer", "nav", "main",
            "section", "article", "aside", "h1", "h2", "h3", "h4", "h5", "h6",
            "br", "hr", "script", "style", "link", "meta", "title", "canvas",
            "video", "audio", "source", "iframe", "svg", "path", "template"
        ],
        "snippets": {
            "html5": '<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>${1:Document}</title>\n</head>\n<body>\n    ${2}\n</body>\n</html>',
            "div": '<div class="${1}">\n    ${2}\n</div>',
            "link": '<a href="${1}">${2}</a>',
            "img": '<img src="${1}" alt="${2}">',
            "form": '<form action="${1}" method="${2:post}">\n    ${3}\n</form>',
            "input": '<input type="${1:text}" name="${2}" id="${3}">',
            "button": '<button type="${1:button}">${2}</button>',
            "script": '<script src="${1}"></script>',
            "style": '<link rel="stylesheet" href="${1}">',
        }
    },
    "css": {
        "name": "CSS",
        "icon": "üé®",
        "extensions": [".css", ".scss", ".sass", ".less"],
        "run": None,
        "comment": "",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "important", "inherit", "initial", "unset", "auto", "none",
            "block", "inline", "flex", "grid", "absolute", "relative",
            "fixed", "sticky", "static", "hidden", "visible", "scroll"
        ],
        "properties": [
            "display", "position", "width", "height", "margin", "padding",
            "border", "background", "color", "font-size", "font-family",
            "text-align", "flex-direction", "justify-content", "align-items",
            "grid-template", "transition", "transform", "animation", "opacity",
            "z-index", "overflow", "box-shadow", "border-radius"
        ],
        "snippets": {
            "flex": "display: flex;\njustify-content: ${1:center};\nalign-items: ${2:center};",
            "grid": "display: grid;\ngrid-template-columns: ${1:1fr 1fr};",
            "center": "display: flex;\njustify-content: center;\nalign-items: center;",
            "media": "@media (max-width: ${1:768px}) {\n    ${2}\n}",
            "var": "--${1:name}: ${2:value};",
            "anim": "@keyframes ${1:name} {\n    from { ${2} }\n    to { ${3} }\n}",
        }
    },
    "php": {
        "name": "PHP",
        "icon": "üêò",
        "extensions": [".php", ".phtml", ".php5"],
        "run": "php {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "abstract", "and", "array", "as", "break", "callable", "case",
            "catch", "class", "clone", "const", "continue", "declare",
            "default", "die", "do", "echo", "else", "elseif", "empty",
            "enddeclare", "endfor", "endforeach", "endif", "endswitch",
            "endwhile", "eval", "exit", "extends", "final", "finally", "fn",
            "for", "foreach", "function", "global", "goto", "if", "implements",
            "include", "include_once", "instanceof", "insteadof", "interface",
            "isset", "list", "match", "namespace", "new", "or", "print",
            "private", "protected", "public", "readonly", "require",
            "require_once", "return", "static", "switch", "throw", "trait",
            "try", "unset", "use", "var", "while", "xor", "yield",
            "true", "false", "null", "self", "parent"
        ],
    },
    "ruby": {
        "name": "Ruby",
        "icon": "üíé",
        "extensions": [".rb", ".rake", ".gemspec"],
        "run": "ruby {file}",
        "comment": "#",
        "comment_multi": ["=begin", "=end"],
        "indent": 2,
        "keywords": [
            "BEGIN", "END", "alias", "and", "begin", "break", "case", "class",
            "def", "defined?", "do", "else", "elsif", "end", "ensure", "false",
            "for", "if", "in", "module", "next", "nil", "not", "or", "redo",
            "rescue", "retry", "return", "self", "super", "then", "true",
            "undef", "unless", "until", "when", "while", "yield", "require",
            "require_relative", "include", "extend", "prepend", "attr_accessor",
            "attr_reader", "attr_writer", "private", "protected", "public"
        ],
    },
    "go": {
        "name": "Go",
        "icon": "üêπ",
        "extensions": [".go"],
        "run": "go run {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "break", "case", "chan", "const", "continue", "default", "defer",
            "else", "fallthrough", "for", "func", "go", "goto", "if", "import",
            "interface", "map", "package", "range", "return", "select", "struct",
            "switch", "type", "var", "true", "false", "nil", "iota", "append",
            "cap", "close", "complex", "copy", "delete", "imag", "len", "make",
            "new", "panic", "print", "println", "real", "recover"
        ],
        "types": ["bool", "byte", "complex64", "complex128", "error", "float32",
                  "float64", "int", "int8", "int16", "int32", "int64", "rune",
                  "string", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr"],
        "snippets": {
            "func": "func ${1:name}(${2:args}) ${3:returnType} {\n\t${4}\n}",
            "main": 'package main\n\nimport "fmt"\n\nfunc main() {\n\t${1}\n}',
            "struct": "type ${1:Name} struct {\n\t${2:Field} ${3:Type}\n}",
            "if": "if ${1:condition} {\n\t${2}\n}",
            "for": "for ${1:i} := 0; ${1:i} < ${2:n}; ${1:i}++ {\n\t${3}\n}",
            "range": "for ${1:i}, ${2:v} := range ${3:slice} {\n\t${4}\n}",
            "err": "if err != nil {\n\treturn ${1:err}\n}",
        }
    },
    "rust": {
        "name": "Rust",
        "icon": "ü¶Ä",
        "extensions": [".rs"],
        "run": "cargo run",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "as", "async", "await", "break", "const", "continue", "crate",
            "dyn", "else", "enum", "extern", "false", "fn", "for", "if",
            "impl", "in", "let", "loop", "match", "mod", "move", "mut",
            "pub", "ref", "return", "self", "Self", "static", "struct",
            "super", "trait", "true", "type", "unsafe", "use", "where",
            "while", "abstract", "become", "box", "do", "final", "macro",
            "override", "priv", "typeof", "unsized", "virtual", "yield"
        ],
        "types": ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32",
                  "u64", "u128", "usize", "f32", "f64", "bool", "char", "str",
                  "String", "Vec", "Option", "Result", "Box", "Rc", "Arc"],
        "snippets": {
            "fn": "fn ${1:name}(${2:args}) -> ${3:Type} {\n    ${4}\n}",
            "main": 'fn main() {\n    println!("${1:Hello}");\n}',
            "struct": "struct ${1:Name} {\n    ${2:field}: ${3:Type},\n}",
            "impl": "impl ${1:Name} {\n    ${2}\n}",
            "match": "match ${1:expr} {\n    ${2:pattern} => ${3:result},\n    _ => ${4:default},\n}",
            "if": "if ${1:condition} {\n    ${2}\n}",
            "loop": "loop {\n    ${1}\n    break;\n}",
            "print": 'println!("{}", ${1:var});',
        }
    },
    "java": {
        "name": "Java",
        "icon": "‚òï",
        "extensions": [".java"],
        "run": "javac {file} && java {name}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "abstract", "assert", "boolean", "break", "byte", "case", "catch",
            "char", "class", "const", "continue", "default", "do", "double",
            "else", "enum", "extends", "final", "finally", "float", "for",
            "goto", "if", "implements", "import", "instanceof", "int",
            "interface", "long", "native", "new", "package", "private",
            "protected", "public", "return", "short", "static", "strictfp",
            "super", "switch", "synchronized", "this", "throw", "throws",
            "transient", "try", "void", "volatile", "while", "true", "false",
            "null", "var", "record", "sealed", "permits", "yield"
        ],
        "snippets": {
            "main": 'public static void main(String[] args) {\n    ${1}\n}',
            "class": "public class ${1:Name} {\n    ${2}\n}",
            "sout": 'System.out.println(${1});',
            "for": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n    ${3}\n}",
            "foreach": "for (${1:Type} ${2:item} : ${3:items}) {\n    ${4}\n}",
            "if": "if (${1:condition}) {\n    ${2}\n}",
            "try": "try {\n    ${1}\n} catch (${2:Exception} e) {\n    ${3}\n}",
        }
    },
    "kotlin": {
        "name": "Kotlin",
        "icon": "üéØ",
        "extensions": [".kt", ".kts"],
        "run": "kotlin {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "abstract", "actual", "annotation", "as", "break", "by", "catch",
            "class", "companion", "const", "constructor", "continue",
            "crossinline", "data", "delegate", "do", "dynamic", "else", "enum",
            "expect", "external", "false", "field", "final", "finally", "for",
            "fun", "get", "if", "import", "in", "infix", "init", "inline",
            "inner", "interface", "internal", "is", "it", "lateinit", "noinline",
            "null", "object", "open", "operator", "out", "override", "package",
            "private", "protected", "public", "reified", "return", "sealed",
            "set", "super", "suspend", "tailrec", "this", "throw", "true",
            "try", "typealias", "typeof", "val", "var", "vararg", "when",
            "where", "while"
        ],
    },
    "swift": {
        "name": "Swift",
        "icon": "üçé",
        "extensions": [".swift"],
        "run": "swift {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "associatedtype", "class", "deinit", "enum", "extension", "fileprivate",
            "func", "import", "init", "inout", "internal", "let", "open",
            "operator", "private", "precedencegroup", "protocol", "public",
            "rethrows", "static", "struct", "subscript", "typealias", "var",
            "break", "case", "catch", "continue", "default", "defer", "do",
            "else", "fallthrough", "for", "guard", "if", "in", "repeat",
            "return", "switch", "throw", "try", "where", "while", "Any",
            "as", "catch", "false", "is", "nil", "self", "Self", "super",
            "throw", "throws", "true", "try", "async", "await", "actor"
        ],
    },
    "c": {
        "name": "C",
        "icon": "‚öôÔ∏è",
        "extensions": [".c", ".h"],
        "run": "gcc {file} -o /tmp/a.out && /tmp/a.out",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "auto", "break", "case", "char", "const", "continue", "default",
            "do", "double", "else", "enum", "extern", "float", "for", "goto",
            "if", "inline", "int", "long", "register", "restrict", "return",
            "short", "signed", "sizeof", "static", "struct", "switch",
            "typedef", "union", "unsigned", "void", "volatile", "while",
            "_Bool", "_Complex", "_Imaginary", "NULL", "true", "false"
        ],
        "snippets": {
            "main": '#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    ${1}\n    return 0;\n}',
            "for": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n    ${3}\n}",
            "while": "while (${1:condition}) {\n    ${2}\n}",
            "if": "if (${1:condition}) {\n    ${2}\n}",
            "func": "${1:void} ${2:name}(${3:args}) {\n    ${4}\n}",
            "struct": "struct ${1:Name} {\n    ${2:type} ${3:field};\n};",
            "printf": 'printf("${1:%s}\\n", ${2:var});',
            "include": "#include <${1:stdio.h}>",
        }
    },
    "cpp": {
        "name": "C++",
        "icon": "‚öôÔ∏è",
        "extensions": [".cpp", ".cxx", ".cc", ".hpp", ".hxx", ".hh"],
        "run": "g++ {file} -o /tmp/a.out && /tmp/a.out",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel",
            "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor",
            "bool", "break", "case", "catch", "char", "char8_t", "char16_t",
            "char32_t", "class", "compl", "concept", "const", "consteval",
            "constexpr", "constinit", "const_cast", "continue", "co_await",
            "co_return", "co_yield", "decltype", "default", "delete", "do",
            "double", "dynamic_cast", "else", "enum", "explicit", "export",
            "extern", "false", "float", "for", "friend", "goto", "if",
            "inline", "int", "long", "mutable", "namespace", "new", "noexcept",
            "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private",
            "protected", "public", "reflexpr", "register", "reinterpret_cast",
            "requires", "return", "short", "signed", "sizeof", "static",
            "static_assert", "static_cast", "struct", "switch", "synchronized",
            "template", "this", "thread_local", "throw", "true", "try",
            "typedef", "typeid", "typename", "union", "unsigned", "using",
            "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"
        ],
        "snippets": {
            "main": '#include <iostream>\n\nint main() {\n    ${1}\n    return 0;\n}',
            "class": "class ${1:Name} {\npublic:\n    ${1:Name}();\n    ~${1:Name}();\nprivate:\n    ${2}\n};",
            "cout": 'std::cout << ${1} << std::endl;',
            "cin": 'std::cin >> ${1};',
            "vector": 'std::vector<${1:int}> ${2:vec};',
            "for": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n    ${3}\n}",
            "foreach": "for (auto& ${1:item} : ${2:container}) {\n    ${3}\n}",
        }
    },
    "csharp": {
        "name": "C#",
        "icon": "üî∑",
        "extensions": [".cs"],
        "run": "dotnet run",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 4,
        "keywords": [
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
            "char", "checked", "class", "const", "continue", "decimal", "default",
            "delegate", "do", "double", "else", "enum", "event", "explicit",
            "extern", "false", "finally", "fixed", "float", "for", "foreach",
            "goto", "if", "implicit", "in", "int", "interface", "internal",
            "is", "lock", "long", "namespace", "new", "null", "object",
            "operator", "out", "override", "params", "private", "protected",
            "public", "readonly", "ref", "return", "sbyte", "sealed", "short",
            "sizeof", "stackalloc", "static", "string", "struct", "switch",
            "this", "throw", "true", "try", "typeof", "uint", "ulong",
            "unchecked", "unsafe", "ushort", "using", "virtual", "void",
            "volatile", "while", "async", "await", "var", "dynamic", "yield",
            "nameof", "record", "init", "with", "required"
        ],
    },
    "bash": {
        "name": "Bash",
        "icon": "üíª",
        "extensions": [".sh", ".bash", ".zsh"],
        "run": "bash {file}",
        "comment": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "if", "then", "else", "elif", "fi", "case", "esac", "for", "select",
            "while", "until", "do", "done", "in", "function", "time", "coproc",
            "local", "return", "exit", "break", "continue", "declare", "typeset",
            "export", "readonly", "unset", "shift", "eval", "exec", "source",
            "alias", "unalias", "set", "shopt", "trap", "true", "false", "test"
        ],
        "builtins": [
            "echo", "printf", "read", "cd", "pwd", "pushd", "popd", "dirs",
            "type", "which", "whereis", "command", "builtin", "enable", "help",
            "let", "expr", "bc", "awk", "sed", "grep", "find", "xargs",
            "cat", "head", "tail", "sort", "uniq", "wc", "cut", "paste",
            "tr", "tee", "diff", "patch", "tar", "gzip", "zip", "curl", "wget"
        ],
        "snippets": {
            "shebang": "#!/bin/bash\n\n${1}",
            "if": 'if [[ ${1:condition} ]]; then\n    ${2}\nfi',
            "for": 'for ${1:i} in ${2:items}; do\n    ${3}\ndone',
            "while": 'while ${1:condition}; do\n    ${2}\ndone',
            "func": '${1:name}() {\n    ${2}\n}',
            "case": 'case ${1:var} in\n    ${2:pattern})\n        ${3}\n        ;;\n    *)\n        ${4}\n        ;;\nesac',
            "read": 'read -p "${1:Enter: }" ${2:var}',
        }
    },
    "powershell": {
        "name": "PowerShell",
        "icon": "üîµ",
        "extensions": [".ps1", ".psm1", ".psd1"],
        "run": "pwsh {file}",
        "comment": "#",
        "comment_multi": ["<#", "#>"],
        "indent": 4,
        "keywords": [
            "Begin", "Break", "Catch", "Class", "Continue", "Data", "Define",
            "Do", "DynamicParam", "Else", "ElseIf", "End", "Enum", "Exit",
            "Filter", "Finally", "For", "ForEach", "From", "Function", "Hidden",
            "If", "In", "InlineScript", "Parallel", "Param", "Process", "Return",
            "Sequence", "Switch", "Throw", "Trap", "Try", "Until", "Using",
            "Var", "While", "Workflow", "True", "False", "Null"
        ],
    },
    "lua": {
        "name": "Lua",
        "icon": "üåô",
        "extensions": [".lua"],
        "run": "lua {file}",
        "comment": "--",
        "comment_multi": ["--[[", "]]"],
        "indent": 2,
        "keywords": [
            "and", "break", "do", "else", "elseif", "end", "false", "for",
            "function", "goto", "if", "in", "local", "nil", "not", "or",
            "repeat", "return", "then", "true", "until", "while"
        ],
        "builtins": [
            "assert", "collectgarbage", "dofile", "error", "getmetatable",
            "ipairs", "load", "loadfile", "next", "pairs", "pcall", "print",
            "rawequal", "rawget", "rawlen", "rawset", "require", "select",
            "setmetatable", "tonumber", "tostring", "type", "xpcall",
            "coroutine", "debug", "io", "math", "os", "package", "string", "table"
        ],
    },
    "perl": {
        "name": "Perl",
        "icon": "üê™",
        "extensions": [".pl", ".pm", ".t"],
        "run": "perl {file}",
        "comment": "#",
        "comment_multi": ["=pod", "=cut"],
        "indent": 4,
        "keywords": [
            "and", "cmp", "continue", "do", "else", "elsif", "eq", "for",
            "foreach", "ge", "gt", "if", "last", "le", "lt", "my", "ne",
            "next", "no", "not", "or", "our", "package", "print", "redo",
            "require", "return", "say", "sub", "undef", "unless", "until",
            "use", "when", "while", "xor", "given", "state", "STDIN", "STDOUT",
            "STDERR", "BEGIN", "END", "CHECK", "INIT", "UNITCHECK"
        ],
    },
    "r": {
        "name": "R",
        "icon": "üìä",
        "extensions": [".r", ".R", ".Rmd"],
        "run": "Rscript {file}",
        "comment": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "if", "else", "repeat", "while", "function", "for", "in", "next",
            "break", "TRUE", "FALSE", "NULL", "Inf", "NaN", "NA", "NA_integer_",
            "NA_real_", "NA_complex_", "NA_character_", "library", "require",
            "return", "invisible", "local", "global"
        ],
    },
    "sql": {
        "name": "SQL",
        "icon": "üóÉÔ∏è",
        "extensions": [".sql"],
        "run": None,
        "comment": "--",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "BACKUP",
            "BETWEEN", "BY", "CASE", "CHECK", "COLUMN", "CONSTRAINT", "CREATE",
            "DATABASE", "DEFAULT", "DELETE", "DESC", "DISTINCT", "DROP", "EXEC",
            "EXISTS", "FOREIGN", "FROM", "FULL", "GROUP", "HAVING", "IN",
            "INDEX", "INNER", "INSERT", "INTO", "IS", "JOIN", "KEY", "LEFT",
            "LIKE", "LIMIT", "NOT", "NULL", "ON", "OR", "ORDER", "OUTER",
            "PRIMARY", "PROCEDURE", "RIGHT", "ROWNUM", "SELECT", "SET", "TABLE",
            "TOP", "TRUNCATE", "UNION", "UNIQUE", "UPDATE", "VALUES", "VIEW",
            "WHERE", "WITH", "GRANT", "REVOKE", "COMMIT", "ROLLBACK", "BEGIN",
            "END", "TRANSACTION", "TRIGGER", "CASCADE", "REFERENCES"
        ],
        "snippets": {
            "select": "SELECT ${1:*} FROM ${2:table} WHERE ${3:condition};",
            "insert": "INSERT INTO ${1:table} (${2:columns}) VALUES (${3:values});",
            "update": "UPDATE ${1:table} SET ${2:column} = ${3:value} WHERE ${4:condition};",
            "delete": "DELETE FROM ${1:table} WHERE ${2:condition};",
            "create": "CREATE TABLE ${1:name} (\n    ${2:id} INT PRIMARY KEY,\n    ${3:column} ${4:TYPE}\n);",
            "join": "SELECT * FROM ${1:t1}\nINNER JOIN ${2:t2} ON ${1:t1}.${3:id} = ${2:t2}.${4:id};",
        }
    },
    "json": {
        "name": "JSON",
        "icon": "üì¶",
        "extensions": [".json", ".jsonc"],
        "run": None,
        "comment": None,
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false", "null"],
    },
    "yaml": {
        "name": "YAML",
        "icon": "üìã",
        "extensions": [".yaml", ".yml"],
        "run": None,
        "comment": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false", "null", "yes", "no", "on", "off"],
    },
    "toml": {
        "name": "TOML",
        "icon": "‚öôÔ∏è",
        "extensions": [".toml"],
        "run": None,
        "comment": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false"],
    },
    "xml": {
        "name": "XML",
        "icon": "üìÑ",
        "extensions": [".xml", ".xsl", ".xslt", ".xsd", ".svg"],
        "run": None,
        "comment": "",
        "comment_multi": ["<!--", "-->"],
        "indent": 2,
        "keywords": [],
    },
    "markdown": {
        "name": "Markdown",
        "icon": "üìù",
        "extensions": [".md", ".markdown", ".mdown", ".mkd"],
        "run": None,
        "comment": None,
        "comment_multi": None,
        "indent": 2,
        "keywords": [],
    },
    "dockerfile": {
        "name": "Dockerfile",
        "icon": "üê≥",
        "extensions": ["Dockerfile", ".dockerfile"],
        "run": None,
        "comment": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "FROM", "RUN", "CMD", "LABEL", "MAINTAINER", "EXPOSE", "ENV",
            "ADD", "COPY", "ENTRYPOINT", "VOLUME", "USER", "WORKDIR", "ARG",
            "ONBUILD", "STOPSIGNAL", "HEALTHCHECK", "SHELL", "AS"
        ],
    },
    "graphql": {
        "name": "GraphQL",
        "icon": "üî∫",
        "extensions": [".graphql", ".gql"],
        "run": None,
        "comment": "#",
        "comment_multi": ['"""', '"""'],
        "indent": 2,
        "keywords": [
            "type", "interface", "union", "enum", "input", "scalar", "directive",
            "schema", "query", "mutation", "subscription", "fragment", "on",
            "extend", "implements", "true", "false", "null"
        ],
    },
    "dart": {
        "name": "Dart",
        "icon": "üéØ",
        "extensions": [".dart"],
        "run": "dart run {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "abstract", "as", "assert", "async", "await", "base", "break",
            "case", "catch", "class", "const", "continue", "covariant",
            "default", "deferred", "do", "dynamic", "else", "enum", "export",
            "extends", "extension", "external", "factory", "false", "final",
            "finally", "for", "Function", "get", "hide", "if", "implements",
            "import", "in", "interface", "is", "late", "library", "mixin",
            "new", "null", "on", "operator", "part", "required", "rethrow",
            "return", "sealed", "set", "show", "static", "super", "switch",
            "sync", "this", "throw", "true", "try", "typedef", "var", "void",
            "when", "while", "with", "yield"
        ],
    },
    "elixir": {
        "name": "Elixir",
        "icon": "üíß",
        "extensions": [".ex", ".exs"],
        "run": "elixir {file}",
        "comment": "#",
        "comment_multi": ['"""', '"""'],
        "indent": 2,
        "keywords": [
            "after", "alias", "and", "case", "catch", "cond", "def", "defcallback",
            "defdelegate", "defexception", "defimpl", "defmacro", "defmacrop",
            "defmodule", "defoverridable", "defp", "defprotocol", "defstruct",
            "do", "else", "end", "fn", "for", "if", "import", "in", "nil",
            "not", "or", "quote", "raise", "receive", "require", "reraise",
            "rescue", "super", "throw", "true", "false", "try", "unless",
            "unquote", "unquote_splicing", "use", "when", "with"
        ],
    },
    "scala": {
        "name": "Scala",
        "icon": "üî¥",
        "extensions": [".scala", ".sc"],
        "run": "scala {file}",
        "comment": "//",
        "comment_multi": ["/*", "*/"],
        "indent": 2,
        "keywords": [
            "abstract", "case", "catch", "class", "def", "do", "else", "extends",
            "false", "final", "finally", "for", "forSome", "if", "implicit",
            "import", "lazy", "macro", "match", "new", "null", "object",
            "override", "package", "private", "protected", "return", "sealed",
            "super", "this", "throw", "trait", "true", "try", "type", "val",
            "var", "while", "with", "yield", "given", "using", "extension",
            "transparent", "inline", "opaque", "enum", "then", "end", "export"
        ],
    },
    "haskell": {
        "name": "Haskell",
        "icon": "Œª",
        "extensions": [".hs", ".lhs"],
        "run": "runhaskell {file}",
        "comment": "--",
        "comment_multi": ["{-", "-}"],
        "indent": 2,
        "keywords": [
            "as", "case", "class", "data", "default", "deriving", "do", "else",
            "forall", "foreign", "hiding", "if", "import", "in", "infix",
            "infixl", "infixr", "instance", "let", "module", "newtype", "of",
            "qualified", "then", "type", "where", "True", "False", "Nothing",
            "Just", "Left", "Right", "IO", "Maybe", "Either"
        ],
    },
    "clojure": {
        "name": "Clojure",
        "icon": "üü¢",
        "extensions": [".clj", ".cljs", ".cljc", ".edn"],
        "run": "clojure {file}",
        "comment": ";",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "def", "defn", "defmacro", "defonce", "defn-", "fn", "let", "loop",
            "recur", "if", "if-not", "if-let", "when", "when-not", "when-let",
            "cond", "condp", "case", "do", "doseq", "dotimes", "for", "while",
            "try", "catch", "finally", "throw", "ns", "require", "use", "import",
            "refer", "nil", "true", "false", "and", "or", "not"
        ],
    },
    "vue": {
        "name": "Vue",
        "icon": "üíö",
        "extensions": [".vue"],
        "run": None,
        "comment": "//",
        "comment_multi": ["<!--", "-->"],
        "indent": 2,
        "keywords": [
            "template", "script", "style", "setup", "lang", "scoped", "module",
            "v-if", "v-else", "v-else-if", "v-for", "v-on", "v-bind", "v-model",
            "v-slot", "v-show", "v-html", "v-text", "v-once", "v-pre", "v-cloak",
            "ref", "reactive", "computed", "watch", "onMounted", "onUpdated",
            "defineProps", "defineEmits", "withDefaults"
        ],
    },
    "svelte": {
        "name": "Svelte",
        "icon": "üî•",
        "extensions": [".svelte"],
        "run": None,
        "comment": "//",
        "comment_multi": ["<!--", "-->"],
        "indent": 2,
        "keywords": [
            "script", "style", "each", "if", "else", "await", "then", "catch",
            "key", "html", "const", "debug", "bind", "on", "use", "class",
            "transition", "in", "out", "animate", "let", "export", "$"
        ],
    },
    "nginx": {
        "name": "Nginx",
        "icon": "‚ö°",
        "extensions": [".conf", "nginx.conf"],
        "run": None,
        "comment": "#",
        "comment_multi": None,
        "indent": 4,
        "keywords": [
            "server", "location", "upstream", "http", "events", "stream",
            "include", "listen", "server_name", "root", "index", "try_files",
            "proxy_pass", "fastcgi_pass", "return", "rewrite", "if", "set",
            "error_page", "access_log", "error_log", "ssl_certificate",
            "ssl_certificate_key", "worker_processes", "worker_connections"
        ],
    },
    "makefile": {
        "name": "Makefile",
        "icon": "üîß",
        "extensions": ["Makefile", "makefile", ".mk"],
        "run": "make",
        "comment": "#",
        "comment_multi": None,
        "indent": 4,  # Tabs –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã!
        "keywords": [
            "ifeq", "ifneq", "ifdef", "ifndef", "else", "endif", "define",
            "endef", "include", "override", "export", "unexport", "vpath",
            ".PHONY", ".SUFFIXES", ".DEFAULT", ".PRECIOUS", ".INTERMEDIATE",
            ".SECONDARY", ".SECONDEXPANSION", ".DELETE_ON_ERROR", ".IGNORE",
            ".LOW_RESOLUTION_TIME", ".SILENT", ".EXPORT_ALL_VARIABLES",
            ".NOTPARALLEL", ".ONESHELL", ".POSIX"
        ],
    },
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ê–í–¢–û–ü–ê–†–´ –°–ö–û–ë–û–ö
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

AUTO_PAIRS = {
    "(": ")",
    "[": "]",
    "{": "}",
    '"': '"',
    "'": "'",
    "`": "`",
    "<": ">",
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ò–ö–û–ù–ö–ò –§–ê–ô–õ–û–í
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

FILE_ICONS = {
    ".py": "üêç", ".js": "üìú", ".ts": "üí†", ".jsx": "‚öõÔ∏è", ".tsx": "‚öõÔ∏è",
    ".html": "üåê", ".css": "üé®", ".scss": "üé®", ".sass": "üé®",
    ".json": "üì¶", ".yaml": "üìã", ".yml": "üìã", ".toml": "‚öôÔ∏è",
    ".xml": "üìÑ", ".md": "üìù", ".txt": "üìÑ",
    ".php": "üêò", ".rb": "üíé", ".go": "üêπ", ".rs": "ü¶Ä",
    ".java": "‚òï", ".kt": "üéØ", ".swift": "üçé",
    ".c": "‚öôÔ∏è", ".cpp": "‚öôÔ∏è", ".h": "‚öôÔ∏è", ".hpp": "‚öôÔ∏è",
    ".cs": "üî∑", ".sh": "üíª", ".bash": "üíª", ".zsh": "üíª",
    ".ps1": "üîµ", ".lua": "üåô", ".pl": "üê™", ".r": "üìä",
    ".sql": "üóÉÔ∏è", ".graphql": "üî∫", ".gql": "üî∫",
    ".vue": "üíö", ".svelte": "üî•", ".dart": "üéØ",
    ".ex": "üíß", ".exs": "üíß", ".scala": "üî¥", ".hs": "Œª",
    ".clj": "üü¢", ".elm": "üå≥", ".erl": "üìû",
    ".dockerfile": "üê≥", "dockerfile": "üê≥",
    ".gitignore": "üôà", ".env": "üîê", ".lock": "üîí",
    ".png": "üñºÔ∏è", ".jpg": "üñºÔ∏è", ".gif": "üñºÔ∏è", ".svg": "üé®",
    ".mp3": "üéµ", ".mp4": "üé¨", ".pdf": "üìï",
    ".zip": "üì¶", ".tar": "üì¶", ".gz": "üì¶",
}

FOLDER_ICON = "üìÇ"
FOLDER_OPEN_ICON = "üìÇ"
FILE_DEFAULT_ICON = "üìÑ"

print("‚úÖ –ß–∞—Å—Ç—å 1/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: –û—Å–Ω–æ–≤–∞, –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã, —è–∑—ã–∫–∏")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ö–õ–ê–°–° BUFFER - –£–ü–†–ê–í–õ–ï–ù–ò–ï –¢–ï–ö–°–¢–û–ú
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Buffer:
    """–ë—É—Ñ–µ—Ä —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –æ–ø–µ—Ä–∞—Ü–∏–π —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    
    def __init__(self, content: str = ""):
        self.lines: List[str] = content.split('\n') if content else [""]
        self.modified: bool = False
        self.filename: Optional[str] = None
        self.language: Optional[str] = None
        self.encoding: str = "utf-8"
        self.line_ending: str = "\n"  # LF –∏–ª–∏ CRLF
        self.readonly: bool = False
        
    @property
    def line_count(self) -> int:
        return len(self.lines)
    
    @property
    def total_chars(self) -> int:
        return sum(len(line) for line in self.lines) + len(self.lines) - 1
    
    @property
    def total_words(self) -> int:
        text = '\n'.join(self.lines)
        return len(text.split())
    
    def get_line(self, row: int) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É –ø–æ –∏–Ω–¥–µ–∫—Å—É"""
        if 0 <= row < len(self.lines):
            return self.lines[row]
        return ""
    
    def set_line(self, row: int, text: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç —Å—Ç—Ä–æ–∫–∏"""
        if 0 <= row < len(self.lines):
            self.lines[row] = text
            self.modified = True
    
    def insert_char(self, row: int, col: int, char: str):
        """–í—Å—Ç–∞–≤–∏—Ç—å —Å–∏–º–≤–æ–ª –≤ –ø–æ–∑–∏—Ü–∏—é"""
        if 0 <= row < len(self.lines):
            line = self.lines[row]
            self.lines[row] = line[:col] + char + line[col:]
            self.modified = True
    
    def delete_char(self, row: int, col: int) -> str:
        """–£–¥–∞–ª–∏—Ç—å —Å–∏–º–≤–æ–ª –≤ –ø–æ–∑–∏—Ü–∏–∏ (Backspace)"""
        if row < 0 or row >= len(self.lines):
            return ""
        
        line = self.lines[row]
        
        if col > 0:
            deleted = line[col-1]
            self.lines[row] = line[:col-1] + line[col:]
            self.modified = True
            return deleted
        elif row > 0:
            # –û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Å—Ç—Ä–æ–∫–æ–π
            prev_line = self.lines[row - 1]
            self.lines[row - 1] = prev_line + line
            del self.lines[row]
            self.modified = True
            return "\n"
        return ""
    
    def delete_char_forward(self, row: int, col: int) -> str:
        """–£–¥–∞–ª–∏—Ç—å —Å–∏–º–≤–æ–ª –ø–æ—Å–ª–µ –∫—É—Ä—Å–æ—Ä–∞ (Delete)"""
        if row < 0 or row >= len(self.lines):
            return ""
        
        line = self.lines[row]
        
        if col < len(line):
            deleted = line[col]
            self.lines[row] = line[:col] + line[col+1:]
            self.modified = True
            return deleted
        elif row < len(self.lines) - 1:
            # –û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–æ–π
            next_line = self.lines[row + 1]
            self.lines[row] = line + next_line
            del self.lines[row + 1]
            self.modified = True
            return "\n"
        return ""
    
    def insert_newline(self, row: int, col: int) -> int:
        """–í—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É, –≤–µ—Ä–Ω—É—Ç—å –æ—Ç—Å—Ç—É–ø"""
        if 0 <= row < len(self.lines):
            line = self.lines[row]
            # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ—Ç—Å—Ç—É–ø —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏
            indent = len(line) - len(line.lstrip())
            
            # –†–∞–∑–¥–µ–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É
            self.lines[row] = line[:col]
            self.lines.insert(row + 1, " " * indent + line[col:].lstrip())
            self.modified = True
            return indent
        return 0
    
    def insert_line(self, row: int, text: str = ""):
        """–í—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É"""
        self.lines.insert(row, text)
        self.modified = True
    
    def delete_line(self, row: int) -> str:
        """–£–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É"""
        if 0 < len(self.lines) and 0 <= row < len(self.lines):
            deleted = self.lines[row]
            del self.lines[row]
            if len(self.lines) == 0:
                self.lines = [""]
            self.modified = True
            return deleted
        return ""
    
    def get_text(self) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç"""
        return self.line_ending.join(self.lines)
    
    def set_text(self, text: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç"""
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –ø–µ—Ä–µ–Ω–æ—Å–∞ —Å—Ç—Ä–æ–∫
        if '\r\n' in text:
            self.line_ending = '\r\n'
            text = text.replace('\r\n', '\n')
        elif '\r' in text:
            self.line_ending = '\r'
            text = text.replace('\r', '\n')
        
        self.lines = text.split('\n')
        self.modified = True
    
    def get_selection(self, start: Tuple[int, int], end: Tuple[int, int]) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç"""
        start_row, start_col = start
        end_row, end_col = end
        
        # –£–ø–æ—Ä—è–¥–æ—á–∏—Ç—å
        if (start_row, start_col) > (end_row, end_col):
            start_row, start_col, end_row, end_col = end_row, end_col, start_row, start_col
        
        if start_row == end_row:
            return self.lines[start_row][start_col:end_col]
        
        result = [self.lines[start_row][start_col:]]
        for row in range(start_row + 1, end_row):
            result.append(self.lines[row])
        result.append(self.lines[end_row][:end_col])
        
        return '\n'.join(result)
    
    def delete_selection(self, start: Tuple[int, int], end: Tuple[int, int]) -> str:
        """–£–¥–∞–ª–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç"""
        start_row, start_col = start
        end_row, end_col = end
        
        # –£–ø–æ—Ä—è–¥–æ—á–∏—Ç—å
        if (start_row, start_col) > (end_row, end_col):
            start_row, start_col, end_row, end_col = end_row, end_col, start_row, start_col
        
        deleted = self.get_selection((start_row, start_col), (end_row, end_col))
        
        # –£–¥–∞–ª–∏—Ç—å
        if start_row == end_row:
            line = self.lines[start_row]
            self.lines[start_row] = line[:start_col] + line[end_col:]
        else:
            first_part = self.lines[start_row][:start_col]
            last_part = self.lines[end_row][end_col:]
            self.lines[start_row] = first_part + last_part
            del self.lines[start_row + 1:end_row + 1]
        
        self.modified = True
        return deleted
    
    def insert_text(self, row: int, col: int, text: str) -> Tuple[int, int]:
        """–í—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç, –≤–µ—Ä–Ω—É—Ç—å –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞"""
        lines = text.split('\n')
        
        if len(lines) == 1:
            # –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞
            line = self.lines[row]
            self.lines[row] = line[:col] + text + line[col:]
            self.modified = True
            return (row, col + len(text))
        else:
            # –ù–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫
            first_line = self.lines[row]
            last_part = first_line[col:]
            
            self.lines[row] = first_line[:col] + lines[0]
            
            for i, line_text in enumerate(lines[1:-1], 1):
                self.lines.insert(row + i, line_text)
            
            self.lines.insert(row + len(lines) - 1, lines[-1] + last_part)
            self.modified = True
            
            return (row + len(lines) - 1, len(lines[-1]))
    
    def detect_language(self):
        """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —è–∑—ã–∫ –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é —Ñ–∞–π–ª–∞"""
        if not self.filename:
            return
        
        _, ext = os.path.splitext(self.filename)
        ext = ext.lower()
        name = os.path.basename(self.filename).lower()
        
        for lang_id, lang_data in LANGUAGES.items():
            extensions = lang_data.get("extensions", [])
            for e in extensions:
                if e.lower() == ext or e.lower() == name:
                    self.language = lang_id
                    return
        
        self.language = None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ö–õ–ê–°–° CURSOR - –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–£–†–°–û–†–û–ú
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Cursor:
    """–ö—É—Ä—Å–æ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤—ã–¥–µ–ª–µ–Ω–∏—è –∏ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∫—É—Ä—Å–æ—Ä–æ–≤"""
    
    def __init__(self, row: int = 0, col: int = 0):
        self.row: int = row
        self.col: int = col
        self.target_col: int = col  # –ñ–µ–ª–∞–µ–º–∞—è –∫–æ–ª–æ–Ω–∫–∞ –ø—Ä–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏
        
        # –í—ã–¥–µ–ª–µ–Ω–∏–µ
        self.selection_start: Optional[Tuple[int, int]] = None
        self.selection_active: bool = False
        
    @property
    def position(self) -> Tuple[int, int]:
        return (self.row, self.col)
    
    def move_to(self, row: int, col: int, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∫—É—Ä—Å–æ—Ä –≤ –ø–æ–∑–∏—Ü–∏—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –≥—Ä–∞–Ω–∏—Ü"""
        self.row = max(0, min(row, buffer.line_count - 1))
        line_len = len(buffer.get_line(self.row))
        self.col = max(0, min(col, line_len))
        self.target_col = self.col
    
    def move_up(self, buffer: Buffer, count: int = 1):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–≤–µ—Ä—Ö"""
        self.row = max(0, self.row - count)
        line_len = len(buffer.get_line(self.row))
        self.col = min(self.target_col, line_len)
    
    def move_down(self, buffer: Buffer, count: int = 1):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–Ω–∏–∑"""
        self.row = min(buffer.line_count - 1, self.row + count)
        line_len = len(buffer.get_line(self.row))
        self.col = min(self.target_col, line_len)
    
    def move_left(self, buffer: Buffer, count: int = 1):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–ª–µ–≤–æ"""
        for _ in range(count):
            if self.col > 0:
                self.col -= 1
            elif self.row > 0:
                self.row -= 1
                self.col = len(buffer.get_line(self.row))
        self.target_col = self.col
    
    def move_right(self, buffer: Buffer, count: int = 1):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–ø—Ä–∞–≤–æ"""
        for _ in range(count):
            line_len = len(buffer.get_line(self.row))
            if self.col < line_len:
                self.col += 1
            elif self.row < buffer.line_count - 1:
                self.row += 1
                self.col = 0
        self.target_col = self.col
    
    def move_word_left(self, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –Ω–∞ —Å–ª–æ–≤–æ –≤–ª–µ–≤–æ"""
        line = buffer.get_line(self.row)
        
        if self.col == 0 and self.row > 0:
            self.row -= 1
            self.col = len(buffer.get_line(self.row))
            return
        
        # –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–±–µ–ª—ã
        while self.col > 0 and (self.col > len(line) or line[self.col - 1].isspace()):
            self.col -= 1
        
        # –ù–∞–π—Ç–∏ –Ω–∞—á–∞–ª–æ —Å–ª–æ–≤–∞
        while self.col > 0 and not line[self.col - 1].isspace():
            self.col -= 1
        
        self.target_col = self.col
    
    def move_word_right(self, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –Ω–∞ —Å–ª–æ–≤–æ –≤–ø—Ä–∞–≤–æ"""
        line = buffer.get_line(self.row)
        line_len = len(line)
        
        if self.col >= line_len and self.row < buffer.line_count - 1:
            self.row += 1
            self.col = 0
            return
        
        # –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–ª–æ–≤–æ
        while self.col < line_len and not line[self.col].isspace():
            self.col += 1
        
        # –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–±–µ–ª—ã
        while self.col < line_len and line[self.col].isspace():
            self.col += 1
        
        self.target_col = self.col
    
    def move_home(self, buffer: Buffer, smart: bool = True):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ —Å—Ç—Ä–æ–∫–∏"""
        line = buffer.get_line(self.row)
        indent = len(line) - len(line.lstrip())
        
        if smart and self.col > indent:
            self.col = indent
        elif smart and self.col == indent and indent > 0:
            self.col = 0
        else:
            self.col = 0
        
        self.target_col = self.col
    
    def move_end(self, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –∫–æ–Ω–µ—Ü —Å—Ç—Ä–æ–∫–∏"""
        self.col = len(buffer.get_line(self.row))
        self.target_col = self.col
    
    def move_file_start(self, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞"""
        self.row = 0
        self.col = 0
        self.target_col = 0
    
    def move_file_end(self, buffer: Buffer):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞"""
        self.row = buffer.line_count - 1
        self.col = len(buffer.get_line(self.row))
        self.target_col = self.col
    
    def start_selection(self):
        """–ù–∞—á–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ"""
        if not self.selection_active:
            self.selection_start = (self.row, self.col)
            self.selection_active = True
    
    def end_selection(self):
        """–ó–∞–∫–æ–Ω—á–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ"""
        self.selection_active = False
        self.selection_start = None
    
    def get_selection_range(self) -> Optional[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω –≤—ã–¥–µ–ª–µ–Ω–∏—è"""
        if not self.selection_start:
            return None
        
        start = self.selection_start
        end = (self.row, self.col)
        
        if start > end:
            start, end = end, start
        
        return (start, end)
    
    def has_selection(self) -> bool:
        """–ï—Å—Ç—å –ª–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ"""
        return self.selection_start is not None and self.selection_start != (self.row, self.col)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ö–õ–ê–°–° HISTORY - UNDO/REDO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class HistoryAction:
    """–û–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏"""
    
    def __init__(self, action_type: str, data: Dict[str, Any], cursor_before: Tuple[int, int]):
        self.action_type = action_type  # insert, delete, replace
        self.data = data
        self.cursor_before = cursor_before
        self.cursor_after: Optional[Tuple[int, int]] = None
        self.timestamp = time.time()


class History:
    """–ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π undo/redo"""
    
    def __init__(self, max_size: int = MAX_UNDO_HISTORY):
        self.undo_stack: List[HistoryAction] = []
        self.redo_stack: List[HistoryAction] = []
        self.max_size = max_size
        self.batch_mode = False
        self.batch_actions: List[HistoryAction] = []
        
    def push(self, action: HistoryAction):
        """–î–æ–±–∞–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        if self.batch_mode:
            self.batch_actions.append(action)
        else:
            self.undo_stack.append(action)
            self.redo_stack.clear()
            
            # –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä
            while len(self.undo_stack) > self.max_size:
                self.undo_stack.pop(0)
    
    def begin_batch(self):
        """–ù–∞—á–∞—Ç—å –ø–∞–∫–µ—Ç –¥–µ–π—Å—Ç–≤–∏–π"""
        self.batch_mode = True
        self.batch_actions = []
    
    def end_batch(self):
        """–ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–∞–∫–µ—Ç –¥–µ–π—Å—Ç–≤–∏–π"""
        if self.batch_actions:
            # –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –≤ –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ
            combined = HistoryAction(
                "batch",
                {"actions": self.batch_actions},
                self.batch_actions[0].cursor_before
            )
            combined.cursor_after = self.batch_actions[-1].cursor_after
            self.undo_stack.append(combined)
            self.redo_stack.clear()
        
        self.batch_mode = False
        self.batch_actions = []
    
    def can_undo(self) -> bool:
        return len(self.undo_stack) > 0
    
    def can_redo(self) -> bool:
        return len(self.redo_stack) > 0
    
    def undo(self, buffer: Buffer, cursor: Cursor) -> bool:
        """–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ"""
        if not self.can_undo():
            return False
        
        action = self.undo_stack.pop()
        self._reverse_action(action, buffer, cursor)
        self.redo_stack.append(action)
        return True
    
    def redo(self, buffer: Buffer, cursor: Cursor) -> bool:
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ—Ç–º–µ–Ω—ë–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"""
        if not self.can_redo():
            return False
        
        action = self.redo_stack.pop()
        self._apply_action(action, buffer, cursor)
        self.undo_stack.append(action)
        return True
    
    def _reverse_action(self, action: HistoryAction, buffer: Buffer, cursor: Cursor):
        """–û—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ"""
        if action.action_type == "batch":
            for sub_action in reversed(action.data["actions"]):
                self._reverse_action(sub_action, buffer, cursor)
        elif action.action_type == "insert":
            # –£–¥–∞–ª–∏—Ç—å –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ
            row, col = action.data["position"]
            text = action.data["text"]
            lines = text.split('\n')
            
            if len(lines) == 1:
                line = buffer.get_line(row)
                buffer.set_line(row, line[:col] + line[col + len(text):])
            else:
                # –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
                end_row = row + len(lines) - 1
                end_col = len(lines[-1])
                buffer.delete_selection((row, col), (end_row, end_col))
        
        elif action.action_type == "delete":
            # –í—Å—Ç–∞–≤–∏—Ç—å —É–¥–∞–ª—ë–Ω–Ω–æ–µ
            row, col = action.data["position"]
            text = action.data["text"]
            buffer.insert_text(row, col, text)
        
        elif action.action_type == "replace":
            # –ó–∞–º–µ–Ω–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ
            row, col = action.data["position"]
            old_text = action.data["old_text"]
            new_text = action.data["new_text"]
            
            # –£–¥–∞–ª–∏—Ç—å –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç, –≤—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã–π
            lines = new_text.split('\n')
            if len(lines) == 1:
                line = buffer.get_line(row)
                buffer.set_line(row, line[:col] + old_text + line[col + len(new_text):])
            else:
                end_row = row + len(lines) - 1
                end_col = len(lines[-1])
                buffer.delete_selection((row, col), (end_row, end_col))
                buffer.insert_text(row, col, old_text)
        
        cursor.move_to(action.cursor_before[0], action.cursor_before[1], buffer)
    
    def _apply_action(self, action: HistoryAction, buffer: Buffer, cursor: Cursor):
        """–ü—Ä–∏–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ (redo)"""
        if action.action_type == "batch":
            for sub_action in action.data["actions"]:
                self._apply_action(sub_action, buffer, cursor)
        elif action.action_type == "insert":
            row, col = action.data["position"]
            text = action.data["text"]
            buffer.insert_text(row, col, text)
        elif action.action_type == "delete":
            row, col = action.data["position"]
            text = action.data["text"]
            lines = text.split('\n')
            if len(lines) == 1:
                line = buffer.get_line(row)
                buffer.set_line(row, line[:col] + line[col + len(text):])
            else:
                end_row = row + len(lines) - 1
                end_col = len(lines[-1])
                buffer.delete_selection((row, col), (end_row, end_col))
        elif action.action_type == "replace":
            row, col = action.data["position"]
            old_text = action.data["old_text"]
            new_text = action.data["new_text"]
            lines = old_text.split('\n')
            if len(lines) == 1:
                line = buffer.get_line(row)
                buffer.set_line(row, line[:col] + new_text + line[col + len(old_text):])
            else:
                end_row = row + len(lines) - 1
                end_col = len(lines[-1])
                buffer.delete_selection((row, col), (end_row, end_col))
                buffer.insert_text(row, col, new_text)
        
        if action.cursor_after:
            cursor.move_to(action.cursor_after[0], action.cursor_after[1], buffer)
    
    def clear(self):
        """–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é"""
        self.undo_stack.clear()
        self.redo_stack.clear()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ö–õ–ê–°–° CLIPBOARD - –ë–£–§–ï–† –û–ë–ú–ï–ù–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Clipboard:
    """–ë—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ —Å –∏—Å—Ç–æ—Ä–∏–µ–π"""
    
    def __init__(self, max_history: int = MAX_CLIPBOARD_HISTORY):
        self.history: List[str] = []
        self.max_history = max_history
        self.current_index = 0
    
    def copy(self, text: str):
        """–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç"""
        if text:
            # –£–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
            if text in self.history:
                self.history.remove(text)
            
            self.history.insert(0, text)
            
            # –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä
            while len(self.history) > self.max_history:
                self.history.pop()
            
            self.current_index = 0
            
            # –°–∏—Å—Ç–µ–º–Ω—ã–π –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
            self._copy_to_system(text)
    
    def paste(self) -> str:
        """–í—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç"""
        # –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –±—É—Ñ–µ—Ä
        system_text = self._paste_from_system()
        if system_text:
            if not self.history or self.history[0] != system_text:
                self.copy(system_text)
            return system_text
        
        if self.history:
            return self.history[0]
        return ""
    
    def get_history(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –±—É—Ñ–µ—Ä–∞"""
        return self.history.copy()
    
    def paste_from_history(self, index: int) -> str:
        """–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏"""
        if 0 <= index < len(self.history):
            return self.history[index]
        return ""
    
    def _copy_to_system(self, text: str):
        """–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º–Ω—ã–π –±—É—Ñ–µ—Ä"""
        try:
            if Platform.IS_TERMUX:
                subprocess.run(['termux-clipboard-set'], input=text.encode(), check=True)
            elif Platform.IS_MACOS:
                subprocess.run(['pbcopy'], input=text.encode(), check=True)
            elif Platform.IS_LINUX:
                try:
                    subprocess.run(['xclip', '-selection', 'clipboard'], 
                                 input=text.encode(), check=True)
                except:
                    subprocess.run(['xsel', '--clipboard', '--input'], 
                                 input=text.encode(), check=True)
        except:
            pass
    
    def _paste_from_system(self) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–∑ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∞"""
        try:
            if Platform.IS_TERMUX:
                result = subprocess.run(['termux-clipboard-get'], 
                                       capture_output=True, text=True)
                return result.stdout
            elif Platform.IS_MACOS:
                result = subprocess.run(['pbpaste'], capture_output=True, text=True)
                return result.stdout
            elif Platform.IS_LINUX:
                try:
                    result = subprocess.run(['xclip', '-selection', 'clipboard', '-o'], 
                                           capture_output=True, text=True)
                    return result.stdout
                except:
                    result = subprocess.run(['xsel', '--clipboard', '--output'], 
                                           capture_output=True, text=True)
                    return result.stdout
        except:
            pass
        return ""


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –£–¢–ò–õ–ò–¢–´
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Utils:
    """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏"""
    
    @staticmethod
    def truncate(text: str, max_len: int, suffix: str = "...") -> str:
        """–û–±—Ä–µ–∑–∞—Ç—å —Ç–µ–∫—Å—Ç"""
        if len(text) <= max_len:
            return text
        return text[:max_len - len(suffix)] + suffix
    
    @staticmethod
    def pad(text: str, width: int, align: str = "left", fill: str = " ") -> str:
        """–í—ã—Ä–æ–≤–Ω—è—Ç—å —Ç–µ–∫—Å—Ç"""
        if len(text) >= width:
            return text[:width]
        
        padding = width - len(text)
        if align == "left":
            return text + fill * padding
        elif align == "right":
            return fill * padding + text
        else:  # center
            left = padding // 2
            right = padding - left
            return fill * left + text + fill * right
    
    @staticmethod
    def format_size(size: int) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"
    
    @staticmethod
    def format_time(seconds: int) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è"""
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        secs = seconds % 60
        
        if hours > 0:
            return f"{hours}:{minutes:02d}:{secs:02d}"
        return f"{minutes}:{secs:02d}"
    
    @staticmethod
    def get_file_icon(filename: str) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–∫–æ–Ω–∫—É –¥–ª—è —Ñ–∞–π–ª–∞"""
        if os.path.isdir(filename):
            return FOLDER_ICON
        
        name = os.path.basename(filename).lower()
        _, ext = os.path.splitext(name)
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–ª–Ω–æ–µ –∏–º—è
        if name in FILE_ICONS:
            return FILE_ICONS[name]
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
        return FILE_ICONS.get(ext, FILE_DEFAULT_ICON)
    
    @staticmethod
    def safe_read_file(filepath: str) -> Tuple[str, str]:
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —á—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫–∏"""
        encodings = ['utf-8', 'utf-8-sig', 'cp1251', 'cp866', 'iso-8859-1', 'utf-16']
        
        for encoding in encodings:
            try:
                with open(filepath, 'r', encoding=encoding) as f:
                    content = f.read()
                return content, encoding
            except (UnicodeDecodeError, LookupError):
                continue
            except Exception as e:
                raise e
        
        raise UnicodeDecodeError("Failed to decode file with any known encoding")
    
    @staticmethod
    def safe_write_file(filepath: str, content: str, encoding: str = 'utf-8') -> bool:
        """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–ø–∏—Å—å —Ñ–∞–π–ª–∞"""
        # –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—Å–∞—Ç—å –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        temp_path = filepath + '.tmp'
        try:
            with open(temp_path, 'w', encoding=encoding) as f:
                f.write(content)
            
            # –ó–∞–º–µ–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª
            if os.path.exists(filepath):
                backup_path = filepath + '.bak'
                if os.path.exists(backup_path):
                    os.remove(backup_path)
                os.rename(filepath, backup_path)
            
            os.rename(temp_path, filepath)
            
            # –£–¥–∞–ª–∏—Ç—å –±—ç–∫–∞–ø
            backup_path = filepath + '.bak'
            if os.path.exists(backup_path):
                os.remove(backup_path)
            
            return True
        except Exception as e:
            if os.path.exists(temp_path):
                os.remove(temp_path)
            raise e
    
    @staticmethod
    def get_relative_path(path: str, base: str = None) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å"""
        if base is None:
            base = os.getcwd()
        try:
            return os.path.relpath(path, base)
        except ValueError:
            return path
    
    @staticmethod
    def is_binary_file(filepath: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –±–∏–Ω–∞—Ä–Ω—ã–º"""
        try:
            with open(filepath, 'rb') as f:
                chunk = f.read(8192)
                if b'\x00' in chunk:
                    return True
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
                text_chars = bytearray({7, 8, 9, 10, 12, 13, 27} | 
                                        set(range(0x20, 0x100)) - {0x7f})
                non_text = sum(1 for b in chunk if b not in text_chars)
                return non_text / len(chunk) > 0.3 if chunk else False
        except:
            return True


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ù–ê–°–¢–†–û–ô–ö–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Settings:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
    
    DEFAULTS = {
        "theme": "cosmos",
        "tab_size": 4,
        "use_spaces": True,
        "auto_indent": True,
        "auto_pairs": True,
        "show_line_numbers": True,
        "highlight_current_line": True,
        "word_wrap": False,
        "autosave": True,
        "autosave_interval": 60,
        "font_size": 12,
        "show_minimap": False,
        "show_whitespace": False,
        "trim_trailing_whitespace": True,
        "insert_final_newline": True,
        "encoding": "utf-8",
        "line_ending": "lf",
        "recent_files": [],
        "max_recent_files": 20,
        "ai_provider": None,
        "ai_model": None,
        "beginner_mode": False,
        "hints_enabled": True,
        "show_hints_delay": 2,
    }
    
    def __init__(self):
        self.data = self.DEFAULTS.copy()
        self.load()
    
    def load(self):
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded = json.load(f)
                    self.data.update(loaded)
        except:
            pass
    
    def save(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        try:
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=2, ensure_ascii=False)
        except:
            pass
    
    def get(self, key: str, default=None):
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É"""
        return self.data.get(key, default if default is not None else self.DEFAULTS.get(key))
    
    def set(self, key: str, value):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É"""
        self.data[key] = value
        self.save()
    
    def add_recent_file(self, filepath: str):
        """–î–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª –≤ –Ω–µ–¥–∞–≤–Ω–∏–µ"""
        recent = self.data.get("recent_files", [])
        
        # –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
        filepath = os.path.abspath(filepath)
        
        # –£–¥–∞–ª–∏—Ç—å –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å
        if filepath in recent:
            recent.remove(filepath)
        
        # –î–æ–±–∞–≤–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ
        recent.insert(0, filepath)
        
        # –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä
        max_files = self.data.get("max_recent_files", 20)
        self.data["recent_files"] = recent[:max_files]
        self.save()
    
    def get_recent_files(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–µ–¥–∞–≤–Ω–∏–µ —Ñ–∞–π–ª—ã"""
        recent = self.data.get("recent_files", [])
        # –§–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ
        return [f for f in recent if os.path.exists(f)]


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
settings = Settings()

print("‚úÖ –ß–∞—Å—Ç—å 2/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: Buffer, Cursor, History, Clipboard, Utils, Settings")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–û–î–°–í–ï–¢–ö–ê –°–ò–ù–¢–ê–ö–°–ò–°–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SyntaxHighlighter:
    """–î–≤–∏–∂–æ–∫ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤"""
    
    def __init__(self):
        self.cache: Dict[str, List[List[Tuple[str, int]]]] = {}
        self.cache_valid: Dict[str, bool] = {}
        
    def invalidate_cache(self, buffer_id: str):
        """–°–±—Ä–æ—Å–∏—Ç—å –∫—ç—à –¥–ª—è –±—É—Ñ–µ—Ä–∞"""
        self.cache_valid[buffer_id] = False
    
    def highlight_line(self, line: str, language: Optional[str], 
                       theme: Dict, in_multiline_string: bool = False,
                       in_multiline_comment: bool = False) -> Tuple[List[Tuple[str, int]], bool, bool]:
        """
        –ü–æ–¥—Å–≤–µ—Ç–∏—Ç—å –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (—Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤, –≤_–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–π_—Å—Ç—Ä–æ–∫–µ, –≤_–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–º_–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏)
        """
        if not language or language not in LANGUAGES:
            return [(line, Colors.get_pair(Colors.WHITE))], False, False
        
        lang = LANGUAGES[language]
        tokens = []
        i = 0
        line_len = len(line)
        
        # –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç–∞ –∏–∑ —Ç–µ–º—ã
        keyword_color = Colors.get_pair(theme.get("keyword", Colors.MAGENTA))
        string_color = Colors.get_pair(theme.get("string", Colors.GREEN))
        comment_color = Colors.get_pair(theme.get("comment", Colors.CYAN))
        number_color = Colors.get_pair(theme.get("number", Colors.YELLOW))
        function_color = Colors.get_pair(theme.get("function", Colors.BLUE))
        class_color = Colors.get_pair(theme.get("class_name", Colors.CYAN))
        operator_color = Colors.get_pair(theme.get("operator", Colors.WHITE))
        default_color = Colors.get_pair(theme.get("fg", Colors.WHITE))
        builtin_color = Colors.get_pair(theme.get("builtin", Colors.CYAN))
        type_color = Colors.get_pair(theme.get("type", Colors.CYAN))
        tag_color = Colors.get_pair(theme.get("tag", Colors.RED))
        attribute_color = Colors.get_pair(theme.get("attribute", Colors.YELLOW))
        
        # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
        if in_multiline_comment:
            comment_multi = lang.get("comment_multi")
            if comment_multi:
                end_marker = comment_multi[1]
                end_idx = line.find(end_marker)
                if end_idx != -1:
                    tokens.append((line[:end_idx + len(end_marker)], comment_color))
                    i = end_idx + len(end_marker)
                    in_multiline_comment = False
                else:
                    return [(line, comment_color)], in_multiline_string, True
        
        # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        if in_multiline_string:
            # –ò—â–µ–º –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ –∫–∞–≤—ã—á–∫–∏
            for quote in ['"""', "'''", '`']:
                end_idx = line.find(quote)
                if end_idx != -1:
                    tokens.append((line[:end_idx + len(quote)], string_color))
                    i = end_idx + len(quote)
                    in_multiline_string = False
                    break
            else:
                return [(line, string_color)], True, in_multiline_comment
        
        keywords = set(lang.get("keywords", []))
        builtins = set(lang.get("builtins", []))
        types = set(lang.get("types", []))
        tags = set(lang.get("tags", []))
        properties = set(lang.get("properties", []))
        comment_single = lang.get("comment")
        comment_multi = lang.get("comment_multi")
        
        operators = {'+', '-', '*', '/', '%', '=', '<', '>', '!', '&', '|', '^', '~', ':', ';', ',', '.'}
        brackets = {'(', ')', '[', ']', '{', '}'}
        
        while i < line_len:
            # –û–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
            if comment_single and line[i:].startswith(comment_single):
                tokens.append((line[i:], comment_color))
                break
            
            # –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–∞—á–∞–ª–æ
            if comment_multi and line[i:].startswith(comment_multi[0]):
                end_marker = comment_multi[1]
                end_idx = line.find(end_marker, i + len(comment_multi[0]))
                if end_idx != -1:
                    tokens.append((line[i:end_idx + len(end_marker)], comment_color))
                    i = end_idx + len(end_marker)
                else:
                    tokens.append((line[i:], comment_color))
                    return tokens, in_multiline_string, True
                continue
            
            # –°—Ç—Ä–æ–∫–∏
            if line[i] in '"\'`':
                quote = line[i]
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç—Ä–æ–π–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
                if line[i:i+3] in ['"""', "'''"]:
                    triple_quote = line[i:i+3]
                    end_idx = line.find(triple_quote, i + 3)
                    if end_idx != -1:
                        tokens.append((line[i:end_idx + 3], string_color))
                        i = end_idx + 3
                    else:
                        tokens.append((line[i:], string_color))
                        return tokens, True, in_multiline_comment
                    continue
                
                # –û–±—ã—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
                j = i + 1
                while j < line_len:
                    if line[j] == '\\' and j + 1 < line_len:
                        j += 2
                    elif line[j] == quote:
                        j += 1
                        break
                    else:
                        j += 1
                tokens.append((line[i:j], string_color))
                i = j
                continue
            
            # –ß–∏—Å–ª–∞
            if line[i].isdigit() or (line[i] == '.' and i + 1 < line_len and line[i+1].isdigit()):
                j = i
                has_dot = False
                has_exp = False
                # –®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ
                if line[i:i+2].lower() in ['0x', '0b', '0o']:
                    j = i + 2
                    while j < line_len and (line[j].isalnum() or line[j] == '_'):
                        j += 1
                else:
                    while j < line_len:
                        if line[j].isdigit() or line[j] == '_':
                            j += 1
                        elif line[j] == '.' and not has_dot:
                            has_dot = True
                            j += 1
                        elif line[j].lower() in 'ej' and not has_exp:
                            has_exp = True
                            j += 1
                            if j < line_len and line[j] in '+-':
                                j += 1
                        elif line[j].lower() in 'fldul':
                            j += 1
                            break
                        else:
                            break
                tokens.append((line[i:j], number_color))
                i = j
                continue
            
            # –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
            if line[i].isalpha() or line[i] == '_':
                j = i
                while j < line_len and (line[j].isalnum() or line[j] == '_'):
                    j += 1
                word = line[i:j]
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é (–∑–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Å–ª–µ–¥—É–µ—Ç ()
                is_function = j < line_len and line[j] == '('
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–ª–∞—Å—Å (—Å–ª–µ–¥—É–µ—Ç –∑–∞ class/def –∏–ª–∏ —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã)
                is_class = word[0].isupper() and not word.isupper()
                
                if word in keywords:
                    tokens.append((word, keyword_color | curses.A_BOLD))
                elif word in builtins:
                    tokens.append((word, builtin_color))
                elif word in types:
                    tokens.append((word, type_color))
                elif word in tags:
                    tokens.append((word, tag_color))
                elif word in properties:
                    tokens.append((word, attribute_color))
                elif is_function:
                    tokens.append((word, function_color))
                elif is_class:
                    tokens.append((word, class_color))
                else:
                    tokens.append((word, default_color))
                i = j
                continue
            
            # –î–µ–∫–æ—Ä–∞—Ç–æ—Ä—ã (Python, Java, etc.)
            if line[i] == '@' and i + 1 < line_len and (line[i+1].isalpha() or line[i+1] == '_'):
                j = i + 1
                while j < line_len and (line[j].isalnum() or line[j] == '_'):
                    j += 1
                tokens.append((line[i:j], keyword_color | curses.A_BOLD))
                i = j
                continue
            
            # HTML/XML —Ç–µ–≥–∏
            if language in ['html', 'xml', 'vue', 'svelte'] and line[i] == '<':
                j = i + 1
                if j < line_len and line[j] == '/':
                    j += 1
                while j < line_len and (line[j].isalnum() or line[j] in '-_'):
                    j += 1
                tokens.append((line[i:j], tag_color))
                i = j
                continue
            
            # –û–ø–µ—Ä–∞—Ç–æ—Ä—ã
            if line[i] in operators:
                j = i
                while j < line_len and line[j] in operators:
                    j += 1
                tokens.append((line[i:j], operator_color))
                i = j
                continue
            
            # –°–∫–æ–±–∫–∏
            if line[i] in brackets:
                tokens.append((line[i], operator_color))
                i += 1
                continue
            
            # –ü—Ä–æ–±–µ–ª—ã –∏ –æ—Å—Ç–∞–ª—å–Ω–æ–µ
            tokens.append((line[i], default_color))
            i += 1
        
        return tokens, in_multiline_string, in_multiline_comment
    
    def get_highlighted_lines(self, buffer: Buffer, theme: Dict) -> List[List[Tuple[str, int]]]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏"""
        result = []
        in_string = False
        in_comment = False
        
        for i, line in enumerate(buffer.lines):
            tokens, in_string, in_comment = self.highlight_line(
                line, buffer.language, theme, in_string, in_comment
            )
            result.append(tokens)
        
        return result


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB/–í–ö–õ–ê–î–ö–ê –†–ï–î–ê–ö–¢–û–†–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Tab:
    """–í–∫–ª–∞–¥–∫–∞ —Å —Ñ–∞–π–ª–æ–º"""
    
    def __init__(self, filename: Optional[str] = None):
        self.buffer = Buffer()
        self.cursor = Cursor()
        self.history = History()
        self.scroll_row = 0
        self.scroll_col = 0
        self.id = id(self)
        
        if filename:
            self.load_file(filename)
        else:
            self.buffer.filename = None
            self.buffer.language = "python"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
    @property
    def title(self) -> str:
        """–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤–∫–ª–∞–¥–∫–∏"""
        if self.buffer.filename:
            name = os.path.basename(self.buffer.filename)
        else:
            name = "–ë–µ–∑ –∏–º–µ–Ω–∏"
        
        if self.buffer.modified:
            name += " ‚óè"
        
        return name
    
    @property
    def icon(self) -> str:
        """–ò–∫–æ–Ω–∫–∞ —Ñ–∞–π–ª–∞"""
        if self.buffer.filename:
            return Utils.get_file_icon(self.buffer.filename)
        return "üìÑ"
    
    def load_file(self, filename: str) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª"""
        try:
            filepath = os.path.abspath(filename)
            
            if not os.path.exists(filepath):
                # –ù–æ–≤—ã–π —Ñ–∞–π–ª
                self.buffer.filename = filepath
                self.buffer.lines = [""]
                self.buffer.modified = False
                self.buffer.detect_language()
                return True
            
            if os.path.isdir(filepath):
                return False
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª
            if Utils.is_binary_file(filepath):
                return False
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
            size = os.path.getsize(filepath)
            if size > MAX_FILE_SIZE_MB * 1024 * 1024:
                return False
            
            content, encoding = Utils.safe_read_file(filepath)
            self.buffer.set_text(content)
            self.buffer.filename = filepath
            self.buffer.encoding = encoding
            self.buffer.modified = False
            self.buffer.detect_language()
            
            self.history.clear()
            self.cursor.move_to(0, 0, self.buffer)
            self.scroll_row = 0
            self.scroll_col = 0
            
            settings.add_recent_file(filepath)
            return True
            
        except Exception as e:
            return False
    
    def save_file(self, filename: Optional[str] = None) -> Tuple[bool, str]:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª"""
        try:
            if filename:
                self.buffer.filename = os.path.abspath(filename)
                self.buffer.detect_language()
            
            if not self.buffer.filename:
                return False, "–ù–µ —É–∫–∞–∑–∞–Ω–æ –∏–º—è —Ñ–∞–π–ª–∞"
            
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç
            content = self.buffer.get_text()
            
            # –£–±—Ä–∞—Ç—å trailing whitespace –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
            if settings.get("trim_trailing_whitespace"):
                lines = content.split('\n')
                lines = [line.rstrip() for line in lines]
                content = '\n'.join(lines)
            
            # –î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–π newline –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
            if settings.get("insert_final_newline"):
                if not content.endswith('\n'):
                    content += '\n'
            
            # –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            dirname = os.path.dirname(self.buffer.filename)
            if dirname and not os.path.exists(dirname):
                os.makedirs(dirname)
            
            Utils.safe_write_file(self.buffer.filename, content, self.buffer.encoding)
            self.buffer.modified = False
            
            settings.add_recent_file(self.buffer.filename)
            return True, f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {self.buffer.filename}"
            
        except PermissionError:
            return False, "–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –∑–∞–ø–∏—Å—å"
        except Exception as e:
            return False, f"–û—à–∏–±–∫–∞: {str(e)}"
    
    def ensure_cursor_visible(self, height: int, width: int, line_num_width: int):
        """–£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –∫—É—Ä—Å–æ—Ä –≤–∏–¥–∏–º"""
        # –£—á–∏—Ç—ã–≤–∞–µ–º —à–∏—Ä–∏–Ω—É –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–æ–∫
        text_width = width - line_num_width - 1
        text_height = height
        
        # –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞
        if self.cursor.row < self.scroll_row:
            self.scroll_row = self.cursor.row
        elif self.cursor.row >= self.scroll_row + text_height:
            self.scroll_row = self.cursor.row - text_height + 1
        
        # –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞
        if self.cursor.col < self.scroll_col:
            self.scroll_col = max(0, self.cursor.col - 5)
        elif self.cursor.col >= self.scroll_col + text_width:
            self.scroll_col = self.cursor.col - text_width + 5


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ú–ï–ù–ï–î–ñ–ï–† –í–ö–õ–ê–î–û–ö
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TabManager:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∞–º–∏"""
    
    def __init__(self):
        self.tabs: List[Tab] = []
        self.active_index: int = 0
    
    @property
    def active_tab(self) -> Optional[Tab]:
        if 0 <= self.active_index < len(self.tabs):
            return self.tabs[self.active_index]
        return None
    
    @property
    def count(self) -> int:
        return len(self.tabs)
    
    def new_tab(self, filename: Optional[str] = None) -> Tab:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≤–∫–ª–∞–¥–∫—É"""
        tab = Tab(filename)
        self.tabs.append(tab)
        self.active_index = len(self.tabs) - 1
        return tab
    
    def close_tab(self, index: Optional[int] = None) -> bool:
        """–ó–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É"""
        if index is None:
            index = self.active_index
        
        if 0 <= index < len(self.tabs):
            tab = self.tabs[index]
            
            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            if tab.buffer.modified:
                return False  # –ù—É–∂–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            
            del self.tabs[index]
            
            if self.active_index >= len(self.tabs):
                self.active_index = max(0, len(self.tabs) - 1)
            
            return True
        return False
    
    def next_tab(self):
        """–°–ª–µ–¥—É—é—â–∞—è –≤–∫–ª–∞–¥–∫–∞"""
        if self.tabs:
            self.active_index = (self.active_index + 1) % len(self.tabs)
    
    def prev_tab(self):
        """–ü—Ä–µ–¥—ã–¥—É—â–∞—è –≤–∫–ª–∞–¥–∫–∞"""
        if self.tabs:
            self.active_index = (self.active_index - 1) % len(self.tabs)
    
    def goto_tab(self, index: int):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–∫–ª–∞–¥–∫–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É"""
        if 0 <= index < len(self.tabs):
            self.active_index = index
    
    def find_tab_by_filename(self, filename: str) -> Optional[int]:
        """–ù–∞–π—Ç–∏ –≤–∫–ª–∞–¥–∫—É –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        abs_path = os.path.abspath(filename)
        for i, tab in enumerate(self.tabs):
            if tab.buffer.filename == abs_path:
                return i
        return None
    
    def open_file(self, filename: str) -> Optional[Tab]:
        """–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª (–≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∏–ª–∏ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ)"""
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ –æ—Ç–∫—Ä—ã—Ç –ª–∏ —É–∂–µ
        existing = self.find_tab_by_filename(filename)
        if existing is not None:
            self.active_index = existing
            return self.tabs[existing]
        
        # –ï—Å–ª–∏ —Ç–µ–∫—É—â–∞—è –≤–∫–ª–∞–¥–∫–∞ –ø—É—Å—Ç–∞—è - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë
        if self.active_tab and not self.active_tab.buffer.filename and not self.active_tab.buffer.modified:
            if self.active_tab.load_file(filename):
                return self.active_tab
            return None
        
        # –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é
        tab = self.new_tab()
        if tab.load_file(filename):
            return tab
        else:
            # –û—Ç–∫–∞—Ç–∏—Ç—å
            self.tabs.pop()
            self.active_index = max(0, len(self.tabs) - 1)
            return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –î–ò–ê–õ–û–ì–û–í–´–ï –û–ö–ù–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Dialog:
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –¥–∏–∞–ª–æ–≥–æ–≤—ã—Ö –æ–∫–æ–Ω"""
    
    @staticmethod
    def draw_box(stdscr, y: int, x: int, height: int, width: int, 
                 title: str = "", color_pair: int = 0):
        """–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Ä–∞–º–∫—É"""
        # –£–≥–ª—ã –∏ –ª–∏–Ω–∏–∏
        stdscr.attron(color_pair)
        
        # –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
        stdscr.addstr(y, x, "‚ïî" + "‚ïê" * (width - 2) + "‚ïó")
        
        # –ë–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
        for i in range(1, height - 1):
            stdscr.addstr(y + i, x, "‚ïë")
            stdscr.addstr(y + i, x + width - 1, "‚ïë")
        
        # –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
        stdscr.addstr(y + height - 1, x, "‚ïö" + "‚ïê" * (width - 2) + "‚ïù")
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        if title:
            title_text = f" {title} "
            title_x = x + (width - len(title_text)) // 2
            stdscr.addstr(y, title_x, title_text)
        
        stdscr.attroff(color_pair)
    
    @staticmethod
    def center_pos(screen_height: int, screen_width: int, 
                   dialog_height: int, dialog_width: int) -> Tuple[int, int]:
        """–í—ã—á–∏—Å–ª–∏—Ç—å —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é"""
        y = (screen_height - dialog_height) // 2
        x = (screen_width - dialog_width) // 2
        return max(0, y), max(0, x)


class InputDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞"""
    
    def __init__(self, stdscr, title: str, prompt: str, 
                 default: str = "", password: bool = False):
        self.stdscr = stdscr
        self.title = title
        self.prompt = prompt
        self.value = default
        self.cursor_pos = len(default)
        self.password = password
        self.cancelled = False
    
    def show(self) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = 7
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(1)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.CYAN, -1))
            
            # –ü—Ä–æ–º–ø—Ç
            self.stdscr.addstr(y + 2, x + 2, self.prompt[:dialog_width - 4])
            
            # –ü–æ–ª–µ –≤–≤–æ–¥–∞
            input_width = dialog_width - 6
            display_value = "*" * len(self.value) if self.password else self.value
            
            # –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –¥–ª–∏–Ω–Ω—ã–π
            if len(display_value) > input_width:
                start = max(0, self.cursor_pos - input_width + 5)
                display_value = display_value[start:start + input_width]
                cursor_screen_pos = self.cursor_pos - start
            else:
                cursor_screen_pos = self.cursor_pos
            
            self.stdscr.addstr(y + 4, x + 3, "‚îÇ" + " " * input_width + "‚îÇ",
                              Colors.get_pair(Colors.WHITE, -1))
            self.stdscr.addstr(y + 4, x + 4, display_value)
            
            # –ö–Ω–æ–ø–∫–∏
            self.stdscr.addstr(y + 5, x + 2, "[Enter] OK  [Esc] –û—Ç–º–µ–Ω–∞",
                              Colors.get_pair(Colors.CYAN, -1))
            
            # –ö—É—Ä—Å–æ—Ä
            self.stdscr.move(y + 4, x + 4 + min(cursor_screen_pos, input_width - 1))
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                self.cancelled = True
                curses.curs_set(0)
                return None
            elif key in (10, 13, curses.KEY_ENTER):  # Enter
                curses.curs_set(0)
                return self.value
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if self.cursor_pos > 0:
                    self.value = self.value[:self.cursor_pos-1] + self.value[self.cursor_pos:]
                    self.cursor_pos -= 1
            elif key == curses.KEY_DC:  # Delete
                if self.cursor_pos < len(self.value):
                    self.value = self.value[:self.cursor_pos] + self.value[self.cursor_pos+1:]
            elif key == curses.KEY_LEFT:
                self.cursor_pos = max(0, self.cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                self.cursor_pos = min(len(self.value), self.cursor_pos + 1)
            elif key == curses.KEY_HOME:
                self.cursor_pos = 0
            elif key == curses.KEY_END:
                self.cursor_pos = len(self.value)
            elif 32 <= key <= 126:  # Printable
                self.value = self.value[:self.cursor_pos] + chr(key) + self.value[self.cursor_pos:]
                self.cursor_pos += 1


class ConfirmDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"""
    
    def __init__(self, stdscr, title: str, message: str, 
                 buttons: List[str] = None):
        self.stdscr = stdscr
        self.title = title
        self.message = message
        self.buttons = buttons or ["–î–∞", "–ù–µ—Ç"]
        self.selected = 0
    
    def show(self) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å –∏–Ω–¥–µ–∫—Å –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–Ω–æ–ø–∫–∏"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(50, width - 4)
        dialog_height = 8
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(0)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.YELLOW, -1))
            
            # –°–æ–æ–±—â–µ–Ω–∏–µ
            msg_lines = []
            words = self.message.split()
            current_line = ""
            for word in words:
                if len(current_line) + len(word) + 1 <= dialog_width - 4:
                    current_line += (" " if current_line else "") + word
                else:
                    msg_lines.append(current_line)
                    current_line = word
            if current_line:
                msg_lines.append(current_line)
            
            for i, line in enumerate(msg_lines[:3]):
                self.stdscr.addstr(y + 2 + i, x + 2, line[:dialog_width - 4])
            
            # –ö–Ω–æ–ø–∫–∏
            btn_y = y + dialog_height - 2
            total_btn_width = sum(len(b) + 4 for b in self.buttons) + len(self.buttons) - 1
            btn_x = x + (dialog_width - total_btn_width) // 2
            
            for i, btn in enumerate(self.buttons):
                if i == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                
                self.stdscr.addstr(btn_y, btn_x, f"[ {btn} ]", attr)
                btn_x += len(btn) + 5
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                return len(self.buttons) - 1  # –ü–æ—Å–ª–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ (–æ–±—ã—á–Ω–æ –û—Ç–º–µ–Ω–∞)
            elif key in (10, 13, curses.KEY_ENTER):
                return self.selected
            elif key in (curses.KEY_LEFT, ord('h')):
                self.selected = (self.selected - 1) % len(self.buttons)
            elif key in (curses.KEY_RIGHT, ord('l')):
                self.selected = (self.selected + 1) % len(self.buttons)
            elif key == ord('y') or key == ord('Y'):
                if "–î–∞" in self.buttons:
                    return self.buttons.index("–î–∞")
            elif key == ord('n') or key == ord('N'):
                if "–ù–µ—Ç" in self.buttons:
                    return self.buttons.index("–ù–µ—Ç")


class MessageDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ —Å–æ–æ–±—â–µ–Ω–∏—è"""
    
    def __init__(self, stdscr, title: str, message: str, 
                 msg_type: str = "info"):
        self.stdscr = stdscr
        self.title = title
        self.message = message
        self.msg_type = msg_type  # info, success, warning, error
    
    def show(self, timeout: float = 0):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(50, width - 4)
        dialog_height = 6
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        # –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
        colors = {
            "info": Colors.CYAN,
            "success": Colors.GREEN,
            "warning": Colors.YELLOW,
            "error": Colors.RED
        }
        icons = {
            "info": "‚ÑπÔ∏è",
            "success": "‚úÖ",
            "warning": "‚ö†Ô∏è",
            "error": "‚ùå"
        }
        
        color = colors.get(self.msg_type, Colors.WHITE)
        icon = icons.get(self.msg_type, "")
        
        # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
        for i in range(dialog_height):
            self.stdscr.addstr(y + i, x, " " * dialog_width)
        
        # –†–∞–º–∫–∞
        Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                       f"{icon} {self.title}", Colors.get_pair(color, -1))
        
        # –°–æ–æ–±—â–µ–Ω–∏–µ
        msg = self.message[:dialog_width - 4]
        self.stdscr.addstr(y + 2, x + 2, msg)
        
        # –ü–æ–¥—Å–∫–∞–∑–∫–∞
        self.stdscr.addstr(y + 4, x + 2, "[Enter/Esc] –ó–∞–∫—Ä—ã—Ç—å",
                          Colors.get_pair(Colors.CYAN, -1))
        
        self.stdscr.refresh()
        
        if timeout > 0:
            curses.napms(int(timeout * 1000))
        else:
            while True:
                key = self.stdscr.getch()
                if key in (27, 10, 13, curses.KEY_ENTER, ord(' ')):
                    break


class ListDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞"""
    
    def __init__(self, stdscr, title: str, items: List[str], 
                 icons: List[str] = None):
        self.stdscr = stdscr
        self.title = title
        self.items = items
        self.icons = icons or [""] * len(items)
        self.selected = 0
        self.scroll = 0
    
    def show(self) -> Optional[int]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å –∏–Ω–¥–µ–∫—Å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = min(len(self.items) + 4, height - 4)
        visible_items = dialog_height - 4
        
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(0)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.MAGENTA, -1))
            
            # –≠–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞
            for i in range(visible_items):
                item_idx = self.scroll + i
                if item_idx >= len(self.items):
                    break
                
                icon = self.icons[item_idx] if item_idx < len(self.icons) else ""
                text = self.items[item_idx]
                
                if item_idx == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                    prefix = "‚ñ∂ "
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                    prefix = "  "
                
                display = f"{prefix}{icon} {text}"[:dialog_width - 4]
                self.stdscr.addstr(y + 2 + i, x + 2, display.ljust(dialog_width - 4), attr)
            
            # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
            if len(self.items) > visible_items:
                scroll_info = f" {self.selected + 1}/{len(self.items)} "
                self.stdscr.addstr(y + dialog_height - 1, 
                                  x + dialog_width - len(scroll_info) - 2,
                                  scroll_info, Colors.get_pair(Colors.CYAN, -1))
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                return self.selected
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected > 0:
                    self.selected -= 1
                    if self.selected < self.scroll:
                        self.scroll = self.selected
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected < len(self.items) - 1:
                    self.selected += 1
                    if self.selected >= self.scroll + visible_items:
                        self.scroll = self.selected - visible_items + 1
            elif key == curses.KEY_HOME:
                self.selected = 0
                self.scroll = 0
            elif key == curses.KEY_END:
                self.selected = len(self.items) - 1
                self.scroll = max(0, len(self.items) - visible_items)
            elif key == curses.KEY_PPAGE:  # Page Up
                self.selected = max(0, self.selected - visible_items)
                self.scroll = max(0, self.scroll - visible_items)
            elif key == curses.KEY_NPAGE:  # Page Down
                self.selected = min(len(self.items) - 1, self.selected + visible_items)
                self.scroll = min(max(0, len(self.items) - visible_items),
                                 self.scroll + visible_items)


class SearchDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –ø–æ–∏—Å–∫–∞"""
    
    def __init__(self, stdscr, replace_mode: bool = False):
        self.stdscr = stdscr
        self.replace_mode = replace_mode
        self.search_text = ""
        self.replace_text = ""
        self.case_sensitive = False
        self.whole_word = False
        self.use_regex = False
        self.active_field = 0  # 0 = search, 1 = replace
        self.cursor_pos = 0
    
    def show(self) -> Optional[Dict]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –ø–æ–∏—Å–∫–∞"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = 10 if self.replace_mode else 8
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(1)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            title = "üîç –ü–æ–∏—Å–∫ –∏ –∑–∞–º–µ–Ω–∞" if self.replace_mode else "üîç –ü–æ–∏—Å–∫"
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           title, Colors.get_pair(Colors.CYAN, -1))
            
            # –ü–æ–ª–µ –ø–æ–∏—Å–∫–∞
            label_color = Colors.get_pair(Colors.WHITE, -1)
            active_color = Colors.get_pair(Colors.CYAN, -1)
            
            self.stdscr.addstr(y + 2, x + 2, "–ù–∞–π—Ç–∏:", label_color)
            search_attr = active_color if self.active_field == 0 else label_color
            self.stdscr.addstr(y + 2, x + 10, f"[{self.search_text.ljust(dialog_width - 14)}]", 
                              search_attr)
            
            if self.replace_mode:
                self.stdscr.addstr(y + 3, x + 2, "–ó–∞–º–µ–Ω–∏—Ç—å:", label_color)
                replace_attr = active_color if self.active_field == 1 else label_color
                self.stdscr.addstr(y + 3, x + 12, 
                                  f"[{self.replace_text.ljust(dialog_width - 16)}]",
                                  replace_attr)
            
            # –û–ø—Ü–∏–∏
            opt_y = y + (5 if self.replace_mode else 4)
            
            cs_mark = "‚úì" if self.case_sensitive else " "
            ww_mark = "‚úì" if self.whole_word else " "
            rx_mark = "‚úì" if self.use_regex else " "
            
            self.stdscr.addstr(opt_y, x + 2, f"[{cs_mark}] –†–µ–≥–∏—Å—Ç—Ä  [{ww_mark}] –°–ª–æ–≤–æ  [{rx_mark}] Regex",
                              Colors.get_pair(Colors.YELLOW, -1))
            
            # –ö–Ω–æ–ø–∫–∏
            btn_y = opt_y + 2
            self.stdscr.addstr(btn_y, x + 2, "[Enter] –ù–∞–π—Ç–∏  [Esc] –û—Ç–º–µ–Ω–∞",
                              Colors.get_pair(Colors.CYAN, -1))
            if self.replace_mode:
                self.stdscr.addstr(btn_y, x + 35, "[Ctrl+R] –ó–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ")
            
            # –ö—É—Ä—Å–æ—Ä
            if self.active_field == 0:
                cursor_x = x + 11 + min(self.cursor_pos, len(self.search_text))
                self.stdscr.move(y + 2, cursor_x)
            else:
                cursor_x = x + 13 + min(self.cursor_pos, len(self.replace_text))
                self.stdscr.move(y + 3, cursor_x)
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                curses.curs_set(0)
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                curses.curs_set(0)
                return {
                    "search": self.search_text,
                    "replace": self.replace_text if self.replace_mode else None,
                    "case_sensitive": self.case_sensitive,
                    "whole_word": self.whole_word,
                    "regex": self.use_regex
                }
            elif key == 9:  # Tab
                if self.replace_mode:
                    self.active_field = 1 - self.active_field
                    self.cursor_pos = len(self.replace_text if self.active_field == 1 
                                         else self.search_text)
            elif key == ord('c') - 96:  # Ctrl+C - toggle case
                self.case_sensitive = not self.case_sensitive
            elif key == ord('w') - 96:  # Ctrl+W - toggle word
                self.whole_word = not self.whole_word
            elif key == ord('x') - 96:  # Ctrl+X - toggle regex
                self.use_regex = not self.use_regex
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if self.active_field == 0 and self.cursor_pos > 0:
                    self.search_text = (self.search_text[:self.cursor_pos-1] + 
                                       self.search_text[self.cursor_pos:])
                    self.cursor_pos -= 1
                elif self.active_field == 1 and self.cursor_pos > 0:
                    self.replace_text = (self.replace_text[:self.cursor_pos-1] + 
                                        self.replace_text[self.cursor_pos:])
                    self.cursor_pos -= 1
            elif key == curses.KEY_LEFT:
                self.cursor_pos = max(0, self.cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                max_pos = len(self.search_text if self.active_field == 0 else self.replace_text)
                self.cursor_pos = min(max_pos, self.cursor_pos + 1)
            elif 32 <= key <= 126:
                char = chr(key)
                if self.active_field == 0:
                    self.search_text = (self.search_text[:self.cursor_pos] + char + 
                                       self.search_text[self.cursor_pos:])
                else:
                    self.replace_text = (self.replace_text[:self.cursor_pos] + char + 
                                        self.replace_text[self.cursor_pos:])
                self.cursor_pos += 1


print("‚úÖ –ß–∞—Å—Ç—å 3/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: SyntaxHighlighter, Tab, TabManager, Dialogs")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ë–ê–ó–û–í–´–ô –ö–õ–ê–°–° –ü–õ–ê–ì–ò–ù–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Plugin:
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –ø–ª–∞–≥–∏–Ω–æ–≤"""
    
    name: str = "Plugin"
    description: str = ""
    version: str = "1.0.0"
    author: str = "DIPO Team"
    enabled: bool = True
    
    def __init__(self, editor: 'Editor'):
        self.editor = editor
    
    def on_load(self):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–ª–∞–≥–∏–Ω–∞"""
        pass
    
    def on_unload(self):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ –ø–ª–∞–≥–∏–Ω–∞"""
        pass
    
    def on_key(self, key: int) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à–∏. –í–µ—Ä–Ω—É—Ç—å True –µ—Å–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ"""
        return False
    
    def on_save(self, tab: Tab):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞"""
        pass
    
    def on_open(self, tab: Tab):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞"""
        pass
    
    def on_close(self, tab: Tab):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞"""
        pass
    
    def on_edit(self, tab: Tab):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞"""
        pass


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 1: RUNNER - –ó–ê–ü–£–°–ö –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class RunnerPlugin(Plugin):
    """–ó–∞–ø—É—Å–∫ –∫–æ–¥–∞ –∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞"""
    
    name = "Runner"
    description = "–ó–∞–ø—É—Å–∫ –∫–æ–¥–∞ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.last_output = ""
        self.last_error = ""
        self.last_exit_code = 0
        self.running = False
        self.process = None
    
    def run_current_file(self) -> Tuple[bool, str]:
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ñ–∞–π–ª"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return False, "–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —Ñ–∞–π–ª–∞"
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
        if tab.buffer.modified:
            success, msg = tab.save_file()
            if not success:
                return False, f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: {msg}"
        
        if not tab.buffer.filename:
            return False, "–§–∞–π–ª –Ω–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω"
        
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –∑–∞–ø—É—Å–∫–∞
        lang = tab.buffer.language
        if not lang or lang not in LANGUAGES:
            return False, f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —è–∑—ã–∫: {lang}"
        
        lang_config = LANGUAGES[lang]
        run_cmd = lang_config.get("run")
        
        if not run_cmd:
            return False, f"–ó–∞–ø—É—Å–∫ –¥–ª—è {lang} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
        
        # –ü–æ–¥—Å—Ç–∞–≤–∏—Ç—å –∏–º—è —Ñ–∞–π–ª–∞
        filename = tab.buffer.filename
        basename = os.path.basename(filename)
        name_only = os.path.splitext(basename)[0]
        dirname = os.path.dirname(filename)
        
        cmd = run_cmd.format(
            file=filename,
            name=name_only,
            basename=basename,
            dir=dirname
        )
        
        return self.execute(cmd, dirname)
    
    def execute(self, cmd: str, cwd: str = None) -> Tuple[bool, str]:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"""
        self.running = True
        start_time = time.time()
        
        try:
            # –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞
            self.process = subprocess.Popen(
                cmd,
                shell=True,
                cwd=cwd or os.getcwd(),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True
            )
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            try:
                stdout, stderr = self.process.communicate(timeout=300)  # 5 –º–∏–Ω—É—Ç
            except subprocess.TimeoutExpired:
                self.process.kill()
                stdout, stderr = self.process.communicate()
                return False, "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (5 –º–∏–Ω—É—Ç)"
            
            self.last_output = stdout
            self.last_error = stderr
            self.last_exit_code = self.process.returncode
            
            elapsed = time.time() - start_time
            
            # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            result_lines = []
            result_lines.append(f"{'‚ïê' * 50}")
            result_lines.append(f"üöÄ –ö–æ–º–∞–Ω–¥–∞: {cmd}")
            result_lines.append(f"‚è±Ô∏è  –í—Ä–µ–º—è: {elapsed:.2f}—Å")
            result_lines.append(f"{'‚ïê' * 50}")
            
            if stdout:
                result_lines.append("\nüì§ –í–´–í–û–î:")
                result_lines.append(stdout)
            
            if stderr:
                result_lines.append("\n‚ö†Ô∏è –û–®–ò–ë–ö–ò:")
                result_lines.append(stderr)
            
            result_lines.append(f"\n{'‚ïê' * 50}")
            
            if self.last_exit_code == 0:
                result_lines.append(f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ (–∫–æ–¥: 0)")
            else:
                result_lines.append(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (–∫–æ–¥: {self.last_exit_code})")
            
            return self.last_exit_code == 0, '\n'.join(result_lines)
            
        except FileNotFoundError:
            return False, f"‚ùå –ö–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {cmd.split()[0]}"
        except Exception as e:
            return False, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}"
        finally:
            self.running = False
            self.process = None
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ"""
        if self.process and self.running:
            self.process.terminate()
            try:
                self.process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self.process.kill()
            self.running = False
    
    def show_output_dialog(self, output: str, success: bool):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è"""
        height, width = self.editor.stdscr.getmaxyx()
        
        dialog_height = min(height - 4, 30)
        dialog_width = min(width - 4, 80)
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        lines = output.split('\n')
        scroll = 0
        max_scroll = max(0, len(lines) - dialog_height + 4)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å
            for i in range(dialog_height):
                try:
                    self.editor.stdscr.addstr(y + i, x, " " * dialog_width)
                except:
                    pass
            
            # –†–∞–º–∫–∞
            title = "‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç" if success else "‚ùå –û—à–∏–±–∫–∞"
            color = Colors.GREEN if success else Colors.RED
            Dialog.draw_box(self.editor.stdscr, y, x, dialog_height, dialog_width,
                           title, Colors.get_pair(color, -1))
            
            # –í—ã–≤–æ–¥
            visible_lines = dialog_height - 4
            for i, line in enumerate(lines[scroll:scroll + visible_lines]):
                try:
                    display_line = line[:dialog_width - 4]
                    self.editor.stdscr.addstr(y + 2 + i, x + 2, display_line)
                except:
                    pass
            
            # –°–∫—Ä–æ–ª–ª–±–∞—Ä
            if max_scroll > 0:
                scrollbar_height = max(1, (visible_lines * visible_lines) // len(lines))
                scrollbar_pos = (scroll * (visible_lines - scrollbar_height)) // max_scroll
                for i in range(visible_lines):
                    char = "‚ñà" if scrollbar_pos <= i < scrollbar_pos + scrollbar_height else "‚ñë"
                    try:
                        self.editor.stdscr.addstr(y + 2 + i, x + dialog_width - 2, char,
                                                 Colors.get_pair(Colors.CYAN, -1))
                    except:
                        pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∏
            try:
                self.editor.stdscr.addstr(y + dialog_height - 1, x + 2,
                                         " [‚Üë‚Üì] –°–∫—Ä–æ–ª–ª [Esc/Enter] –ó–∞–∫—Ä—ã—Ç—å ",
                                         Colors.get_pair(Colors.CYAN, -1))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key in (27, 10, 13, ord('q')):
                break
            elif key == curses.KEY_UP:
                scroll = max(0, scroll - 1)
            elif key == curses.KEY_DOWN:
                scroll = min(max_scroll, scroll + 1)
            elif key == curses.KEY_PPAGE:
                scroll = max(0, scroll - visible_lines)
            elif key == curses.KEY_NPAGE:
                scroll = min(max_scroll, scroll + visible_lines)
            elif key == curses.KEY_HOME:
                scroll = 0
            elif key == curses.KEY_END:
                scroll = max_scroll


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 2: FILE EXPLORER - –ü–†–û–í–û–î–ù–ò–ö –§–ê–ô–õ–û–í
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FileExplorerPlugin(Plugin):
    """–ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤"""
    
    name = "FileExplorer"
    description = "–ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.current_path = os.getcwd()
        self.selected = 0
        self.scroll = 0
        self.show_hidden = False
        self.items: List[Dict] = []
        self.filter_text = ""
        self.is_open = False
    
    def refresh(self):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤"""
        self.items = []
        
        try:
            entries = os.listdir(self.current_path)
        except PermissionError:
            entries = []
        
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–∫—Ä—ã—Ç—ã—Ö
        if not self.show_hidden:
            entries = [e for e in entries if not e.startswith('.')]
        
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–µ–∫—Å—Ç—É
        if self.filter_text:
            entries = [e for e in entries if self.filter_text.lower() in e.lower()]
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –ø–∞–ø–∫–∏ –ø–µ—Ä–≤—ã–º–∏, –ø–æ—Ç–æ–º —Ñ–∞–π–ª—ã
        dirs = []
        files = []
        
        for entry in entries:
            full_path = os.path.join(self.current_path, entry)
            is_dir = os.path.isdir(full_path)
            
            try:
                stat = os.stat(full_path)
                size = stat.st_size
                mtime = stat.st_mtime
            except:
                size = 0
                mtime = 0
            
            item = {
                "name": entry,
                "path": full_path,
                "is_dir": is_dir,
                "size": size,
                "mtime": mtime,
                "icon": FOLDER_ICON if is_dir else Utils.get_file_icon(entry)
            }
            
            if is_dir:
                dirs.append(item)
            else:
                files.append(item)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∏–º–µ–Ω–∏
        dirs.sort(key=lambda x: x["name"].lower())
        files.sort(key=lambda x: x["name"].lower())
        
        # –î–æ–±–∞–≤–∏—Ç—å ".." –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤–≤–µ—Ä—Ö
        if self.current_path != "/":
            self.items.append({
                "name": "..",
                "path": os.path.dirname(self.current_path),
                "is_dir": True,
                "size": 0,
                "mtime": 0,
                "icon": "üìÇ"
            })
        
        self.items.extend(dirs)
        self.items.extend(files)
        
        # –°–±—Ä–æ—Å–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if self.selected >= len(self.items):
            self.selected = max(0, len(self.items) - 1)
    
    def show(self) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≤–æ–¥–Ω–∏–∫ –∏ –≤–µ—Ä–Ω—É—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–∞–π–ª"""
        self.is_open = True
        self.refresh()
        
        height, width = self.editor.stdscr.getmaxyx()
        
        # –†–∞–∑–º–µ—Ä—ã –ø–∞–Ω–µ–ª–∏
        panel_width = min(50, width // 2)
        panel_height = height - 2
        panel_x = 0
        panel_y = 1
        
        curses.curs_set(0)
        
        result = None
        
        while self.is_open:
            visible_items = panel_height - 5
            
            # –û—á–∏—Å—Ç–∏—Ç—å –ø–∞–Ω–µ–ª—å
            for i in range(panel_height):
                try:
                    self.editor.stdscr.addstr(panel_y + i, panel_x, " " * panel_width)
                except:
                    pass
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            header_color = Colors.get_pair(Colors.WHITE, Colors.BLUE)
            path_display = Utils.truncate(self.current_path, panel_width - 4)
            try:
                self.editor.stdscr.addstr(panel_y, panel_x, 
                                         f" üìÇ {path_display}".ljust(panel_width),
                                         header_color)
            except:
                pass
            
            # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
            try:
                self.editor.stdscr.addstr(panel_y + 1, panel_x, "‚îÄ" * panel_width,
                                         Colors.get_pair(Colors.CYAN, -1))
            except:
                pass
            
            # –§–∞–π–ª—ã
            for i in range(visible_items):
                item_idx = self.scroll + i
                if item_idx >= len(self.items):
                    break
                
                item = self.items[item_idx]
                
                # –§–æ—Ä–º–∞—Ç —Å—Ç—Ä–æ–∫–∏
                if item["is_dir"]:
                    name = item["name"] + "/"
                    size_str = "<DIR>"
                else:
                    name = item["name"]
                    size_str = Utils.format_size(item["size"])
                
                # –¶–≤–µ—Ç
                if item_idx == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                elif item["is_dir"]:
                    attr = Colors.get_pair(Colors.CYAN, -1)
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                
                # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                icon = item["icon"]
                display_name = Utils.truncate(name, panel_width - 15)
                line = f" {icon} {display_name}".ljust(panel_width - 8) + f"{size_str:>7} "
                
                try:
                    self.editor.stdscr.addstr(panel_y + 2 + i, panel_x, 
                                             line[:panel_width], attr)
                except:
                    pass
            
            # –°—Ç–∞—Ç—É—Å –±–∞—Ä –≤–Ω–∏–∑—É –ø–∞–Ω–µ–ª–∏
            status_y = panel_y + panel_height - 2
            total = len(self.items)
            hidden_status = "üëÅ" if self.show_hidden else "üôà"
            status = f" {self.selected + 1}/{total} {hidden_status} "
            
            try:
                self.editor.stdscr.addstr(status_y, panel_x, "‚îÄ" * panel_width,
                                         Colors.get_pair(Colors.CYAN, -1))
                self.editor.stdscr.addstr(status_y + 1, panel_x,
                                         " [Enter]–û—Ç–∫—Ä—ã—Ç—å [n]–ù–æ–≤—ã–π [d]–£–¥–∞–ª–∏—Ç—å [r]–ü–µ—Ä–µ–∏–º. [h]–°–∫—Ä—ã—Ç—ã–µ [q]–í—ã—Ö–æ–¥ ".ljust(panel_width),
                                         Colors.get_pair(Colors.YELLOW, -1))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞
            key = self.editor.stdscr.getch()
            
            if key in (27, ord('q')):  # Esc –∏–ª–∏ q - –≤—ã—Ö–æ–¥
                self.is_open = False
                result = None
            
            elif key in (10, 13, curses.KEY_ENTER):  # Enter - –æ—Ç–∫—Ä—ã—Ç—å
                if self.items:
                    item = self.items[self.selected]
                    if item["is_dir"]:
                        self.current_path = item["path"]
                        self.selected = 0
                        self.scroll = 0
                        self.refresh()
                    else:
                        result = item["path"]
                        self.is_open = False
            
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected > 0:
                    self.selected -= 1
                    if self.selected < self.scroll:
                        self.scroll = self.selected
            
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected < len(self.items) - 1:
                    self.selected += 1
                    if self.selected >= self.scroll + visible_items:
                        self.scroll = self.selected - visible_items + 1
            
            elif key == curses.KEY_PPAGE:  # Page Up
                self.selected = max(0, self.selected - visible_items)
                self.scroll = max(0, self.scroll - visible_items)
            
            elif key == curses.KEY_NPAGE:  # Page Down
                self.selected = min(len(self.items) - 1, self.selected + visible_items)
                max_scroll = max(0, len(self.items) - visible_items)
                self.scroll = min(max_scroll, self.scroll + visible_items)
            
            elif key == ord('h'):  # –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —Ñ–∞–π–ª—ã
                self.show_hidden = not self.show_hidden
                self.refresh()
            
            elif key == ord('n'):  # –ù–æ–≤—ã–π —Ñ–∞–π–ª/–ø–∞–ø–∫–∞
                self._create_new()
            
            elif key == ord('d'):  # –£–¥–∞–ª–∏—Ç—å
                self._delete_selected()
            
            elif key == ord('r'):  # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å
                self._rename_selected()
            
            elif key == ord('/'):  # –ü–æ–∏—Å–∫
                self._search()
            
            elif key == curses.KEY_BACKSPACE or key == 127:
                # –í–≤–µ—Ä—Ö –ø–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
                if self.current_path != "/":
                    self.current_path = os.path.dirname(self.current_path)
                    self.selected = 0
                    self.scroll = 0
                    self.refresh()
            
            elif key == ord('~'):  # –î–æ–º–∞—à–Ω—è—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
                self.current_path = os.path.expanduser("~")
                self.selected = 0
                self.scroll = 0
                self.refresh()
        
        return result
    
    def _create_new(self):
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª –∏–ª–∏ –ø–∞–ø–∫—É"""
        dialog = InputDialog(self.editor.stdscr, "üìù –ù–æ–≤—ã–π", 
                            "–ò–º—è (–¥–æ–±–∞–≤—å—Ç–µ / –¥–ª—è –ø–∞–ø–∫–∏):")
        name = dialog.show()
        
        if name:
            full_path = os.path.join(self.current_path, name)
            try:
                if name.endswith('/'):
                    os.makedirs(full_path.rstrip('/'), exist_ok=True)
                else:
                    # –°–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª
                    dirname = os.path.dirname(full_path)
                    if dirname and not os.path.exists(dirname):
                        os.makedirs(dirname)
                    with open(full_path, 'w') as f:
                        pass
                self.refresh()
            except Exception as e:
                MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞", 
                            str(e), "error").show()
    
    def _delete_selected(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç"""
        if not self.items or self.items[self.selected]["name"] == "..":
            return
        
        item = self.items[self.selected]
        confirm = ConfirmDialog(
            self.editor.stdscr,
            "‚ö†Ô∏è –£–¥–∞–ª–µ–Ω–∏–µ",
            f"–£–¥–∞–ª–∏—Ç—å '{item['name']}'?",
            ["–î–∞", "–ù–µ—Ç"]
        )
        
        if confirm.show() == 0:
            try:
                if item["is_dir"]:
                    shutil.rmtree(item["path"])
                else:
                    os.remove(item["path"])
                self.refresh()
            except Exception as e:
                MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞", 
                            str(e), "error").show()
    
    def _rename_selected(self):
        """–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç"""
        if not self.items or self.items[self.selected]["name"] == "..":
            return
        
        item = self.items[self.selected]
        dialog = InputDialog(self.editor.stdscr, "‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å",
                            "–ù–æ–≤–æ–µ –∏–º—è:", item["name"])
        new_name = dialog.show()
        
        if new_name and new_name != item["name"]:
            try:
                new_path = os.path.join(self.current_path, new_name)
                os.rename(item["path"], new_path)
                self.refresh()
            except Exception as e:
                MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞",
                            str(e), "error").show()
    
    def _search(self):
        """–ü–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏"""
        dialog = InputDialog(self.editor.stdscr, "üîç –ü–æ–∏—Å–∫", "–§–∏–ª—å—Ç—Ä:")
        self.filter_text = dialog.show() or ""
        self.selected = 0
        self.scroll = 0
        self.refresh()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 3: GIT INTEGRATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class GitPlugin(Plugin):
    """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Git"""
    
    name = "Git"
    description = "Git –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.repo_path = None
    
    def is_git_available(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å git"""
        try:
            subprocess.run(['git', '--version'], capture_output=True, check=True)
            return True
        except:
            return False
    
    def find_repo(self, path: str) -> Optional[str]:
        """–ù–∞–π—Ç–∏ –∫–æ—Ä–µ–Ω—å git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è"""
        current = os.path.abspath(path)
        while current != '/':
            if os.path.isdir(os.path.join(current, '.git')):
                return current
            current = os.path.dirname(current)
        return None
    
    def run_git(self, *args, cwd: str = None) -> Tuple[bool, str, str]:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å git –∫–æ–º–∞–Ω–¥—É"""
        try:
            result = subprocess.run(
                ['git'] + list(args),
                cwd=cwd or self.repo_path or os.getcwd(),
                capture_output=True,
                text=True
            )
            return result.returncode == 0, result.stdout, result.stderr
        except Exception as e:
            return False, "", str(e)
    
    def get_status(self) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è"""
        status = {
            "branch": "",
            "changed": [],
            "staged": [],
            "untracked": [],
            "ahead": 0,
            "behind": 0
        }
        
        # –¢–µ–∫—É—â–∞—è –≤–µ—Ç–∫–∞
        success, stdout, _ = self.run_git('branch', '--show-current')
        if success:
            status["branch"] = stdout.strip()
        
        # –°—Ç–∞—Ç—É—Å —Ñ–∞–π–ª–æ–≤
        success, stdout, _ = self.run_git('status', '--porcelain=v1')
        if success:
            for line in stdout.strip().split('\n'):
                if not line:
                    continue
                
                status_code = line[:2]
                filename = line[3:]
                
                if status_code[0] in 'MADRCU':
                    status["staged"].append({"status": status_code[0], "file": filename})
                if status_code[1] in 'MADRCU':
                    status["changed"].append({"status": status_code[1], "file": filename})
                if status_code == '??':
                    status["untracked"].append(filename)
        
        # Ahead/Behind
        success, stdout, _ = self.run_git('rev-list', '--count', '--left-right', '@{u}...HEAD')
        if success:
            parts = stdout.strip().split('\t')
            if len(parts) == 2:
                status["behind"] = int(parts[0])
                status["ahead"] = int(parts[1])
        
        return status
    
    def get_diff(self, filename: str = None) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å diff"""
        args = ['diff', '--color=never']
        if filename:
            args.append(filename)
        
        success, stdout, _ = self.run_git(*args)
        return stdout if success else ""
    
    def stage_file(self, filename: str) -> bool:
        """–î–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª –≤ –∏–Ω–¥–µ–∫—Å"""
        success, _, _ = self.run_git('add', filename)
        return success
    
    def unstage_file(self, filename: str) -> bool:
        """–£–±—Ä–∞—Ç—å —Ñ–∞–π–ª –∏–∑ –∏–Ω–¥–µ–∫—Å–∞"""
        success, _, _ = self.run_git('reset', 'HEAD', filename)
        return success
    
    def commit(self, message: str) -> Tuple[bool, str]:
        """–°–æ–∑–¥–∞—Ç—å –∫–æ–º–º–∏—Ç"""
        success, stdout, stderr = self.run_git('commit', '-m', message)
        return success, stdout if success else stderr
    
    def push(self) -> Tuple[bool, str]:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
        success, stdout, stderr = self.run_git('push')
        return success, stdout if success else stderr
    
    def pull(self) -> Tuple[bool, str]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
        success, stdout, stderr = self.run_git('pull')
        return success, stdout if success else stderr
    
    def get_branches(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤–µ—Ç–æ–∫"""
        success, stdout, _ = self.run_git('branch', '-a')
        if success:
            branches = []
            for line in stdout.strip().split('\n'):
                branch = line.strip().lstrip('* ')
                if branch:
                    branches.append(branch)
            return branches
        return []
    
    def checkout(self, branch: str) -> Tuple[bool, str]:
        """–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤–µ—Ç–∫—É"""
        success, stdout, stderr = self.run_git('checkout', branch)
        return success, stdout if success else stderr
    
    def show_menu(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é Git"""
        if not self.is_git_available():
            MessageDialog(self.editor.stdscr, "Git", 
                         "Git –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", "error").show()
            return
        
        tab = self.editor.tab_manager.active_tab
        if tab and tab.buffer.filename:
            self.repo_path = self.find_repo(os.path.dirname(tab.buffer.filename))
        else:
            self.repo_path = self.find_repo(os.getcwd())
        
        if not self.repo_path:
            MessageDialog(self.editor.stdscr, "Git",
                         "–ù–µ –Ω–∞–π–¥–µ–Ω Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π", "warning").show()
            return
        
        status = self.get_status()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –º–µ–Ω—é
        items = [
            f"üåø –í–µ—Ç–∫–∞: {status['branch']}",
            "‚îÄ" * 30,
            f"üìù –ò–∑–º–µ–Ω–µ–Ω–æ: {len(status['changed'])} —Ñ–∞–π–ª–æ–≤",
            f"‚úÖ –í –∏–Ω–¥–µ–∫—Å–µ: {len(status['staged'])} —Ñ–∞–π–ª–æ–≤",
            f"‚ùì –ù–µ–æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö: {len(status['untracked'])} —Ñ–∞–π–ª–æ–≤",
            "‚îÄ" * 30,
            "üìã Commit - —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–º–∏—Ç",
            "‚¨ÜÔ∏è Push - –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è",
            "‚¨áÔ∏è Pull - –ø–æ–ª—É—á–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è",
            "üîÄ Branches - –≤–µ—Ç–∫–∏",
            "üìä Status - –ø–æ–ª–Ω—ã–π —Å—Ç–∞—Ç—É—Å",
            "üìú Log - –∏—Å—Ç–æ—Ä–∏—è –∫–æ–º–º–∏—Ç–æ–≤",
            "üîô –í—ã—Ö–æ–¥"
        ]
        
        dialog = ListDialog(self.editor.stdscr, "üåø Git", items)
        choice = dialog.show()
        
        if choice is None or choice in [0, 1, 5, 12]:
            return
        
        if choice == 6:  # Commit
            self._do_commit()
        elif choice == 7:  # Push
            success, msg = self.push()
            MessageDialog(self.editor.stdscr, "Git Push",
                         msg, "success" if success else "error").show()
        elif choice == 8:  # Pull
            success, msg = self.pull()
            MessageDialog(self.editor.stdscr, "Git Pull",
                         msg, "success" if success else "error").show()
        elif choice == 9:  # Branches
            self._show_branches()
        elif choice == 10:  # Status
            self._show_full_status()
        elif choice == 11:  # Log
            self._show_log()
    
    def _do_commit(self):
        """–°–æ–∑–¥–∞—Ç—å –∫–æ–º–º–∏—Ç"""
        dialog = InputDialog(self.editor.stdscr, "Git Commit", 
                            "–°–æ–æ–±—â–µ–Ω–∏–µ –∫–æ–º–º–∏—Ç–∞:")
        message = dialog.show()
        
        if message:
            success, result = self.commit(message)
            MessageDialog(self.editor.stdscr, "Git Commit",
                         result[:200], "success" if success else "error").show()
    
    def _show_branches(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∏ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤–µ—Ç–∫–∏"""
        branches = self.get_branches()
        if not branches:
            return
        
        dialog = ListDialog(self.editor.stdscr, "üîÄ –í–µ—Ç–∫–∏ Git", branches)
        choice = dialog.show()
        
        if choice is not None:
            branch = branches[choice].replace('remotes/origin/', '')
            success, msg = self.checkout(branch)
            MessageDialog(self.editor.stdscr, "Git Checkout",
                         msg, "success" if success else "error").show()
    
    def _show_full_status(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–Ω—ã–π —Å—Ç–∞—Ç—É—Å"""
        success, stdout, stderr = self.run_git('status')
        output = stdout if success else stderr
        
        # –ü–æ–∫–∞–∑–∞—Ç—å –≤ –¥–∏–∞–ª–æ–≥–µ
        height, width = self.editor.stdscr.getmaxyx()
        dialog_height = min(height - 4, 25)
        dialog_width = min(width - 4, 70)
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        lines = output.split('\n')
        scroll = 0
        
        while True:
            for i in range(dialog_height):
                try:
                    self.editor.stdscr.addstr(y + i, x, " " * dialog_width)
                except:
                    pass
            
            Dialog.draw_box(self.editor.stdscr, y, x, dialog_height, dialog_width,
                           "üìä Git Status", Colors.get_pair(Colors.CYAN, -1))
            
            for i, line in enumerate(lines[scroll:scroll + dialog_height - 3]):
                try:
                    self.editor.stdscr.addstr(y + 1 + i, x + 1, line[:dialog_width - 2])
                except:
                    pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            if key in (27, 10, ord('q')):
                break
            elif key == curses.KEY_UP:
                scroll = max(0, scroll - 1)
            elif key == curses.KEY_DOWN:
                scroll = min(len(lines) - dialog_height + 3, scroll + 1)
    
    def _show_log(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥ –∫–æ–º–º–∏—Ç–æ–≤"""
        success, stdout, _ = self.run_git('log', '--oneline', '-20')
        if not success:
            return
        
        commits = stdout.strip().split('\n')
        dialog = ListDialog(self.editor.stdscr, "üìú –ò—Å—Ç–æ—Ä–∏—è –∫–æ–º–º–∏—Ç–æ–≤", commits)
        dialog.show()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 4: SNIPPETS - –°–ù–ò–ü–ü–ï–¢–´ –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SnippetsPlugin(Plugin):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–Ω–∏–ø–ø–µ—Ç–∞–º–∏ –∫–æ–¥–∞"""
    
    name = "Snippets"
    description = "–ë—ã—Å—Ç—Ä–∞—è –≤—Å—Ç–∞–≤–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –∫–æ–¥–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.custom_snippets: Dict[str, Dict[str, str]] = {}
        self.load_custom_snippets()
    
    def load_custom_snippets(self):
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–Ω–∏–ø–ø–µ—Ç—ã"""
        snippets_file = os.path.join(CONFIG_DIR, "snippets.json")
        try:
            if os.path.exists(snippets_file):
                with open(snippets_file, 'r', encoding='utf-8') as f:
                    self.custom_snippets = json.load(f)
        except:
            pass
    
    def save_custom_snippets(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–Ω–∏–ø–ø–µ—Ç—ã"""
        snippets_file = os.path.join(CONFIG_DIR, "snippets.json")
        try:
            with open(snippets_file, 'w', encoding='utf-8') as f:
                json.dump(self.custom_snippets, f, indent=2, ensure_ascii=False)
        except:
            pass
    
    def get_snippets(self, language: str) -> Dict[str, str]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Å–Ω–∏–ø–ø–µ—Ç—ã –¥–ª—è —è–∑—ã–∫–∞"""
        snippets = {}
        
        # –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ
        if language in LANGUAGES:
            snippets.update(LANGUAGES[language].get("snippets", {}))
        
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ
        if language in self.custom_snippets:
            snippets.update(self.custom_snippets[language])
        
        return snippets
    
    def expand_snippet(self, tab: Tab, trigger: str) -> bool:
        """–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–Ω–∏–ø–ø–µ—Ç –ø–æ —Ç—Ä–∏–≥–≥–µ—Ä—É"""
        language = tab.buffer.language or "python"
        snippets = self.get_snippets(language)
        
        if trigger not in snippets:
            return False
        
        template = snippets[trigger]
        
        # –£–¥–∞–ª–∏—Ç—å —Ç—Ä–∏–≥–≥–µ—Ä
        cursor = tab.cursor
        line = tab.buffer.get_line(cursor.row)
        new_line = line[:cursor.col - len(trigger)] + line[cursor.col:]
        tab.buffer.set_line(cursor.row, new_line)
        cursor.col -= len(trigger)
        
        # –û–±—Ä–∞–±–æ—Ç–∞—Ç—å —à–∞–±–ª–æ–Ω
        expanded = self._process_template(template, tab)
        
        # –í—Å—Ç–∞–≤–∏—Ç—å
        new_pos = tab.buffer.insert_text(cursor.row, cursor.col, expanded)
        cursor.move_to(new_pos[0], new_pos[1], tab.buffer)
        
        return True
    
    def _process_template(self, template: str, tab: Tab) -> str:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å —à–∞–±–ª–æ–Ω —Å–Ω–∏–ø–ø–µ—Ç–∞"""
        # –ó–∞–º–µ–Ω–∏—Ç—å ${N:default} –Ω–∞ default
        result = template
        
        # –ü—Ä–æ—Å—Ç–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤
        import re
        pattern = r'\$\{(\d+):([^}]*)\}'
        
        def replacer(match):
            return match.group(2)  # –í–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        result = re.sub(pattern, replacer, result)
        
        # –ó–∞–º–µ–Ω–∏—Ç—å $N –Ω–∞ –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É
        result = re.sub(r'\$\d+', '', result)
        
        # –ó–∞–º–µ–Ω–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        result = result.replace('${filename}', 
                               os.path.basename(tab.buffer.filename or 'untitled'))
        result = result.replace('${date}', 
                               datetime.now().strftime('%Y-%m-%d'))
        result = result.replace('${time}', 
                               datetime.now().strftime('%H:%M:%S'))
        result = result.replace('${author}', 
                               os.environ.get('USER', 'Author'))
        
        return result
    
    def show_snippets_menu(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é —Å–Ω–∏–ø–ø–µ—Ç–æ–≤"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        language = tab.buffer.language or "python"
        snippets = self.get_snippets(language)
        
        if not snippets:
            MessageDialog(self.editor.stdscr, "–°–Ω–∏–ø–ø–µ—Ç—ã",
                         f"–ù–µ—Ç —Å–Ω–∏–ø–ø–µ—Ç–æ–≤ –¥–ª—è {language}", "info").show()
            return
        
        items = []
        triggers = []
        for trigger, template in snippets.items():
            preview = template.split('\n')[0][:40]
            items.append(f"{trigger}: {preview}")
            triggers.append(trigger)
        
        dialog = ListDialog(self.editor.stdscr, 
                           f"üìù –°–Ω–∏–ø–ø–µ—Ç—ã ({language})", items)
        choice = dialog.show()
        
        if choice is not None:
            trigger = triggers[choice]
            template = snippets[trigger]
            expanded = self._process_template(template, tab)
            
            cursor = tab.cursor
            new_pos = tab.buffer.insert_text(cursor.row, cursor.col, expanded)
            cursor.move_to(new_pos[0], new_pos[1], tab.buffer)
    
    def add_custom_snippet(self, language: str, trigger: str, template: str):
        """–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Å–Ω–∏–ø–ø–µ—Ç"""
        if language not in self.custom_snippets:
            self.custom_snippets[language] = {}
        
        self.custom_snippets[language][trigger] = template
        self.save_custom_snippets()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 5: LINTER - –ü–†–û–í–ï–†–ö–ê –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class LinterPlugin(Plugin):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –Ω–∞ –æ—à–∏–±–∫–∏"""
    
    name = "Linter"
    description = "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ —Å—Ç–∏–ª—è –∫–æ–¥–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.errors: Dict[int, List[Dict]] = {}  # {tab_id: [{line, col, msg, type}]}
    
    def lint_current(self) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ñ–∞–π–ª"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return []
        
        language = tab.buffer.language
        errors = []
        
        if language == "python":
            errors = self._lint_python(tab)
        elif language in ["javascript", "typescript"]:
            errors = self._lint_javascript(tab)
        elif language == "json":
            errors = self._lint_json(tab)
        elif language in ["html", "xml"]:
            errors = self._lint_html(tab)
        else:
            # –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤
            errors = self._lint_basic(tab)
        
        self.errors[tab.id] = errors
        return errors
    
    def _lint_python(self, tab: Tab) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å Python –∫–æ–¥"""
        errors = []
        code = tab.buffer.get_text()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ Python
        try:
            compile(code, tab.buffer.filename or '<string>', 'exec')
        except SyntaxError as e:
            errors.append({
                "line": e.lineno or 1,
                "col": e.offset or 0,
                "message": str(e.msg),
                "type": "error"
            })
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        for i, line in enumerate(tab.buffer.lines, 1):
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã —Å—Ç—Ä–æ–∫–∏
            if len(line) > 120:
                errors.append({
                    "line": i,
                    "col": 120,
                    "message": f"–°—Ç—Ä–æ–∫–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è ({len(line)} > 120)",
                    "type": "warning"
                })
            
            # Trailing whitespace
            if line.rstrip() != line:
                errors.append({
                    "line": i,
                    "col": len(line.rstrip()) + 1,
                    "message": "–ü—Ä–æ–±–µ–ª—ã –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏",
                    "type": "warning"
                })
            
            # –°–º–µ—à–∞–Ω–Ω—ã–µ —Ç–∞–±—ã –∏ –ø—Ä–æ–±–µ–ª—ã
            stripped = line.lstrip()
            if stripped:
                indent = line[:len(line) - len(stripped)]
                if '\t' in indent and ' ' in indent:
                    errors.append({
                        "line": i,
                        "col": 0,
                        "message": "–°–º–µ—à–∞–Ω–Ω—ã–µ —Ç–∞–±—ã –∏ –ø—Ä–æ–±–µ–ª—ã –≤ –æ—Ç—Å—Ç—É–ø–∞—Ö",
                        "type": "warning"
                    })
            
            # –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –æ–ø–µ—á–∞—Ç–∫–∏
            typos = {
                "pritn": "print",
                "improt": "import",
                "retrun": "return",
                "ture": "True",
                "flase": "False",
                "noen": "None",
                "slef": "self",
                "defint": "define",
            }
            for typo, correct in typos.items():
                if typo in line.lower():
                    errors.append({
                        "line": i,
                        "col": line.lower().find(typo),
                        "message": f"–í–æ–∑–º–æ–∂–Ω–æ –æ–ø–µ—á–∞—Ç–∫–∞: '{typo}' ‚Üí '{correct}'",
                        "type": "hint"
                    })
        
        return errors
    
    def _lint_javascript(self, tab: Tab) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å JavaScript –∫–æ–¥"""
        errors = []
        
        for i, line in enumerate(tab.buffer.lines, 1):
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ var –≤–º–µ—Å—Ç–æ let/const
            if re.search(r'\bvar\s+', line):
                errors.append({
                    "line": i,
                    "col": line.find('var'),
                    "message": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'let' –∏–ª–∏ 'const' –≤–º–µ—Å—Ç–æ 'var'",
                    "type": "warning"
                })
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ == –≤–º–µ—Å—Ç–æ ===
            if '==' in line and '===' not in line and '!==' not in line:
                errors.append({
                    "line": i,
                    "col": line.find('=='),
                    "message": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ '===' –≤–º–µ—Å—Ç–æ '==' –¥–ª—è —Å—Ç—Ä–æ–≥–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è",
                    "type": "hint"
                })
            
            # –î–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
            if len(line) > 100:
                errors.append({
                    "line": i,
                    "col": 100,
                    "message": f"–°—Ç—Ä–æ–∫–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è ({len(line)} > 100)",
                    "type": "warning"
                })
        
        return errors
    
    def _lint_json(self, tab: Tab) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å JSON"""
        errors = []
        try:
            json.loads(tab.buffer.get_text())
        except json.JSONDecodeError as e:
            errors.append({
                "line": e.lineno,
                "col": e.colno,
                "message": e.msg,
                "type": "error"
            })
        return errors
    
    def _lint_html(self, tab: Tab) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å HTML"""
        errors = []
        
        # –°—Ç–µ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ç–µ–≥–æ–≤
        tag_stack = []
        tag_pattern = re.compile(r'<(/?)(\w+)[^>]*(/?)>')
        
        for i, line in enumerate(tab.buffer.lines, 1):
            for match in tag_pattern.finditer(line):
                is_closing = match.group(1) == '/'
                tag_name = match.group(2).lower()
                is_self_closing = match.group(3) == '/'
                
                # –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å void —ç–ª–µ–º–µ–Ω—Ç—ã
                void_elements = {'br', 'hr', 'img', 'input', 'link', 'meta', 
                               'area', 'base', 'col', 'embed', 'param', 'source', 'track', 'wbr'}
                
                if tag_name in void_elements or is_self_closing:
                    continue
                
                if is_closing:
                    if not tag_stack:
                        errors.append({
                            "line": i,
                            "col": match.start(),
                            "message": f"–ó–∞–∫—Ä—ã–≤–∞—é—â–∏–π —Ç–µ–≥ </{tag_name}> –±–µ–∑ –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–≥–æ",
                            "type": "error"
                        })
                    elif tag_stack[-1][0] != tag_name:
                        errors.append({
                            "line": i,
                            "col": match.start(),
                            "message": f"–û–∂–∏–¥–∞–ª—Å—è </{tag_stack[-1][0]}>, –ø–æ–ª—É—á–µ–Ω </{tag_name}>",
                            "type": "error"
                        })
                        tag_stack.pop()
                    else:
                        tag_stack.pop()
                else:
                    tag_stack.append((tag_name, i, match.start()))
        
        # –ù–µ–∑–∞–∫—Ä—ã—Ç—ã–µ —Ç–µ–≥–∏
        for tag_name, line, col in tag_stack:
            errors.append({
                "line": line,
                "col": col,
                "message": f"–ù–µ–∑–∞–∫—Ä—ã—Ç—ã–π —Ç–µ–≥ <{tag_name}>",
                "type": "warning"
            })
        
        return errors
    
    def _lint_basic(self, tab: Tab) -> List[Dict]:
        """–ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤"""
        errors = []
        
        for i, line in enumerate(tab.buffer.lines, 1):
            # –¢–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
            if len(line) > 200:
                errors.append({
                    "line": i,
                    "col": 200,
                    "message": "–û—á–µ–Ω—å –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞",
                    "type": "warning"
                })
        
        return errors
    
    def get_errors_for_line(self, tab_id: int, line: int) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—à–∏–±–∫–∏ –¥–ª—è —Å—Ç—Ä–æ–∫–∏"""
        if tab_id not in self.errors:
            return []
        return [e for e in self.errors[tab_id] if e["line"] == line]
    
    def show_errors_dialog(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –æ—à–∏–±–æ–∫"""
        errors = self.lint_current()
        
        if not errors:
            MessageDialog(self.editor.stdscr, "Linter",
                         "–û—à–∏–±–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ! ‚úÖ", "success").show()
            return
        
        items = []
        for err in errors:
            icon = "‚ùå" if err["type"] == "error" else "‚ö†Ô∏è" if err["type"] == "warning" else "üí°"
            items.append(f"{icon} –°—Ç—Ä–æ–∫–∞ {err['line']}: {err['message'][:50]}")
        
        dialog = ListDialog(self.editor.stdscr, 
                           f"üîç –ù–∞–π–¥–µ–Ω–æ {len(errors)} –ø—Ä–æ–±–ª–µ–º", items)
        choice = dialog.show()
        
        if choice is not None:
            # –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ—à–∏–±–∫–µ
            err = errors[choice]
            tab = self.editor.tab_manager.active_tab
            if tab:
                tab.cursor.move_to(err["line"] - 1, err.get("col", 0), tab.buffer)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 6: FORMATTER - –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FormatterPlugin(Plugin):
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞"""
    
    name = "Formatter"
    description = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞"
    
    def format_current(self) -> bool:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π —Ñ–∞–π–ª"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return False
        
        language = tab.buffer.language
        
        if language == "python":
            return self._format_python(tab)
        elif language == "json":
            return self._format_json(tab)
        elif language in ["javascript", "typescript"]:
            return self._format_javascript(tab)
        elif language in ["html", "xml"]:
            return self._format_html(tab)
        elif language == "css":
            return self._format_css(tab)
        else:
            return self._format_basic(tab)
    
    def _format_python(self, tab: Tab) -> bool:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å Python"""
        lines = tab.buffer.lines
        formatted = []
        
        for line in lines:
            # –£–±—Ä–∞—Ç—å trailing whitespace
            line = line.rstrip()
            
            # –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ—Ç—Å—Ç—É–ø—ã (—Ç–∞–±—ã ‚Üí –ø—Ä–æ–±–µ–ª—ã)
            if line.startswith('\t'):
                indent_count = 0
                for c in line:
                    if c == '\t':
                        indent_count += 1
                    else:
                        break
                line = '    ' * indent_count + line.lstrip('\t')
            
            # –ü—Ä–æ–±–µ–ª—ã –≤–æ–∫—Ä—É–≥ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
            operators = ['==', '!=', '<=', '>=', '+=', '-=', '*=', '/=', 
                        ' = ', ' + ', ' - ', ' * ', ' / ']
            for op in operators:
                clean_op = op.strip()
                if clean_op in line and f' {clean_op} ' not in line:
                    # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ (–Ω–µ –∏–¥–µ–∞–ª—å–Ω–æ, –Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è –±–∞–∑–æ–≤—ã—Ö —Å–ª—É—á–∞–µ–≤)
                    pass
            
            formatted.append(line)
        
        # –£–±—Ä–∞—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        result = []
        prev_empty = False
        for line in formatted:
            is_empty = not line.strip()
            if is_empty and prev_empty:
                continue
            result.append(line)
            prev_empty = is_empty
        
        tab.buffer.lines = result
        tab.buffer.modified = True
        return True
    
    def _format_json(self, tab: Tab) -> bool:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å JSON"""
        try:
            data = json.loads(tab.buffer.get_text())
            formatted = json.dumps(data, indent=2, ensure_ascii=False)
            tab.buffer.set_text(formatted)
            return True
        except json.JSONDecodeError:
            return False
    
    def _format_javascript(self, tab: Tab) -> bool:
        """–ë–∞–∑–æ–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ JavaScript"""
        # –£–ø—Ä–æ—â—ë–Ω–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        lines = []
        indent = 0
        
        for line in tab.buffer.lines:
            stripped = line.strip()
            
            # –£–º–µ–Ω—å—à–∏—Ç—å –æ—Ç—Å—Ç—É–ø –¥–ª—è –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫
            if stripped.startswith('}') or stripped.startswith(']') or stripped.startswith(')'):
                indent = max(0, indent - 1)
            
            # –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Å –æ—Ç—Å—Ç—É–ø–æ–º
            if stripped:
                lines.append('  ' * indent + stripped)
            else:
                lines.append('')
            
            # –£–≤–µ–ª–∏—á–∏—Ç—å –æ—Ç—Å—Ç—É–ø –ø–æ—Å–ª–µ –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫
            if stripped.endswith('{') or stripped.endswith('[') or stripped.endswith('('):
                indent += 1
        
        tab.buffer.lines = lines
        tab.buffer.modified = True
        return True
    
    def _format_html(self, tab: Tab) -> bool:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å HTML"""
        lines = []
        indent = 0
        
        content = tab.buffer.get_text()
        # –†–∞–∑–±–∏—Ç—å –ø–æ —Ç–µ–≥–∞–º
        parts = re.split(r'(<[^>]+>)', content)
        
        current_line = ""
        void_tags = {'br', 'hr', 'img', 'input', 'link', 'meta', 'area', 
                    'base', 'col', 'embed', 'param', 'source', 'track', 'wbr'}
        
        for part in parts:
            part = part.strip()
            if not part:
                continue
            
            if part.startswith('</'):
                # –ó–∞–∫—Ä—ã–≤–∞—é—â–∏–π —Ç–µ–≥
                indent = max(0, indent - 1)
                lines.append('  ' * indent + part)
            elif part.startswith('<'):
                # –û—Ç–∫—Ä—ã–≤–∞—é—â–∏–π —Ç–µ–≥
                tag_match = re.match(r'<(\w+)', part)
                if tag_match:
                    tag_name = tag_match.group(1).lower()
                    lines.append('  ' * indent + part)
                    if tag_name not in void_tags and not part.endswith('/>'):
                        indent += 1
                else:
                    lines.append('  ' * indent + part)
            else:
                # –¢–µ–∫—Å—Ç
                if part:
                    lines.append('  ' * indent + part)
        
        tab.buffer.lines = lines
        tab.buffer.modified = True
        return True
    
    def _format_css(self, tab: Tab) -> bool:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å CSS"""
        lines = []
        content = tab.buffer.get_text()
        
        # –†–∞–∑–±–∏—Ç—å –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º
        indent = 0
        i = 0
        current = ""
        
        while i < len(content):
            c = content[i]
            
            if c == '{':
                lines.append(current.strip() + ' {')
                current = ""
                indent += 1
            elif c == '}':
                if current.strip():
                    lines.append('  ' * indent + current.strip())
                indent = max(0, indent - 1)
                lines.append('  ' * indent + '}')
                current = ""
            elif c == ';':
                lines.append('  ' * indent + current.strip() + ';')
                current = ""
            elif c == '\n':
                if current.strip():
                    current += ' '
            else:
                current += c
            
            i += 1
        
        if current.strip():
            lines.append(current.strip())
        
        tab.buffer.lines = lines
        tab.buffer.modified = True
        return True
    
    def _format_basic(self, tab: Tab) -> bool:
        """–ë–∞–∑–æ–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        lines = []
        for line in tab.buffer.lines:
            lines.append(line.rstrip())
        
        tab.buffer.lines = lines
        tab.buffer.modified = True
        return True


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 7: BOOKMARKS - –ó–ê–ö–õ–ê–î–ö–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class BookmarksPlugin(Plugin):
    """–ó–∞–∫–ª–∞–¥–∫–∏ –≤ –∫–æ–¥–µ"""
    
    name = "Bookmarks"
    description = "–ó–∞–∫–ª–∞–¥–∫–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.bookmarks: Dict[int, List[int]] = {}  # {tab_id: [line_numbers]}
    
    def toggle_bookmark(self):
        """–î–æ–±–∞–≤–∏—Ç—å/—É–¥–∞–ª–∏—Ç—å –∑–∞–∫–ª–∞–¥–∫—É –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        line = tab.cursor.row
        
        if tab.id not in self.bookmarks:
            self.bookmarks[tab.id] = []
        
        if line in self.bookmarks[tab.id]:
            self.bookmarks[tab.id].remove(line)
        else:
            self.bookmarks[tab.id].append(line)
            self.bookmarks[tab.id].sort()
    
    def next_bookmark(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–∫–ª–∞–¥–∫–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab or tab.id not in self.bookmarks:
            return
        
        bookmarks = self.bookmarks[tab.id]
        if not bookmarks:
            return
        
        current = tab.cursor.row
        
        # –ù–∞–π—Ç–∏ —Å–ª–µ–¥—É—é—â—É—é
        for bm in bookmarks:
            if bm > current:
                tab.cursor.move_to(bm, 0, tab.buffer)
                return
        
        # –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ—Ö–æ–¥
        tab.cursor.move_to(bookmarks[0], 0, tab.buffer)
    
    def prev_bookmark(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –∑–∞–∫–ª–∞–¥–∫–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab or tab.id not in self.bookmarks:
            return
        
        bookmarks = self.bookmarks[tab.id]
        if not bookmarks:
            return
        
        current = tab.cursor.row
        
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é
        for bm in reversed(bookmarks):
            if bm < current:
                tab.cursor.move_to(bm, 0, tab.buffer)
                return
        
        # –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ—Ö–æ–¥
        tab.cursor.move_to(bookmarks[-1], 0, tab.buffer)
    
    def get_bookmarks(self, tab_id: int) -> List[int]:
        """–ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–ª–∞–¥–∫–∏ –¥–ª—è –≤–∫–ª–∞–¥–∫–∏"""
        return self.bookmarks.get(tab_id, [])
    
    def has_bookmark(self, tab_id: int, line: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å—Ç—å –ª–∏ –∑–∞–∫–ª–∞–¥–∫–∞ –Ω–∞ —Å—Ç—Ä–æ–∫–µ"""
        return line in self.bookmarks.get(tab_id, [])
    
    def show_bookmarks(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–∫–ª–∞–¥–æ–∫"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        bookmarks = self.get_bookmarks(tab.id)
        if not bookmarks:
            MessageDialog(self.editor.stdscr, "–ó–∞–∫–ª–∞–¥–∫–∏",
                         "–ù–µ—Ç –∑–∞–∫–ª–∞–¥–æ–∫", "info").show()
            return
        
        items = []
        for bm in bookmarks:
            line_text = tab.buffer.get_line(bm)[:50]
            items.append(f"–°—Ç—Ä–æ–∫–∞ {bm + 1}: {line_text}")
        
        dialog = ListDialog(self.editor.stdscr, "üìå –ó–∞–∫–ª–∞–¥–∫–∏", items)
        choice = dialog.show()
        
        if choice is not None:
            tab.cursor.move_to(bookmarks[choice], 0, tab.buffer)
    
    def clear_all(self):
        """–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∑–∞–∫–ª–∞–¥–∫–∏"""
        tab = self.editor.tab_manager.active_tab
        if tab and tab.id in self.bookmarks:
            self.bookmarks[tab.id] = []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 8: FOLDING - –°–í–û–†–ê–ß–ò–í–ê–ù–ò–ï –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FoldingPlugin(Plugin):
    """–°–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ –±–ª–æ–∫–æ–≤ –∫–æ–¥–∞"""
    
    name = "Folding"
    description = "–°–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –∏ –∫–ª–∞—Å—Å–æ–≤"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.folds: Dict[int, Dict[int, int]] = {}  # {tab_id: {start_line: end_line}}
    
    def toggle_fold(self):
        """–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –±–ª–æ–∫ –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        line = tab.cursor.row
        
        if tab.id not in self.folds:
            self.folds[tab.id] = {}
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Å–≤—ë—Ä—Ç–∫–∞
        if line in self.folds[tab.id]:
            # –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å
            del self.folds[tab.id][line]
        else:
            # –ù–∞–π—Ç–∏ –∫–æ–Ω–µ—Ü –±–ª–æ–∫–∞ –∏ —Å–≤–µ—Ä–Ω—É—Ç—å
            end = self._find_block_end(tab, line)
            if end > line:
                self.folds[tab.id][line] = end
    
    def _find_block_end(self, tab: Tab, start_line: int) -> int:
        """–ù–∞–π—Ç–∏ –∫–æ–Ω–µ—Ü –±–ª–æ–∫–∞ –∫–æ–¥–∞"""
        language = tab.buffer.language
        start_indent = self._get_indent(tab.buffer.get_line(start_line))
        
        for i in range(start_line + 1, tab.buffer.line_count):
            line = tab.buffer.get_line(i)
            if line.strip():  # –ù–µ–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
                indent = self._get_indent(line)
                if indent <= start_indent:
                    return i - 1
        
        return tab.buffer.line_count - 1
    
    def _get_indent(self, line: str) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –æ—Ç—Å—Ç—É–ø–∞"""
        return len(line) - len(line.lstrip())
    
    def is_folded(self, tab_id: int, line: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–≤—ë—Ä–Ω—É—Ç–∞ –ª–∏ —Å—Ç—Ä–æ–∫–∞"""
        return line in self.folds.get(tab_id, {})
    
    def get_fold_end(self, tab_id: int, line: int) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–µ—Ü —Å–≤—ë—Ä—Ç–∫–∏"""
        return self.folds.get(tab_id, {}).get(line, line)
    
    def is_hidden(self, tab_id: int, line: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–∫—Ä—ã—Ç–∞ –ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–≤—ë—Ä—Ç–∫–æ–π"""
        for start, end in self.folds.get(tab_id, {}).items():
            if start < line <= end:
                return True
        return False
    
    def fold_all(self):
        """–°–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ –±–ª–æ–∫–∏"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        self.folds[tab.id] = {}
        
        i = 0
        while i < tab.buffer.line_count:
            line = tab.buffer.get_line(i)
            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—á–∞–ª–æ –±–ª–æ–∫–∞
            if self._is_block_start(line, tab.buffer.language):
                end = self._find_block_end(tab, i)
                if end > i:
                    self.folds[tab.id][i] = end
                    i = end
            i += 1
    
    def unfold_all(self):
        """–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ –±–ª–æ–∫–∏"""
        tab = self.editor.tab_manager.active_tab
        if tab and tab.id in self.folds:
            self.folds[tab.id] = {}
    
    def _is_block_start(self, line: str, language: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ª–∏ –±–ª–æ–∫ –Ω–∞ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ"""
        stripped = line.strip()
        
        if language == "python":
            return (stripped.startswith('def ') or 
                    stripped.startswith('class ') or
                    stripped.startswith('if ') or
                    stripped.startswith('for ') or
                    stripped.startswith('while ') or
                    stripped.startswith('try:') or
                    stripped.startswith('with '))
        elif language in ["javascript", "typescript", "java", "c", "cpp", "csharp"]:
            return stripped.endswith('{')
        
        return False


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 9: AUTOCOMPLETE - –ê–í–¢–û–î–û–ü–û–õ–ù–ï–ù–ò–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AutoCompletePlugin(Plugin):
    """–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–¥–∞"""
    
    name = "AutoComplete"
    description = "–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ª–æ–≤ –∏ –∫–æ–¥–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.suggestions: List[str] = []
        self.selected = 0
        self.is_active = False
        self.prefix = ""
    
    def get_completions(self, tab: Tab) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è"""
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        # –ù–∞–π—Ç–∏ —Å–ª–æ–≤–æ –¥–æ –∫—É—Ä—Å–æ—Ä–∞
        word_start = col
        while word_start > 0 and (line[word_start - 1].isalnum() or line[word_start - 1] == '_'):
            word_start -= 1
        
        self.prefix = line[word_start:col]
        
        if len(self.prefix) < 2:
            return []
        
        suggestions = set()
        
        # –°–ª–æ–≤–∞ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ñ–∞–π–ª–∞
        all_text = tab.buffer.get_text()
        words = re.findall(r'\b([a-zA-Z_]\w{2,})\b', all_text)
        for word in words:
            if word.lower().startswith(self.prefix.lower()) and word != self.prefix:
                suggestions.add(word)
        
        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —è–∑—ã–∫–∞
        language = tab.buffer.language
        if language and language in LANGUAGES:
            lang = LANGUAGES[language]
            for kw in lang.get("keywords", []):
                if kw.lower().startswith(self.prefix.lower()):
                    suggestions.add(kw)
            for bi in lang.get("builtins", []):
                if bi.lower().startswith(self.prefix.lower()):
                    suggestions.add(bi)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Å–Ω–∞—á–∞–ª–∞ —Ç–æ—á–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è, –ø–æ—Ç–æ–º –ø–æ –¥–ª–∏–Ω–µ
        result = sorted(suggestions, key=lambda x: (
            not x.startswith(self.prefix),  # –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞
            len(x)
        ))
        
        return result[:15]  # –ú–∞–∫—Å–∏–º—É–º 15 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
    
    def show_popup(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ø–∞–ø –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        self.suggestions = self.get_completions(tab)
        if not self.suggestions:
            return
        
        self.selected = 0
        self.is_active = True
    
    def hide_popup(self):
        """–°–∫—Ä—ã—Ç—å –ø–æ–ø–∞–ø"""
        self.is_active = False
        self.suggestions = []
        self.selected = 0
    
    def select_next(self):
        """–í—ã–±—Ä–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –≤–∞—Ä–∏–∞–Ω—Ç"""
        if self.suggestions:
            self.selected = (self.selected + 1) % len(self.suggestions)
    
    def select_prev(self):
        """–í—ã–±—Ä–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –≤–∞—Ä–∏–∞–Ω—Ç"""
        if self.suggestions:
            self.selected = (self.selected - 1) % len(self.suggestions)
    
    def apply_completion(self) -> bool:
        """–ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ"""
        if not self.is_active or not self.suggestions:
            return False
        
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return False
        
        selected_word = self.suggestions[self.selected]
        
        # –ó–∞–º–µ–Ω–∏—Ç—å prefix –Ω–∞ selected_word
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        word_start = col - len(self.prefix)
        new_line = line[:word_start] + selected_word + line[col:]
        
        tab.buffer.set_line(tab.cursor.row, new_line)
        tab.cursor.col = word_start + len(selected_word)
        
        self.hide_popup()
        return True
    
    def draw_popup(self, stdscr, y: int, x: int, max_height: int, max_width: int):
        """–û—Ç—Ä–∏—Å–æ–≤–∞—Ç—å –ø–æ–ø–∞–ø –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è"""
        if not self.is_active or not self.suggestions:
            return
        
        popup_height = min(len(self.suggestions), max_height, 8)
        popup_width = min(max(len(s) for s in self.suggestions) + 4, max_width, 40)
        
        # –ü–æ–∑–∏—Ü–∏—è
        if y + popup_height >= max_height:
            y = max(0, y - popup_height - 1)
        if x + popup_width >= max_width:
            x = max(0, max_width - popup_width - 1)
        
        # –†–∞–º–∫–∞
        try:
            for i in range(popup_height):
                stdscr.addstr(y + i, x, " " * popup_width,
                             Colors.get_pair(Colors.WHITE, Colors.BLUE))
            
            # –≠–ª–µ–º–µ–Ω—Ç—ã
            for i, suggestion in enumerate(self.suggestions[:popup_height]):
                if i == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                else:
                    attr = Colors.get_pair(Colors.WHITE, Colors.BLUE)
                
                display = f" {suggestion} "[:popup_width]
                stdscr.addstr(y + i, x, display.ljust(popup_width), attr)
        except:
            pass


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 10: COMMENTS - –ö–û–ú–ú–ï–ù–¢–ò–†–û–í–ê–ù–ò–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CommentsPlugin(Plugin):
    """–ö–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞"""
    
    name = "Comments"
    description = "–ë—ã—Å—Ç—Ä–æ–µ –∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫"
    
    def toggle_comment(self):
        """–ó–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å/—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        language = tab.buffer.language or "python"
        comment_str = LANGUAGES.get(language, {}).get("comment", "#")
        
        if not comment_str:
            return
        
        line_num = tab.cursor.row
        line = tab.buffer.get_line(line_num)
        stripped = line.lstrip()
        indent = line[:len(line) - len(stripped)]
        
        if stripped.startswith(comment_str):
            # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
            new_line = indent + stripped[len(comment_str):].lstrip()
        else:
            # –ó–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
            new_line = indent + comment_str + " " + stripped
        
        tab.buffer.set_line(line_num, new_line)
    
    def toggle_block_comment(self, start_line: int, end_line: int):
        """–ó–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å/—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        language = tab.buffer.language or "python"
        comment_str = LANGUAGES.get(language, {}).get("comment", "#")
        
        if not comment_str:
            return
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –ª–∏ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
        all_commented = True
        for i in range(start_line, end_line + 1):
            line = tab.buffer.get_line(i)
            if line.strip() and not line.lstrip().startswith(comment_str):
                all_commented = False
                break
        
        # –ü—Ä–∏–º–µ–Ω–∏—Ç—å
        for i in range(start_line, end_line + 1):
            line = tab.buffer.get_line(i)
            stripped = line.lstrip()
            indent = line[:len(line) - len(stripped)]
            
            if all_commented:
                # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
                if stripped.startswith(comment_str):
                    new_line = indent + stripped[len(comment_str):].lstrip()
                    tab.buffer.set_line(i, new_line)
            else:
                # –ó–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
                if stripped and not stripped.startswith(comment_str):
                    new_line = indent + comment_str + " " + stripped
                    tab.buffer.set_line(i, new_line)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 11: AUTOSAVE - –ê–í–¢–û–°–û–•–†–ê–ù–ï–ù–ò–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AutoSavePlugin(Plugin):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ"""
    
    name = "AutoSave"
    description = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.last_save_time: Dict[int, float] = {}
        self.interval = settings.get("autosave_interval", 60)
        self.enabled = settings.get("autosave", True)
    
    def check_autosave(self):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ"""
        if not self.enabled:
            return
        
        current_time = time.time()
        
        for tab in self.editor.tab_manager.tabs:
            if not tab.buffer.modified or not tab.buffer.filename:
                continue
            
            last_save = self.last_save_time.get(tab.id, 0)
            
            if current_time - last_save >= self.interval:
                self._save_tab(tab)
                self.last_save_time[tab.id] = current_time
    
    def _save_tab(self, tab: Tab):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∫–ª–∞–¥–∫—É"""
        try:
            success, _ = tab.save_file()
            if success:
                # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é
                self._save_recovery(tab)
        except:
            pass
    
    def _save_recovery(self, tab: Tab):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
        if not tab.buffer.filename:
            return
        
        try:
            recovery_file = os.path.join(
                RECOVERY_DIR,
                hashlib.md5(tab.buffer.filename.encode()).hexdigest() + ".recovery"
            )
            
            data = {
                "filename": tab.buffer.filename,
                "content": tab.buffer.get_text(),
                "cursor": (tab.cursor.row, tab.cursor.col),
                "timestamp": time.time()
            }
            
            with open(recovery_file, 'w', encoding='utf-8') as f:
                json.dump(data, f)
        except:
            pass
    
    def get_recovery_files(self) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
        result = []
        
        try:
            for filename in os.listdir(RECOVERY_DIR):
                if filename.endswith('.recovery'):
                    filepath = os.path.join(RECOVERY_DIR, filename)
                    try:
                        with open(filepath, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            result.append({
                                "recovery_file": filepath,
                                "original_file": data.get("filename"),
                                "timestamp": data.get("timestamp"),
                                "content": data.get("content")
                            })
                    except:
                        pass
        except:
            pass
        
        return result
    
    def restore_file(self, recovery_data: Dict) -> bool:
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª"""
        try:
            content = recovery_data.get("content", "")
            filename = recovery_data.get("original_file")
            
            if filename:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                # –£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
                recovery_file = recovery_data.get("recovery_file")
                if recovery_file and os.path.exists(recovery_file):
                    os.remove(recovery_file)
                
                return True
        except:
            pass
        
        return False
    
    def clear_recovery(self):
        """–û—á–∏—Å—Ç–∏—Ç—å —Ñ–∞–π–ª—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
        try:
            for filename in os.listdir(RECOVERY_DIR):
                if filename.endswith('.recovery'):
                    os.remove(os.path.join(RECOVERY_DIR, filename))
        except:
            pass


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 12: SESSION - –£–ü–†–ê–í–õ–ï–ù–ò–ï –°–ï–°–°–ò–Ø–ú–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SessionPlugin(Plugin):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π"""
    
    name = "Session"
    description = "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏ –ø–æ–∑–∏—Ü–∏–π"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.session_file = os.path.join(SESSIONS_DIR, "last_session.json")
    
    def save_session(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é —Å–µ—Å—Å–∏—é"""
        session = {
            "tabs": [],
            "active_tab": self.editor.tab_manager.active_index,
            "timestamp": time.time()
        }
        
        for tab in self.editor.tab_manager.tabs:
            if tab.buffer.filename:
                session["tabs"].append({
                    "filename": tab.buffer.filename,
                    "cursor": (tab.cursor.row, tab.cursor.col),
                    "scroll": (tab.scroll_row, tab.scroll_col)
                })
        
        try:
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(session, f, indent=2)
        except:
            pass
    
    def load_session(self) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–µ—Å—Å–∏—é"""
        try:
            if not os.path.exists(self.session_file):
                return False
            
            with open(self.session_file, 'r', encoding='utf-8') as f:
                session = json.load(f)
            
            # –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª—ã
            for tab_data in session.get("tabs", []):
                filename = tab_data.get("filename")
                if filename and os.path.exists(filename):
                    tab = self.editor.tab_manager.open_file(filename)
                    if tab:
                        cursor = tab_data.get("cursor", (0, 0))
                        scroll = tab_data.get("scroll", (0, 0))
                        tab.cursor.move_to(cursor[0], cursor[1], tab.buffer)
                        tab.scroll_row, tab.scroll_col = scroll
            
            # –ê–∫—Ç–∏–≤–Ω–∞—è –≤–∫–ª–∞–¥–∫–∞
            active = session.get("active_tab", 0)
            if 0 <= active < len(self.editor.tab_manager.tabs):
                self.editor.tab_manager.active_index = active
            
            return True
            
        except:
            return False
    
    def clear_session(self):
        """–û—á–∏—Å—Ç–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é —Å–µ—Å—Å–∏—é"""
        try:
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
        except:
            pass


print("‚úÖ –ß–∞—Å—Ç—å 4/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: 12 –ø–ª–∞–≥–∏–Ω–æ–≤ (Runner, FileExplorer, Git, Snippets, Linter, –∏ –¥—Ä.)")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–û–î–°–í–ï–¢–ö–ê –°–ò–ù–¢–ê–ö–°–ò–°–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SyntaxHighlighter:
    """–î–≤–∏–∂–æ–∫ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤"""
    
    def __init__(self):
        self.cache: Dict[str, List[List[Tuple[str, int]]]] = {}
        self.cache_valid: Dict[str, bool] = {}
        
    def invalidate_cache(self, buffer_id: str):
        """–°–±—Ä–æ—Å–∏—Ç—å –∫—ç—à –¥–ª—è –±—É—Ñ–µ—Ä–∞"""
        self.cache_valid[buffer_id] = False
    
    def highlight_line(self, line: str, language: Optional[str], 
                       theme: Dict, in_multiline_string: bool = False,
                       in_multiline_comment: bool = False) -> Tuple[List[Tuple[str, int]], bool, bool]:
        """
        –ü–æ–¥—Å–≤–µ—Ç–∏—Ç—å –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (—Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤, –≤_–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–π_—Å—Ç—Ä–æ–∫–µ, –≤_–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–º_–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏)
        """
        if not language or language not in LANGUAGES:
            return [(line, Colors.get_pair(Colors.WHITE))], False, False
        
        lang = LANGUAGES[language]
        tokens = []
        i = 0
        line_len = len(line)
        
        # –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç–∞ –∏–∑ —Ç–µ–º—ã
        keyword_color = Colors.get_pair(theme.get("keyword", Colors.MAGENTA))
        string_color = Colors.get_pair(theme.get("string", Colors.GREEN))
        comment_color = Colors.get_pair(theme.get("comment", Colors.CYAN))
        number_color = Colors.get_pair(theme.get("number", Colors.YELLOW))
        function_color = Colors.get_pair(theme.get("function", Colors.BLUE))
        class_color = Colors.get_pair(theme.get("class_name", Colors.CYAN))
        operator_color = Colors.get_pair(theme.get("operator", Colors.WHITE))
        default_color = Colors.get_pair(theme.get("fg", Colors.WHITE))
        builtin_color = Colors.get_pair(theme.get("builtin", Colors.CYAN))
        type_color = Colors.get_pair(theme.get("type", Colors.CYAN))
        tag_color = Colors.get_pair(theme.get("tag", Colors.RED))
        attribute_color = Colors.get_pair(theme.get("attribute", Colors.YELLOW))
        
        # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
        if in_multiline_comment:
            comment_multi = lang.get("comment_multi")
            if comment_multi:
                end_marker = comment_multi[1]
                end_idx = line.find(end_marker)
                if end_idx != -1:
                    tokens.append((line[:end_idx + len(end_marker)], comment_color))
                    i = end_idx + len(end_marker)
                    in_multiline_comment = False
                else:
                    return [(line, comment_color)], in_multiline_string, True
        
        # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        if in_multiline_string:
            # –ò—â–µ–º –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ –∫–∞–≤—ã—á–∫–∏
            for quote in ['"""', "'''", '`']:
                end_idx = line.find(quote)
                if end_idx != -1:
                    tokens.append((line[:end_idx + len(quote)], string_color))
                    i = end_idx + len(quote)
                    in_multiline_string = False
                    break
            else:
                return [(line, string_color)], True, in_multiline_comment
        
        keywords = set(lang.get("keywords", []))
        builtins = set(lang.get("builtins", []))
        types = set(lang.get("types", []))
        tags = set(lang.get("tags", []))
        properties = set(lang.get("properties", []))
        comment_single = lang.get("comment")
        comment_multi = lang.get("comment_multi")
        
        operators = {'+', '-', '*', '/', '%', '=', '<', '>', '!', '&', '|', '^', '~', ':', ';', ',', '.'}
        brackets = {'(', ')', '[', ']', '{', '}'}
        
        while i < line_len:
            # –û–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
            if comment_single and line[i:].startswith(comment_single):
                tokens.append((line[i:], comment_color))
                break
            
            # –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–∞—á–∞–ª–æ
            if comment_multi and line[i:].startswith(comment_multi[0]):
                end_marker = comment_multi[1]
                end_idx = line.find(end_marker, i + len(comment_multi[0]))
                if end_idx != -1:
                    tokens.append((line[i:end_idx + len(end_marker)], comment_color))
                    i = end_idx + len(end_marker)
                else:
                    tokens.append((line[i:], comment_color))
                    return tokens, in_multiline_string, True
                continue
            
            # –°—Ç—Ä–æ–∫–∏
            if line[i] in '"\'`':
                quote = line[i]
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç—Ä–æ–π–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
                if line[i:i+3] in ['"""', "'''"]:
                    triple_quote = line[i:i+3]
                    end_idx = line.find(triple_quote, i + 3)
                    if end_idx != -1:
                        tokens.append((line[i:end_idx + 3], string_color))
                        i = end_idx + 3
                    else:
                        tokens.append((line[i:], string_color))
                        return tokens, True, in_multiline_comment
                    continue
                
                # –û–±—ã—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
                j = i + 1
                while j < line_len:
                    if line[j] == '\\' and j + 1 < line_len:
                        j += 2
                    elif line[j] == quote:
                        j += 1
                        break
                    else:
                        j += 1
                tokens.append((line[i:j], string_color))
                i = j
                continue
            
            # –ß–∏—Å–ª–∞
            if line[i].isdigit() or (line[i] == '.' and i + 1 < line_len and line[i+1].isdigit()):
                j = i
                has_dot = False
                has_exp = False
                # –®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–µ
                if line[i:i+2].lower() in ['0x', '0b', '0o']:
                    j = i + 2
                    while j < line_len and (line[j].isalnum() or line[j] == '_'):
                        j += 1
                else:
                    while j < line_len:
                        if line[j].isdigit() or line[j] == '_':
                            j += 1
                        elif line[j] == '.' and not has_dot:
                            has_dot = True
                            j += 1
                        elif line[j].lower() in 'ej' and not has_exp:
                            has_exp = True
                            j += 1
                            if j < line_len and line[j] in '+-':
                                j += 1
                        elif line[j].lower() in 'fldul':
                            j += 1
                            break
                        else:
                            break
                tokens.append((line[i:j], number_color))
                i = j
                continue
            
            # –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
            if line[i].isalpha() or line[i] == '_':
                j = i
                while j < line_len and (line[j].isalnum() or line[j] == '_'):
                    j += 1
                word = line[i:j]
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é (–∑–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —Å–ª–µ–¥—É–µ—Ç ()
                is_function = j < line_len and line[j] == '('
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–ª–∞—Å—Å (—Å–ª–µ–¥—É–µ—Ç –∑–∞ class/def –∏–ª–∏ —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã)
                is_class = word[0].isupper() and not word.isupper()
                
                if word in keywords:
                    tokens.append((word, keyword_color | curses.A_BOLD))
                elif word in builtins:
                    tokens.append((word, builtin_color))
                elif word in types:
                    tokens.append((word, type_color))
                elif word in tags:
                    tokens.append((word, tag_color))
                elif word in properties:
                    tokens.append((word, attribute_color))
                elif is_function:
                    tokens.append((word, function_color))
                elif is_class:
                    tokens.append((word, class_color))
                else:
                    tokens.append((word, default_color))
                i = j
                continue
            
            # –î–µ–∫–æ—Ä–∞—Ç–æ—Ä—ã (Python, Java, etc.)
            if line[i] == '@' and i + 1 < line_len and (line[i+1].isalpha() or line[i+1] == '_'):
                j = i + 1
                while j < line_len and (line[j].isalnum() or line[j] == '_'):
                    j += 1
                tokens.append((line[i:j], keyword_color | curses.A_BOLD))
                i = j
                continue
            
            # HTML/XML —Ç–µ–≥–∏
            if language in ['html', 'xml', 'vue', 'svelte'] and line[i] == '<':
                j = i + 1
                if j < line_len and line[j] == '/':
                    j += 1
                while j < line_len and (line[j].isalnum() or line[j] in '-_'):
                    j += 1
                tokens.append((line[i:j], tag_color))
                i = j
                continue
            
            # –û–ø–µ—Ä–∞—Ç–æ—Ä—ã
            if line[i] in operators:
                j = i
                while j < line_len and line[j] in operators:
                    j += 1
                tokens.append((line[i:j], operator_color))
                i = j
                continue
            
            # –°–∫–æ–±–∫–∏
            if line[i] in brackets:
                tokens.append((line[i], operator_color))
                i += 1
                continue
            
            # –ü—Ä–æ–±–µ–ª—ã –∏ –æ—Å—Ç–∞–ª—å–Ω–æ–µ
            tokens.append((line[i], default_color))
            i += 1
        
        return tokens, in_multiline_string, in_multiline_comment
    
    def get_highlighted_lines(self, buffer: Buffer, theme: Dict) -> List[List[Tuple[str, int]]]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏"""
        result = []
        in_string = False
        in_comment = False
        
        for i, line in enumerate(buffer.lines):
            tokens, in_string, in_comment = self.highlight_line(
                line, buffer.language, theme, in_string, in_comment
            )
            result.append(tokens)
        
        return result


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB/–í–ö–õ–ê–î–ö–ê –†–ï–î–ê–ö–¢–û–†–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Tab:
    """–í–∫–ª–∞–¥–∫–∞ —Å —Ñ–∞–π–ª–æ–º"""
    
    def __init__(self, filename: Optional[str] = None):
        self.buffer = Buffer()
        self.cursor = Cursor()
        self.history = History()
        self.scroll_row = 0
        self.scroll_col = 0
        self.id = id(self)
        
        if filename:
            self.load_file(filename)
        else:
            self.buffer.filename = None
            self.buffer.language = "python"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
    @property
    def title(self) -> str:
        """–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤–∫–ª–∞–¥–∫–∏"""
        if self.buffer.filename:
            name = os.path.basename(self.buffer.filename)
        else:
            name = "–ë–µ–∑ –∏–º–µ–Ω–∏"
        
        if self.buffer.modified:
            name += " ‚óè"
        
        return name
    
    @property
    def icon(self) -> str:
        """–ò–∫–æ–Ω–∫–∞ —Ñ–∞–π–ª–∞"""
        if self.buffer.filename:
            return Utils.get_file_icon(self.buffer.filename)
        return "üìÑ"
    
    def load_file(self, filename: str) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª"""
        try:
            filepath = os.path.abspath(filename)
            
            if not os.path.exists(filepath):
                # –ù–æ–≤—ã–π —Ñ–∞–π–ª
                self.buffer.filename = filepath
                self.buffer.lines = [""]
                self.buffer.modified = False
                self.buffer.detect_language()
                return True
            
            if os.path.isdir(filepath):
                return False
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª
            if Utils.is_binary_file(filepath):
                return False
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
            size = os.path.getsize(filepath)
            if size > MAX_FILE_SIZE_MB * 1024 * 1024:
                return False
            
            content, encoding = Utils.safe_read_file(filepath)
            self.buffer.set_text(content)
            self.buffer.filename = filepath
            self.buffer.encoding = encoding
            self.buffer.modified = False
            self.buffer.detect_language()
            
            self.history.clear()
            self.cursor.move_to(0, 0, self.buffer)
            self.scroll_row = 0
            self.scroll_col = 0
            
            settings.add_recent_file(filepath)
            return True
            
        except Exception as e:
            return False
    
    def save_file(self, filename: Optional[str] = None) -> Tuple[bool, str]:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª"""
        try:
            if filename:
                self.buffer.filename = os.path.abspath(filename)
                self.buffer.detect_language()
            
            if not self.buffer.filename:
                return False, "–ù–µ —É–∫–∞–∑–∞–Ω–æ –∏–º—è —Ñ–∞–π–ª–∞"
            
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç
            content = self.buffer.get_text()
            
            # –£–±—Ä–∞—Ç—å trailing whitespace –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
            if settings.get("trim_trailing_whitespace"):
                lines = content.split('\n')
                lines = [line.rstrip() for line in lines]
                content = '\n'.join(lines)
            
            # –î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—ã–π newline –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
            if settings.get("insert_final_newline"):
                if not content.endswith('\n'):
                    content += '\n'
            
            # –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            dirname = os.path.dirname(self.buffer.filename)
            if dirname and not os.path.exists(dirname):
                os.makedirs(dirname)
            
            Utils.safe_write_file(self.buffer.filename, content, self.buffer.encoding)
            self.buffer.modified = False
            
            settings.add_recent_file(self.buffer.filename)
            return True, f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {self.buffer.filename}"
            
        except PermissionError:
            return False, "–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –∑–∞–ø–∏—Å—å"
        except Exception as e:
            return False, f"–û—à–∏–±–∫–∞: {str(e)}"
    
    def ensure_cursor_visible(self, height: int, width: int, line_num_width: int):
        """–£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –∫—É—Ä—Å–æ—Ä –≤–∏–¥–∏–º"""
        # –£—á–∏—Ç—ã–≤–∞–µ–º —à–∏—Ä–∏–Ω—É –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–æ–∫
        text_width = width - line_num_width - 1
        text_height = height
        
        # –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞
        if self.cursor.row < self.scroll_row:
            self.scroll_row = self.cursor.row
        elif self.cursor.row >= self.scroll_row + text_height:
            self.scroll_row = self.cursor.row - text_height + 1
        
        # –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞
        if self.cursor.col < self.scroll_col:
            self.scroll_col = max(0, self.cursor.col - 5)
        elif self.cursor.col >= self.scroll_col + text_width:
            self.scroll_col = self.cursor.col - text_width + 5


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ú–ï–ù–ï–î–ñ–ï–† –í–ö–õ–ê–î–û–ö
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TabManager:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∞–º–∏"""
    
    def __init__(self):
        self.tabs: List[Tab] = []
        self.active_index: int = 0
    
    @property
    def active_tab(self) -> Optional[Tab]:
        if 0 <= self.active_index < len(self.tabs):
            return self.tabs[self.active_index]
        return None
    
    @property
    def count(self) -> int:
        return len(self.tabs)
    
    def new_tab(self, filename: Optional[str] = None) -> Tab:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≤–∫–ª–∞–¥–∫—É"""
        tab = Tab(filename)
        self.tabs.append(tab)
        self.active_index = len(self.tabs) - 1
        return tab
    
    def close_tab(self, index: Optional[int] = None) -> bool:
        """–ó–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É"""
        if index is None:
            index = self.active_index
        
        if 0 <= index < len(self.tabs):
            tab = self.tabs[index]
            
            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            if tab.buffer.modified:
                return False  # –ù—É–∂–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            
            del self.tabs[index]
            
            if self.active_index >= len(self.tabs):
                self.active_index = max(0, len(self.tabs) - 1)
            
            return True
        return False
    
    def next_tab(self):
        """–°–ª–µ–¥—É—é—â–∞—è –≤–∫–ª–∞–¥–∫–∞"""
        if self.tabs:
            self.active_index = (self.active_index + 1) % len(self.tabs)
    
    def prev_tab(self):
        """–ü—Ä–µ–¥—ã–¥—É—â–∞—è –≤–∫–ª–∞–¥–∫–∞"""
        if self.tabs:
            self.active_index = (self.active_index - 1) % len(self.tabs)
    
    def goto_tab(self, index: int):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–∫–ª–∞–¥–∫–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É"""
        if 0 <= index < len(self.tabs):
            self.active_index = index
    
    def find_tab_by_filename(self, filename: str) -> Optional[int]:
        """–ù–∞–π—Ç–∏ –≤–∫–ª–∞–¥–∫—É –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        abs_path = os.path.abspath(filename)
        for i, tab in enumerate(self.tabs):
            if tab.buffer.filename == abs_path:
                return i
        return None
    
    def open_file(self, filename: str) -> Optional[Tab]:
        """–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª (–≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∏–ª–∏ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ)"""
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ –æ—Ç–∫—Ä—ã—Ç –ª–∏ —É–∂–µ
        existing = self.find_tab_by_filename(filename)
        if existing is not None:
            self.active_index = existing
            return self.tabs[existing]
        
        # –ï—Å–ª–∏ —Ç–µ–∫—É—â–∞—è –≤–∫–ª–∞–¥–∫–∞ –ø—É—Å—Ç–∞—è - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë
        if self.active_tab and not self.active_tab.buffer.filename and not self.active_tab.buffer.modified:
            if self.active_tab.load_file(filename):
                return self.active_tab
            return None
        
        # –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é
        tab = self.new_tab()
        if tab.load_file(filename):
            return tab
        else:
            # –û—Ç–∫–∞—Ç–∏—Ç—å
            self.tabs.pop()
            self.active_index = max(0, len(self.tabs) - 1)
            return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –î–ò–ê–õ–û–ì–û–í–´–ï –û–ö–ù–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Dialog:
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –¥–∏–∞–ª–æ–≥–æ–≤—ã—Ö –æ–∫–æ–Ω"""
    
    @staticmethod
    def draw_box(stdscr, y: int, x: int, height: int, width: int, 
                 title: str = "", color_pair: int = 0):
        """–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Ä–∞–º–∫—É"""
        # –£–≥–ª—ã –∏ –ª–∏–Ω–∏–∏
        stdscr.attron(color_pair)
        
        # –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
        stdscr.addstr(y, x, "‚ïî" + "‚ïê" * (width - 2) + "‚ïó")
        
        # –ë–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
        for i in range(1, height - 1):
            stdscr.addstr(y + i, x, "‚ïë")
            stdscr.addstr(y + i, x + width - 1, "‚ïë")
        
        # –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
        stdscr.addstr(y + height - 1, x, "‚ïö" + "‚ïê" * (width - 2) + "‚ïù")
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        if title:
            title_text = f" {title} "
            title_x = x + (width - len(title_text)) // 2
            stdscr.addstr(y, title_x, title_text)
        
        stdscr.attroff(color_pair)
    
    @staticmethod
    def center_pos(screen_height: int, screen_width: int, 
                   dialog_height: int, dialog_width: int) -> Tuple[int, int]:
        """–í—ã—á–∏—Å–ª–∏—Ç—å —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é"""
        y = (screen_height - dialog_height) // 2
        x = (screen_width - dialog_width) // 2
        return max(0, y), max(0, x)


class InputDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞"""
    
    def __init__(self, stdscr, title: str, prompt: str, 
                 default: str = "", password: bool = False):
        self.stdscr = stdscr
        self.title = title
        self.prompt = prompt
        self.value = default
        self.cursor_pos = len(default)
        self.password = password
        self.cancelled = False
    
    def show(self) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = 7
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(1)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.CYAN, -1))
            
            # –ü—Ä–æ–º–ø—Ç
            self.stdscr.addstr(y + 2, x + 2, self.prompt[:dialog_width - 4])
            
            # –ü–æ–ª–µ –≤–≤–æ–¥–∞
            input_width = dialog_width - 6
            display_value = "*" * len(self.value) if self.password else self.value
            
            # –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –¥–ª–∏–Ω–Ω—ã–π
            if len(display_value) > input_width:
                start = max(0, self.cursor_pos - input_width + 5)
                display_value = display_value[start:start + input_width]
                cursor_screen_pos = self.cursor_pos - start
            else:
                cursor_screen_pos = self.cursor_pos
            
            self.stdscr.addstr(y + 4, x + 3, "‚îÇ" + " " * input_width + "‚îÇ",
                              Colors.get_pair(Colors.WHITE, -1))
            self.stdscr.addstr(y + 4, x + 4, display_value)
            
            # –ö–Ω–æ–ø–∫–∏
            self.stdscr.addstr(y + 5, x + 2, "[Enter] OK  [Esc] –û—Ç–º–µ–Ω–∞",
                              Colors.get_pair(Colors.CYAN, -1))
            
            # –ö—É—Ä—Å–æ—Ä
            self.stdscr.move(y + 4, x + 4 + min(cursor_screen_pos, input_width - 1))
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                self.cancelled = True
                curses.curs_set(0)
                return None
            elif key in (10, 13, curses.KEY_ENTER):  # Enter
                curses.curs_set(0)
                return self.value
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if self.cursor_pos > 0:
                    self.value = self.value[:self.cursor_pos-1] + self.value[self.cursor_pos:]
                    self.cursor_pos -= 1
            elif key == curses.KEY_DC:  # Delete
                if self.cursor_pos < len(self.value):
                    self.value = self.value[:self.cursor_pos] + self.value[self.cursor_pos+1:]
            elif key == curses.KEY_LEFT:
                self.cursor_pos = max(0, self.cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                self.cursor_pos = min(len(self.value), self.cursor_pos + 1)
            elif key == curses.KEY_HOME:
                self.cursor_pos = 0
            elif key == curses.KEY_END:
                self.cursor_pos = len(self.value)
            elif 32 <= key <= 126:  # Printable
                self.value = self.value[:self.cursor_pos] + chr(key) + self.value[self.cursor_pos:]
                self.cursor_pos += 1


class ConfirmDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"""
    
    def __init__(self, stdscr, title: str, message: str, 
                 buttons: List[str] = None):
        self.stdscr = stdscr
        self.title = title
        self.message = message
        self.buttons = buttons or ["–î–∞", "–ù–µ—Ç"]
        self.selected = 0
    
    def show(self) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å –∏–Ω–¥–µ–∫—Å –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–Ω–æ–ø–∫–∏"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(50, width - 4)
        dialog_height = 8
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(0)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.YELLOW, -1))
            
            # –°–æ–æ–±—â–µ–Ω–∏–µ
            msg_lines = []
            words = self.message.split()
            current_line = ""
            for word in words:
                if len(current_line) + len(word) + 1 <= dialog_width - 4:
                    current_line += (" " if current_line else "") + word
                else:
                    msg_lines.append(current_line)
                    current_line = word
            if current_line:
                msg_lines.append(current_line)
            
            for i, line in enumerate(msg_lines[:3]):
                self.stdscr.addstr(y + 2 + i, x + 2, line[:dialog_width - 4])
            
            # –ö–Ω–æ–ø–∫–∏
            btn_y = y + dialog_height - 2
            total_btn_width = sum(len(b) + 4 for b in self.buttons) + len(self.buttons) - 1
            btn_x = x + (dialog_width - total_btn_width) // 2
            
            for i, btn in enumerate(self.buttons):
                if i == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                
                self.stdscr.addstr(btn_y, btn_x, f"[ {btn} ]", attr)
                btn_x += len(btn) + 5
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                return len(self.buttons) - 1  # –ü–æ—Å–ª–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ (–æ–±—ã—á–Ω–æ –û—Ç–º–µ–Ω–∞)
            elif key in (10, 13, curses.KEY_ENTER):
                return self.selected
            elif key in (curses.KEY_LEFT, ord('h')):
                self.selected = (self.selected - 1) % len(self.buttons)
            elif key in (curses.KEY_RIGHT, ord('l')):
                self.selected = (self.selected + 1) % len(self.buttons)
            elif key == ord('y') or key == ord('Y'):
                if "–î–∞" in self.buttons:
                    return self.buttons.index("–î–∞")
            elif key == ord('n') or key == ord('N'):
                if "–ù–µ—Ç" in self.buttons:
                    return self.buttons.index("–ù–µ—Ç")


class MessageDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ —Å–æ–æ–±—â–µ–Ω–∏—è"""
    
    def __init__(self, stdscr, title: str, message: str, 
                 msg_type: str = "info"):
        self.stdscr = stdscr
        self.title = title
        self.message = message
        self.msg_type = msg_type  # info, success, warning, error
    
    def show(self, timeout: float = 0):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(50, width - 4)
        dialog_height = 6
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        # –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
        colors = {
            "info": Colors.CYAN,
            "success": Colors.GREEN,
            "warning": Colors.YELLOW,
            "error": Colors.RED
        }
        icons = {
            "info": "‚ÑπÔ∏è",
            "success": "‚úÖ",
            "warning": "‚ö†Ô∏è",
            "error": "‚ùå"
        }
        
        color = colors.get(self.msg_type, Colors.WHITE)
        icon = icons.get(self.msg_type, "")
        
        # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
        for i in range(dialog_height):
            self.stdscr.addstr(y + i, x, " " * dialog_width)
        
        # –†–∞–º–∫–∞
        Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                       f"{icon} {self.title}", Colors.get_pair(color, -1))
        
        # –°–æ–æ–±—â–µ–Ω–∏–µ
        msg = self.message[:dialog_width - 4]
        self.stdscr.addstr(y + 2, x + 2, msg)
        
        # –ü–æ–¥—Å–∫–∞–∑–∫–∞
        self.stdscr.addstr(y + 4, x + 2, "[Enter/Esc] –ó–∞–∫—Ä—ã—Ç—å",
                          Colors.get_pair(Colors.CYAN, -1))
        
        self.stdscr.refresh()
        
        if timeout > 0:
            curses.napms(int(timeout * 1000))
        else:
            while True:
                key = self.stdscr.getch()
                if key in (27, 10, 13, curses.KEY_ENTER, ord(' ')):
                    break


class ListDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞"""
    
    def __init__(self, stdscr, title: str, items: List[str], 
                 icons: List[str] = None):
        self.stdscr = stdscr
        self.title = title
        self.items = items
        self.icons = icons or [""] * len(items)
        self.selected = 0
        self.scroll = 0
    
    def show(self) -> Optional[int]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –≤–µ—Ä–Ω—É—Ç—å –∏–Ω–¥–µ–∫—Å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = min(len(self.items) + 4, height - 4)
        visible_items = dialog_height - 4
        
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(0)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            # –†–∞–º–∫–∞
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           self.title, Colors.get_pair(Colors.MAGENTA, -1))
            
            # –≠–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞
            for i in range(visible_items):
                item_idx = self.scroll + i
                if item_idx >= len(self.items):
                    break
                
                icon = self.icons[item_idx] if item_idx < len(self.icons) else ""
                text = self.items[item_idx]
                
                if item_idx == self.selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                    prefix = "‚ñ∂ "
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                    prefix = "  "
                
                display = f"{prefix}{icon} {text}"[:dialog_width - 4]
                self.stdscr.addstr(y + 2 + i, x + 2, display.ljust(dialog_width - 4), attr)
            
            # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
            if len(self.items) > visible_items:
                scroll_info = f" {self.selected + 1}/{len(self.items)} "
                self.stdscr.addstr(y + dialog_height - 1, 
                                  x + dialog_width - len(scroll_info) - 2,
                                  scroll_info, Colors.get_pair(Colors.CYAN, -1))
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                return self.selected
            elif key in (curses.KEY_UP, ord('k')):
                if self.selected > 0:
                    self.selected -= 1
                    if self.selected < self.scroll:
                        self.scroll = self.selected
            elif key in (curses.KEY_DOWN, ord('j')):
                if self.selected < len(self.items) - 1:
                    self.selected += 1
                    if self.selected >= self.scroll + visible_items:
                        self.scroll = self.selected - visible_items + 1
            elif key == curses.KEY_HOME:
                self.selected = 0
                self.scroll = 0
            elif key == curses.KEY_END:
                self.selected = len(self.items) - 1
                self.scroll = max(0, len(self.items) - visible_items)
            elif key == curses.KEY_PPAGE:  # Page Up
                self.selected = max(0, self.selected - visible_items)
                self.scroll = max(0, self.scroll - visible_items)
            elif key == curses.KEY_NPAGE:  # Page Down
                self.selected = min(len(self.items) - 1, self.selected + visible_items)
                self.scroll = min(max(0, len(self.items) - visible_items),
                                 self.scroll + visible_items)


class SearchDialog(Dialog):
    """–î–∏–∞–ª–æ–≥ –ø–æ–∏—Å–∫–∞"""
    
    def __init__(self, stdscr, replace_mode: bool = False):
        self.stdscr = stdscr
        self.replace_mode = replace_mode
        self.search_text = ""
        self.replace_text = ""
        self.case_sensitive = False
        self.whole_word = False
        self.use_regex = False
        self.active_field = 0  # 0 = search, 1 = replace
        self.cursor_pos = 0
    
    def show(self) -> Optional[Dict]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –ø–æ–∏—Å–∫–∞"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_width = min(60, width - 4)
        dialog_height = 10 if self.replace_mode else 8
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        curses.curs_set(1)
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å
            for i in range(dialog_height):
                self.stdscr.addstr(y + i, x, " " * dialog_width)
            
            title = "üîç –ü–æ–∏—Å–∫ –∏ –∑–∞–º–µ–Ω–∞" if self.replace_mode else "üîç –ü–æ–∏—Å–∫"
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           title, Colors.get_pair(Colors.CYAN, -1))
            
            # –ü–æ–ª–µ –ø–æ–∏—Å–∫–∞
            label_color = Colors.get_pair(Colors.WHITE, -1)
            active_color = Colors.get_pair(Colors.CYAN, -1)
            
            self.stdscr.addstr(y + 2, x + 2, "–ù–∞–π—Ç–∏:", label_color)
            search_attr = active_color if self.active_field == 0 else label_color
            self.stdscr.addstr(y + 2, x + 10, f"[{self.search_text.ljust(dialog_width - 14)}]", 
                              search_attr)
            
            if self.replace_mode:
                self.stdscr.addstr(y + 3, x + 2, "–ó–∞–º–µ–Ω–∏—Ç—å:", label_color)
                replace_attr = active_color if self.active_field == 1 else label_color
                self.stdscr.addstr(y + 3, x + 12, 
                                  f"[{self.replace_text.ljust(dialog_width - 16)}]",
                                  replace_attr)
            
            # –û–ø—Ü–∏–∏
            opt_y = y + (5 if self.replace_mode else 4)
            
            cs_mark = "‚úì" if self.case_sensitive else " "
            ww_mark = "‚úì" if self.whole_word else " "
            rx_mark = "‚úì" if self.use_regex else " "
            
            self.stdscr.addstr(opt_y, x + 2, f"[{cs_mark}] –†–µ–≥–∏—Å—Ç—Ä  [{ww_mark}] –°–ª–æ–≤–æ  [{rx_mark}] Regex",
                              Colors.get_pair(Colors.YELLOW, -1))
            
            # –ö–Ω–æ–ø–∫–∏
            btn_y = opt_y + 2
            self.stdscr.addstr(btn_y, x + 2, "[Enter] –ù–∞–π—Ç–∏  [Esc] –û—Ç–º–µ–Ω–∞",
                              Colors.get_pair(Colors.CYAN, -1))
            if self.replace_mode:
                self.stdscr.addstr(btn_y, x + 35, "[Ctrl+R] –ó–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ")
            
            # –ö—É—Ä—Å–æ—Ä
            if self.active_field == 0:
                cursor_x = x + 11 + min(self.cursor_pos, len(self.search_text))
                self.stdscr.move(y + 2, cursor_x)
            else:
                cursor_x = x + 13 + min(self.cursor_pos, len(self.replace_text))
                self.stdscr.move(y + 3, cursor_x)
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # Esc
                curses.curs_set(0)
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                curses.curs_set(0)
                return {
                    "search": self.search_text,
                    "replace": self.replace_text if self.replace_mode else None,
                    "case_sensitive": self.case_sensitive,
                    "whole_word": self.whole_word,
                    "regex": self.use_regex
                }
            elif key == 9:  # Tab
                if self.replace_mode:
                    self.active_field = 1 - self.active_field
                    self.cursor_pos = len(self.replace_text if self.active_field == 1 
                                         else self.search_text)
            elif key == ord('c') - 96:  # Ctrl+C - toggle case
                self.case_sensitive = not self.case_sensitive
            elif key == ord('w') - 96:  # Ctrl+W - toggle word
                self.whole_word = not self.whole_word
            elif key == ord('x') - 96:  # Ctrl+X - toggle regex
                self.use_regex = not self.use_regex
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if self.active_field == 0 and self.cursor_pos > 0:
                    self.search_text = (self.search_text[:self.cursor_pos-1] + 
                                       self.search_text[self.cursor_pos:])
                    self.cursor_pos -= 1
                elif self.active_field == 1 and self.cursor_pos > 0:
                    self.replace_text = (self.replace_text[:self.cursor_pos-1] + 
                                        self.replace_text[self.cursor_pos:])
                    self.cursor_pos -= 1
            elif key == curses.KEY_LEFT:
                self.cursor_pos = max(0, self.cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                max_pos = len(self.search_text if self.active_field == 0 else self.replace_text)
                self.cursor_pos = min(max_pos, self.cursor_pos + 1)
            elif 32 <= key <= 126:
                char = chr(key)
                if self.active_field == 0:
                    self.search_text = (self.search_text[:self.cursor_pos] + char + 
                                       self.search_text[self.cursor_pos:])
                else:
                    self.replace_text = (self.replace_text[:self.cursor_pos] + char + 
                                        self.replace_text[self.cursor_pos:])
                self.cursor_pos += 1


print("‚úÖ –ß–∞—Å—Ç—å 3/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: SyntaxHighlighter, Tab, TabManager, Dialogs")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 13: TERMINAL - –í–°–¢–†–û–ï–ù–ù–´–ô –¢–ï–†–ú–ò–ù–ê–õ
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TerminalPlugin(Plugin):
    """–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π —Ç–µ—Ä–º–∏–Ω–∞–ª"""
    
    name = "Terminal"
    description = "–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π —Ç–µ—Ä–º–∏–Ω–∞–ª –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.history: List[str] = []
        self.history_index = 0
        self.output_lines: List[str] = []
        self.current_dir = os.getcwd()
        self.is_open = False
    
    def show(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ—Ä–º–∏–Ω–∞–ª"""
        self.is_open = True
        height, width = self.editor.stdscr.getmaxyx()
        
        # –¢–µ—Ä–º–∏–Ω–∞–ª –∑–∞–Ω–∏–º–∞–µ—Ç –Ω–∏–∂–Ω—é—é —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞
        term_height = height // 3
        term_y = height - term_height - 1
        
        input_buffer = ""
        cursor_pos = 0
        output_scroll = 0
        
        curses.curs_set(1)
        
        while self.is_open:
            # –û—á–∏—Å—Ç–∏—Ç—å –æ–±–ª–∞—Å—Ç—å —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
            for i in range(term_height + 1):
                try:
                    self.editor.stdscr.addstr(term_y + i, 0, " " * width)
                except:
                    pass
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            header = f" üíª –¢–µ—Ä–º–∏–Ω–∞–ª | {self.current_dir} "
            try:
                self.editor.stdscr.addstr(term_y, 0, header.ljust(width),
                                         Colors.get_pair(Colors.WHITE, Colors.MAGENTA))
            except:
                pass
            
            # –í—ã–≤–æ–¥
            output_area_height = term_height - 3
            visible_output = self.output_lines[-(output_area_height + output_scroll):]
            if output_scroll > 0:
                visible_output = visible_output[:-output_scroll]
            visible_output = visible_output[-output_area_height:]
            
            for i, line in enumerate(visible_output):
                try:
                    display_line = line[:width - 1]
                    self.editor.stdscr.addstr(term_y + 1 + i, 0, display_line)
                except:
                    pass
            
            # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
            try:
                self.editor.stdscr.addstr(term_y + term_height - 2, 0, "‚îÄ" * width,
                                         Colors.get_pair(Colors.CYAN, -1))
            except:
                pass
            
            # –°—Ç—Ä–æ–∫–∞ –≤–≤–æ–¥–∞
            prompt = f"$ "
            try:
                self.editor.stdscr.addstr(term_y + term_height - 1, 0, prompt,
                                         Colors.get_pair(Colors.GREEN, -1))
                
                # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º–∞—è —á–∞—Å—Ç—å –≤–≤–æ–¥–∞
                input_width = width - len(prompt) - 1
                if len(input_buffer) > input_width:
                    start = max(0, cursor_pos - input_width + 5)
                    display_input = input_buffer[start:start + input_width]
                    display_cursor = cursor_pos - start
                else:
                    display_input = input_buffer
                    display_cursor = cursor_pos
                
                self.editor.stdscr.addstr(term_y + term_height - 1, len(prompt), display_input)
                self.editor.stdscr.move(term_y + term_height - 1, len(prompt) + display_cursor)
            except:
                pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∞
            try:
                hint = " [Enter]–í—ã–ø–æ–ª–Ω–∏—Ç—å [‚Üë‚Üì]–ò—Å—Ç–æ—Ä–∏—è [Esc]–ó–∞–∫—Ä—ã—Ç—å "
                self.editor.stdscr.addstr(term_y + term_height, 0, hint.ljust(width),
                                         Colors.get_pair(Colors.BLACK, Colors.CYAN))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞
            key = self.editor.stdscr.getch()
            
            if key == 27:  # Esc
                self.is_open = False
            elif key in (10, 13, curses.KEY_ENTER):
                if input_buffer.strip():
                    self._execute_command(input_buffer.strip())
                    self.history.append(input_buffer)
                    self.history_index = len(self.history)
                input_buffer = ""
                cursor_pos = 0
            elif key == curses.KEY_UP:
                if self.history and self.history_index > 0:
                    self.history_index -= 1
                    input_buffer = self.history[self.history_index]
                    cursor_pos = len(input_buffer)
            elif key == curses.KEY_DOWN:
                if self.history_index < len(self.history) - 1:
                    self.history_index += 1
                    input_buffer = self.history[self.history_index]
                    cursor_pos = len(input_buffer)
                else:
                    self.history_index = len(self.history)
                    input_buffer = ""
                    cursor_pos = 0
            elif key == curses.KEY_LEFT:
                cursor_pos = max(0, cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                cursor_pos = min(len(input_buffer), cursor_pos + 1)
            elif key == curses.KEY_HOME:
                cursor_pos = 0
            elif key == curses.KEY_END:
                cursor_pos = len(input_buffer)
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if cursor_pos > 0:
                    input_buffer = input_buffer[:cursor_pos-1] + input_buffer[cursor_pos:]
                    cursor_pos -= 1
            elif key == curses.KEY_DC:
                if cursor_pos < len(input_buffer):
                    input_buffer = input_buffer[:cursor_pos] + input_buffer[cursor_pos+1:]
            elif key == curses.KEY_PPAGE:
                output_scroll = min(len(self.output_lines) - output_area_height, 
                                   output_scroll + 5)
            elif key == curses.KEY_NPAGE:
                output_scroll = max(0, output_scroll - 5)
            elif 32 <= key <= 126:
                input_buffer = input_buffer[:cursor_pos] + chr(key) + input_buffer[cursor_pos:]
                cursor_pos += 1
            elif key == 9:  # Tab - –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
                completed = self._autocomplete(input_buffer)
                if completed:
                    input_buffer = completed
                    cursor_pos = len(input_buffer)
        
        curses.curs_set(0)
    
    def _execute_command(self, cmd: str):
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"""
        self.output_lines.append(f"$ {cmd}")
        
        # –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
        if cmd == "clear" or cmd == "cls":
            self.output_lines = []
            return
        elif cmd.startswith("cd "):
            path = cmd[3:].strip()
            try:
                if path == "~":
                    path = os.path.expanduser("~")
                elif path == "-":
                    path = os.environ.get("OLDPWD", self.current_dir)
                
                os.environ["OLDPWD"] = self.current_dir
                os.chdir(path)
                self.current_dir = os.getcwd()
                self.output_lines.append(f"‚Üí {self.current_dir}")
            except Exception as e:
                self.output_lines.append(f"‚ùå {str(e)}")
            return
        elif cmd == "pwd":
            self.output_lines.append(self.current_dir)
            return
        elif cmd == "exit":
            self.is_open = False
            return
        
        # –í–Ω–µ—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                cwd=self.current_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout:
                for line in result.stdout.split('\n'):
                    if line:
                        self.output_lines.append(line)
            
            if result.stderr:
                for line in result.stderr.split('\n'):
                    if line:
                        self.output_lines.append(f"‚ö†Ô∏è {line}")
            
            if result.returncode != 0:
                self.output_lines.append(f"‚Ü©Ô∏è –ö–æ–¥ –≤–æ–∑–≤—Ä–∞—Ç–∞: {result.returncode}")
                
        except subprocess.TimeoutExpired:
            self.output_lines.append("‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è (30—Å)")
        except Exception as e:
            self.output_lines.append(f"‚ùå {str(e)}")
        
        # –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é
        if len(self.output_lines) > 1000:
            self.output_lines = self.output_lines[-500:]
    
    def _autocomplete(self, partial: str) -> Optional[str]:
        """–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥ –∏ –ø—É—Ç–µ–π"""
        if not partial:
            return None
        
        parts = partial.split()
        if not parts:
            return None
        
        last_part = parts[-1]
        
        # –î–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—É—Ç–µ–π
        if '/' in last_part or last_part.startswith('.'):
            dirname = os.path.dirname(last_part) or '.'
            basename = os.path.basename(last_part)
            
            try:
                entries = os.listdir(dirname)
                matches = [e for e in entries if e.startswith(basename)]
                
                if len(matches) == 1:
                    completed = os.path.join(dirname, matches[0])
                    if os.path.isdir(completed):
                        completed += '/'
                    parts[-1] = completed
                    return ' '.join(parts)
            except:
                pass
        
        return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 14: MULTICURSOR - –ú–ù–û–ñ–ï–°–¢–í–ï–ù–ù–´–ï –ö–£–†–°–û–†–´
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MultiCursorPlugin(Plugin):
    """–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫—É—Ä—Å–æ—Ä—ã"""
    
    name = "MultiCursor"
    description = "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–µ—Å—Ç–∞—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.cursors: List[Tuple[int, int]] = []  # [(row, col), ...]
        self.active = False
    
    def add_cursor(self, row: int, col: int):
        """–î–æ–±–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä"""
        pos = (row, col)
        if pos not in self.cursors:
            self.cursors.append(pos)
            self.active = True
    
    def add_cursor_at_next_occurrence(self):
        """–î–æ–±–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Å–ª–æ–≤–∞"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        # –ü–æ–ª—É—á–∏—Ç—å —Å–ª–æ–≤–æ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        # –ù–∞–π—Ç–∏ –≥—Ä–∞–Ω–∏—Ü—ã —Å–ª–æ–≤–∞
        start = col
        while start > 0 and (line[start-1].isalnum() or line[start-1] == '_'):
            start -= 1
        
        end = col
        while end < len(line) and (line[end].isalnum() or line[end] == '_'):
            end += 1
        
        word = line[start:end]
        if not word:
            return
        
        # –î–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –µ—Å–ª–∏ –µ—â—ë –Ω–µ—Ç –∫—É—Ä—Å–æ—Ä–æ–≤
        if not self.cursors:
            self.add_cursor(tab.cursor.row, start)
        
        # –ù–∞–π—Ç–∏ —Å–ª–µ–¥—É—é—â–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
        search_start_row = tab.cursor.row
        search_start_col = end
        
        for row in range(search_start_row, tab.buffer.line_count):
            line = tab.buffer.get_line(row)
            start_col = search_start_col if row == search_start_row else 0
            
            idx = line.find(word, start_col)
            if idx != -1:
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ —Ü–µ–ª–æ–µ —Å–ª–æ–≤–æ
                before_ok = idx == 0 or not (line[idx-1].isalnum() or line[idx-1] == '_')
                after_ok = idx + len(word) >= len(line) or not (line[idx+len(word)].isalnum() or line[idx+len(word)] == '_')
                
                if before_ok and after_ok:
                    pos = (row, idx)
                    if pos not in self.cursors:
                        self.add_cursor(row, idx)
                        tab.cursor.move_to(row, idx + len(word), tab.buffer)
                        return
        
        # –ü–æ–∏—Å–∫ —Å –Ω–∞—á–∞–ª–∞ —Ñ–∞–π–ª–∞
        for row in range(0, search_start_row + 1):
            line = tab.buffer.get_line(row)
            max_col = search_start_col if row == search_start_row else len(line)
            
            idx = 0
            while idx < max_col:
                idx = line.find(word, idx)
                if idx == -1 or idx >= max_col:
                    break
                
                before_ok = idx == 0 or not (line[idx-1].isalnum() or line[idx-1] == '_')
                after_ok = idx + len(word) >= len(line) or not (line[idx+len(word)].isalnum() or line[idx+len(word)] == '_')
                
                if before_ok and after_ok:
                    pos = (row, idx)
                    if pos not in self.cursors:
                        self.add_cursor(row, idx)
                        tab.cursor.move_to(row, idx + len(word), tab.buffer)
                        return
                
                idx += 1
    
    def add_cursor_above(self):
        """–î–æ–±–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä –Ω–∞ —Å—Ç—Ä–æ–∫—É –≤—ã—à–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        if not self.cursors:
            self.add_cursor(tab.cursor.row, tab.cursor.col)
        
        # –ù–∞–π—Ç–∏ —Å–∞–º—ã–π –≤–µ—Ä—Ö–Ω–∏–π –∫—É—Ä—Å–æ—Ä
        top_cursor = min(self.cursors, key=lambda c: c[0])
        
        if top_cursor[0] > 0:
            new_row = top_cursor[0] - 1
            new_col = min(top_cursor[1], len(tab.buffer.get_line(new_row)))
            self.add_cursor(new_row, new_col)
    
    def add_cursor_below(self):
        """–î–æ–±–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä –Ω–∞ —Å—Ç—Ä–æ–∫—É –Ω–∏–∂–µ"""
        tab = self.editor.tab_manager.active_tab
        if not tab:
            return
        
        if not self.cursors:
            self.add_cursor(tab.cursor.row, tab.cursor.col)
        
        # –ù–∞–π—Ç–∏ —Å–∞–º—ã–π –Ω–∏–∂–Ω–∏–π –∫—É—Ä—Å–æ—Ä
        bottom_cursor = max(self.cursors, key=lambda c: c[0])
        
        if bottom_cursor[0] < tab.buffer.line_count - 1:
            new_row = bottom_cursor[0] + 1
            new_col = min(bottom_cursor[1], len(tab.buffer.get_line(new_row)))
            self.add_cursor(new_row, new_col)
    
    def clear_cursors(self):
        """–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫—É—Ä—Å–æ—Ä—ã"""
        self.cursors = []
        self.active = False
    
    def type_at_all(self, char: str):
        """–í–≤–µ—Å—Ç–∏ —Å–∏–º–≤–æ–ª –≤–æ –≤—Å–µ—Ö –∫—É—Ä—Å–æ—Ä–∞—Ö"""
        tab = self.editor.tab_manager.active_tab
        if not tab or not self.cursors:
            return
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫—É—Ä—Å–æ—Ä—ã —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö, —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ
        sorted_cursors = sorted(self.cursors, key=lambda c: (-c[0], -c[1]))
        
        # –û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏
        new_cursors = []
        for row, col in sorted_cursors:
            tab.buffer.insert_char(row, col, char)
            new_cursors.append((row, col + 1))
        
        self.cursors = new_cursors
    
    def delete_at_all(self):
        """–£–¥–∞–ª–∏—Ç—å —Å–∏–º–≤–æ–ª –≤–æ –≤—Å–µ—Ö –∫—É—Ä—Å–æ—Ä–∞—Ö"""
        tab = self.editor.tab_manager.active_tab
        if not tab or not self.cursors:
            return
        
        sorted_cursors = sorted(self.cursors, key=lambda c: (-c[0], -c[1]))
        
        new_cursors = []
        for row, col in sorted_cursors:
            if col > 0:
                tab.buffer.delete_char(row, col)
                new_cursors.append((row, col - 1))
            else:
                new_cursors.append((row, col))
        
        self.cursors = new_cursors
    
    def get_cursors(self) -> List[Tuple[int, int]]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫—É—Ä—Å–æ—Ä—ã"""
        return self.cursors.copy()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 15: MINIMAP - –ú–ò–ù–ò-–ö–ê–†–¢–ê –ö–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MinimapPlugin(Plugin):
    """–ú–∏–Ω–∏-–∫–∞—Ä—Ç–∞ –∫–æ–¥–∞ —Å–ø—Ä–∞–≤–∞"""
    
    name = "Minimap"
    description = "–ú–∏–Ω–∏–∞—Ç—é—Ä–Ω—ã–π –æ–±–∑–æ—Ä –≤—Å–µ–≥–æ —Ñ–∞–π–ª–∞"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.visible = False
        self.width = 20
    
    def toggle(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –º–∏–Ω–∏–∫–∞—Ä—Ç—É"""
        self.visible = not self.visible
    
    def draw(self, stdscr, x: int, y: int, height: int, tab: Tab, highlighter: SyntaxHighlighter):
        """–û—Ç—Ä–∏—Å–æ–≤–∞—Ç—å –º–∏–Ω–∏–∫–∞—Ä—Ç—É"""
        if not self.visible or not tab:
            return
        
        # –ú–∞—Å—à—Ç–∞–±: —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞ –Ω–∞ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É –º–∏–Ω–∏–∫–∞—Ä—Ç—ã
        total_lines = tab.buffer.line_count
        scale = max(1, total_lines // height)
        
        # –¶–≤–µ—Ç —Ñ–æ–Ω–∞
        bg_color = Colors.get_pair(Colors.WHITE, Colors.BLUE)
        
        # –û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏
        visible_start = tab.scroll_row
        visible_end = min(tab.scroll_row + height, total_lines)
        
        for i in range(height):
            source_line = i * scale
            if source_line >= total_lines:
                break
            
            line = tab.buffer.get_line(source_line)
            
            # –°–∂–∞—Ç—å —Å—Ç—Ä–æ–∫—É
            compressed = ""
            for j in range(0, min(len(line), self.width * 2), 2):
                if j < len(line):
                    c = line[j]
                    if c.isalnum():
                        compressed += "‚ñà"
                    elif c in ' \t':
                        compressed += " "
                    else:
                        compressed += "‚ñ™"
                else:
                    compressed += " "
            
            compressed = compressed[:self.width]
            
            # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–∏–¥–∏–º–æ–π –æ–±–ª–∞—Å—Ç–∏
            if visible_start <= source_line < visible_end:
                attr = Colors.get_pair(Colors.BLACK, Colors.CYAN)
            else:
                attr = Colors.get_pair(Colors.CYAN, -1) | curses.A_DIM
            
            try:
                stdscr.addstr(y + i, x, compressed.ljust(self.width), attr)
            except:
                pass
        
        # –†–∞–º–∫–∞
        try:
            for i in range(height):
                stdscr.addstr(y + i, x - 1, "‚îÇ", Colors.get_pair(Colors.CYAN, -1))
        except:
            pass


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 16: BRACKETS - –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ï –°–ö–û–ë–ö–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class BracketsPlugin(Plugin):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏"""
    
    name = "Brackets"
    description = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Å–∫–æ–±–æ–∫ –∏ –∫–∞–≤—ã—á–µ–∫"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.enabled = settings.get("auto_pairs", True)
        self.pairs = {
            '(': ')',
            '[': ']',
            '{': '}',
            '"': '"',
            "'": "'",
            '`': '`',
        }
    
    def handle_char(self, char: str, tab: Tab) -> Optional[str]:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–≤–æ–¥ —Å–∏–º–≤–æ–ª–∞. –í–µ—Ä–Ω—É—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–º–≤–æ–ª –µ—Å–ª–∏ –Ω—É–∂–Ω–æ"""
        if not self.enabled:
            return None
        
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        # –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
        if char in self.pairs:
            closing = self.pairs[char]
            
            # –î–ª—è –∫–∞–≤—ã—á–µ–∫ - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
            if char in '"\'`':
                # –ï—Å–ª–∏ —É–∂–µ –≤–Ω—É—Ç—Ä–∏ —Å—Ç—Ä–æ–∫–∏ —Ç–æ–≥–æ –∂–µ —Ç–∏–ø–∞ - –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å
                before = line[:col]
                if before.count(char) % 2 == 1:
                    return None
            
            return closing
        
        # –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞ - –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å
        if char in self.pairs.values():
            if col < len(line) and line[col] == char:
                # –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å –∫—É—Ä—Å–æ—Ä
                return "SKIP"
        
        return None
    
    def handle_backspace(self, tab: Tab) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å backspace. –í–µ—Ä–Ω—É—Ç—å True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–∞ –ø–∞—Ä–∞"""
        if not self.enabled:
            return False
        
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        if col > 0 and col < len(line):
            prev_char = line[col - 1]
            next_char = line[col]
            
            if prev_char in self.pairs and self.pairs[prev_char] == next_char:
                # –£–¥–∞–ª–∏—Ç—å –æ–±–∞ —Å–∏–º–≤–æ–ª–∞
                new_line = line[:col-1] + line[col+1:]
                tab.buffer.set_line(tab.cursor.row, new_line)
                tab.cursor.col -= 1
                return True
        
        return False
    
    def find_matching_bracket(self, tab: Tab) -> Optional[Tuple[int, int]]:
        """–ù–∞–π—Ç–∏ –ø–∞—Ä–Ω—É—é —Å–∫–æ–±–∫—É"""
        line = tab.buffer.get_line(tab.cursor.row)
        col = tab.cursor.col
        
        if col >= len(line):
            return None
        
        char = line[col]
        
        opening = '([{'
        closing = ')]}'
        
        if char in opening:
            # –ò—â–µ–º –≤–ø–µ—Ä—ë–¥
            idx = opening.index(char)
            target = closing[idx]
            depth = 1
            
            for row in range(tab.cursor.row, tab.buffer.line_count):
                start_col = col + 1 if row == tab.cursor.row else 0
                search_line = tab.buffer.get_line(row)
                
                for c in range(start_col, len(search_line)):
                    if search_line[c] == char:
                        depth += 1
                    elif search_line[c] == target:
                        depth -= 1
                        if depth == 0:
                            return (row, c)
        
        elif char in closing:
            # –ò—â–µ–º –Ω–∞–∑–∞–¥
            idx = closing.index(char)
            target = opening[idx]
            depth = 1
            
            for row in range(tab.cursor.row, -1, -1):
                end_col = col - 1 if row == tab.cursor.row else len(tab.buffer.get_line(row)) - 1
                search_line = tab.buffer.get_line(row)
                
                for c in range(end_col, -1, -1):
                    if search_line[c] == char:
                        depth += 1
                    elif search_line[c] == target:
                        depth -= 1
                        if depth == 0:
                            return (row, c)
        
        return None


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 17: INDENT - –£–ú–ù–´–ï –û–¢–°–¢–£–ü–´
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class IndentPlugin(Plugin):
    """–£–º–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã"""
    
    name = "Indent"
    description = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ—Ç—Å—Ç—É–ø—ã"
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.use_spaces = settings.get("use_spaces", True)
        self.tab_size = settings.get("tab_size", 4)
    
    def get_indent_string(self) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É –æ—Ç—Å—Ç—É–ø–∞"""
        if self.use_spaces:
            return " " * self.tab_size
        return "\t"
    
    def get_line_indent(self, line: str) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –æ—Ç—Å—Ç—É–ø–∞ —Å—Ç—Ä–æ–∫–∏"""
        indent = len(line) - len(line.lstrip())
        if self.use_spaces:
            return indent // self.tab_size
        return indent
    
    def calculate_indent(self, tab: Tab, row: int) -> str:
        """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ—Ç—Å—Ç—É–ø –¥–ª—è –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏"""
        if row == 0:
            return ""
        
        prev_line = tab.buffer.get_line(row - 1)
        prev_indent = len(prev_line) - len(prev_line.lstrip())
        prev_stripped = prev_line.rstrip()
        
        language = tab.buffer.language
        
        # –£–≤–µ–ª–∏—á–∏—Ç—å –æ—Ç—Å—Ç—É–ø –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤/—Å–ª–æ–≤
        increase_indent = False
        
        if language == "python":
            if prev_stripped.endswith(':'):
                increase_indent = True
        elif language in ["javascript", "typescript", "java", "c", "cpp", "csharp", "go", "rust"]:
            if prev_stripped.endswith('{') or prev_stripped.endswith('('):
                increase_indent = True
        elif language in ["html", "xml"]:
            # –ü–æ—Å–ª–µ –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–≥–æ —Ç–µ–≥–∞
            if prev_stripped.endswith('>') and not prev_stripped.endswith('/>') and not prev_stripped.startswith('</'):
                increase_indent = True
        
        if increase_indent:
            return " " * (prev_indent + self.tab_size)
        
        return " " * prev_indent
    
    def indent_line(self, tab: Tab, row: int):
        """–î–æ–±–∞–≤–∏—Ç—å –æ—Ç—Å—Ç—É–ø –∫ —Å—Ç—Ä–æ–∫–µ"""
        line = tab.buffer.get_line(row)
        indent_str = self.get_indent_string()
        tab.buffer.set_line(row, indent_str + line)
        tab.cursor.col += len(indent_str)
    
    def unindent_line(self, tab: Tab, row: int):
        """–£–±—Ä–∞—Ç—å –æ—Ç—Å—Ç—É–ø –∏–∑ —Å—Ç—Ä–æ–∫–∏"""
        line = tab.buffer.get_line(row)
        
        if self.use_spaces:
            if line.startswith(" " * self.tab_size):
                tab.buffer.set_line(row, line[self.tab_size:])
                tab.cursor.col = max(0, tab.cursor.col - self.tab_size)
        else:
            if line.startswith("\t"):
                tab.buffer.set_line(row, line[1:])
                tab.cursor.col = max(0, tab.cursor.col - 1)
    
    def indent_selection(self, tab: Tab, start_row: int, end_row: int):
        """–î–æ–±–∞–≤–∏—Ç—å –æ—Ç—Å—Ç—É–ø –∫ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–º —Å—Ç—Ä–æ–∫–∞–º"""
        for row in range(start_row, end_row + 1):
            line = tab.buffer.get_line(row)
            tab.buffer.set_line(row, self.get_indent_string() + line)
    
    def unindent_selection(self, tab: Tab, start_row: int, end_row: int):
        """–£–±—Ä–∞—Ç—å –æ—Ç—Å—Ç—É–ø –∏–∑ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫"""
        for row in range(start_row, end_row + 1):
            line = tab.buffer.get_line(row)
            if self.use_spaces:
                if line.startswith(" " * self.tab_size):
                    tab.buffer.set_line(row, line[self.tab_size:])
            else:
                if line.startswith("\t"):
                    tab.buffer.set_line(row, line[1:])


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 18: APK BUILDER - –°–ë–û–†–ö–ê APK –ù–ê –£–î–ê–õ–Å–ù–ù–´–• –°–ï–†–í–ï–†–ê–•
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class APKBuilderPlugin(Plugin):
    """–°–±–æ—Ä–∫–∞ APK –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–∞—Ö"""
    
    name = "APKBuilder"
    description = "–°–±–æ—Ä–∫–∞ Android APK —á–µ—Ä–µ–∑ –æ–±–ª–∞—á–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã"
    
    SERVERS = {
        "colab": {
            "name": "Google Colab",
            "icon": "üü¢",
            "description": "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ –Ω–∞–≤—Å–µ–≥–¥–∞, 12 –ì–ë RAM",
            "type": "colab"
        },
        "oracle": {
            "name": "Oracle Cloud Free",
            "icon": "üî¥",
            "description": "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ, 24 –ì–ë RAM ARM",
            "type": "ssh"
        },
        "github": {
            "name": "GitHub Actions",
            "icon": "‚ö´",
            "description": "2000 –º–∏–Ω/–º–µ—Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ",
            "type": "github"
        },
        "custom": {
            "name": "–°–≤–æ–π —Å–µ—Ä–≤–µ—Ä (SSH)",
            "icon": "üî∑",
            "description": "–õ—é–±–æ–π VPS —Å SSH –¥–æ—Å—Ç—É–ø–æ–º",
            "type": "ssh"
        }
    }
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.config_file = os.path.join(CONFIG_DIR, "apk_builder.json")
        self.config = self._load_config()
        self.build_log: List[str] = []
        self.is_building = False
    
    def _load_config(self) -> Dict:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    return json.load(f)
        except:
            pass
        return {}
    
    def _save_config(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except:
            pass
    
    def show_build_menu(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é —Å–±–æ—Ä–∫–∏ APK"""
        height, width = self.editor.stdscr.getmaxyx()
        
        dialog_height = 20
        dialog_width = min(70, width - 4)
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        selected = 0
        servers = list(self.SERVERS.keys())
        
        while True:
            # –û—á–∏—Å—Ç–∏—Ç—å
            for i in range(dialog_height):
                try:
                    self.editor.stdscr.addstr(y + i, x, " " * dialog_width)
                except:
                    pass
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            Dialog.draw_box(self.editor.stdscr, y, x, dialog_height, dialog_width,
                           "üì¶ –°–±–æ—Ä–∫–∞ APK", Colors.get_pair(Colors.MAGENTA, -1))
            
            # –û–ø–∏—Å–∞–Ω–∏–µ
            try:
                self.editor.stdscr.addstr(y + 2, x + 2, 
                    "–°–æ–±–µ—Ä–∏—Ç–µ APK –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ –∑–∞ 5-20 –º–∏–Ω—É—Ç!",
                    Colors.get_pair(Colors.CYAN, -1))
                self.editor.stdscr.addstr(y + 3, x + 2,
                    "–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–±–æ—Ä–∫–∏:",
                    Colors.get_pair(Colors.WHITE, -1))
            except:
                pass
            
            # –°–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤
            for i, server_id in enumerate(servers):
                server = self.SERVERS[server_id]
                
                if i == selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.WHITE)
                    prefix = "‚ñ∂ "
                else:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                    prefix = "  "
                
                line = f"{prefix}{server['icon']} {server['name']}"
                desc = f"     {server['description']}"
                
                try:
                    self.editor.stdscr.addstr(y + 5 + i * 2, x + 2, 
                                             line[:dialog_width - 4], attr)
                    self.editor.stdscr.addstr(y + 6 + i * 2, x + 2,
                                             desc[:dialog_width - 4],
                                             Colors.get_pair(Colors.CYAN, -1) | curses.A_DIM)
                except:
                    pass
            
            # –ö–Ω–æ–ø–∫–∏
            btn_y = y + dialog_height - 3
            try:
                self.editor.stdscr.addstr(btn_y, x + 2,
                    "[Enter] –í—ã–±—Ä–∞—Ç—å  [Esc] –û—Ç–º–µ–Ω–∞",
                    Colors.get_pair(Colors.YELLOW, -1))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key == 27:
                return
            elif key in (10, 13, curses.KEY_ENTER):
                server_id = servers[selected]
                self._configure_server(server_id)
                return
            elif key in (curses.KEY_UP, ord('k')):
                selected = (selected - 1) % len(servers)
            elif key in (curses.KEY_DOWN, ord('j')):
                selected = (selected + 1) % len(servers)
    
    def _configure_server(self, server_id: str):
        """–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä"""
        server = self.SERVERS[server_id]
        
        if server["type"] == "colab":
            self._setup_colab()
        elif server["type"] == "ssh":
            self._setup_ssh(server_id)
        elif server["type"] == "github":
            self._setup_github()
    
    def _setup_colab(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Google Colab"""
        height, width = self.editor.stdscr.getmaxyx()
        
        message = """
Google Colab - —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–±!

1. –ù–∞–∂–º–∏—Ç–µ "–û—Ç–∫—Ä—ã—Ç—å –≤ Colab"
2. –í–æ–π–¥–∏—Ç–µ –≤ Google –∞–∫–∫–∞—É–Ω—Ç
3. –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ"
4. –°–∫–∞—á–∞–π—Ç–µ –≥–æ—Ç–æ–≤—ã–π APK

–í–∞—à –ø—Ä–æ–µ–∫—Ç –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω.
        """
        
        dialog_height = 15
        dialog_width = 60
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        for i in range(dialog_height):
            try:
                self.editor.stdscr.addstr(y + i, x, " " * dialog_width)
            except:
                pass
        
        Dialog.draw_box(self.editor.stdscr, y, x, dialog_height, dialog_width,
                       "üü¢ Google Colab", Colors.get_pair(Colors.GREEN, -1))
        
        for i, line in enumerate(message.strip().split('\n')):
            try:
                self.editor.stdscr.addstr(y + 2 + i, x + 2, line[:dialog_width - 4])
            except:
                pass
        
        try:
            self.editor.stdscr.addstr(y + dialog_height - 2, x + 2,
                "[Enter] –û—Ç–∫—Ä—ã—Ç—å –≤ Colab  [Esc] –ù–∞–∑–∞–¥",
                Colors.get_pair(Colors.YELLOW, -1))
        except:
            pass
        
        self.editor.stdscr.refresh()
        
        while True:
            key = self.editor.stdscr.getch()
            if key == 27:
                return
            elif key in (10, 13):
                self._open_colab()
                return
    
    def _open_colab(self):
        """–û—Ç–∫—Ä—ã—Ç—å Google Colab —Å –ø—Ä–æ–µ–∫—Ç–æ–º"""
        # –°–æ–∑–¥–∞—Ç—å ZIP –ø—Ä–æ–µ–∫—Ç–∞
        tab = self.editor.tab_manager.active_tab
        if not tab or not tab.buffer.filename:
            MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞",
                         "–°–Ω–∞—á–∞–ª–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç", "error").show()
            return
        
        project_dir = os.path.dirname(tab.buffer.filename)
        
        # –°—Å—ã–ª–∫–∞ –Ω–∞ —à–∞–±–ª–æ–Ω Colab
        colab_url = "https://colab.research.google.com/github/nickolasburr/buildozer-action/blob/main/notebook.ipynb"
        
        try:
            if Platform.IS_TERMUX:
                subprocess.run(['termux-open-url', colab_url])
            else:
                import webbrowser
                webbrowser.open(colab_url)
            
            MessageDialog(self.editor.stdscr, "Colab",
                         "Colab –æ—Ç–∫—Ä—ã—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–µ!\n–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç –≤—Ä—É—á–Ω—É—é.",
                         "success").show()
        except Exception as e:
            MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞",
                         str(e), "error").show()
    
    def _setup_ssh(self, server_id: str):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ SSH —Å–µ—Ä–≤–µ—Ä–∞"""
        height, width = self.editor.stdscr.getmaxyx()
        
        # –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ
        host = InputDialog(self.editor.stdscr, "SSH –°–µ—Ä–≤–µ—Ä",
                          "–•–æ—Å—Ç (user@ip):", 
                          self.config.get(f"{server_id}_host", "")).show()
        if not host:
            return
        
        port = InputDialog(self.editor.stdscr, "SSH –ü–æ—Ä—Ç",
                          "–ü–æ—Ä—Ç:", 
                          self.config.get(f"{server_id}_port", "22")).show()
        if not port:
            return
        
        # –ú–µ—Ç–æ–¥ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        auth_items = ["üîë SSH –∫–ª—é—á (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)", "üîí –ü–∞—Ä–æ–ª—å"]
        auth_dialog = ListDialog(self.editor.stdscr, "–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è", auth_items)
        auth_choice = auth_dialog.show()
        
        if auth_choice is None:
            return
        
        if auth_choice == 0:
            key_path = InputDialog(self.editor.stdscr, "SSH –ö–ª—é—á",
                                  "–ü—É—Ç—å –∫ –ø—Ä–∏–≤–∞—Ç–Ω–æ–º—É –∫–ª—é—á—É:",
                                  os.path.expanduser("~/.ssh/id_rsa")).show()
            if not key_path:
                return
            self.config[f"{server_id}_key"] = key_path
        else:
            password = InputDialog(self.editor.stdscr, "–ü–∞—Ä–æ–ª—å",
                                  "–ü–∞—Ä–æ–ª—å SSH:", "", password=True).show()
            if password:
                # –ù–ï —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–æ–ª—å –≤ –∫–æ–Ω—Ñ–∏–≥ (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
                self.config[f"{server_id}_use_password"] = True
        
        self.config[f"{server_id}_host"] = host
        self.config[f"{server_id}_port"] = port
        self._save_config()
        
        # –¢–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        if self._test_ssh_connection(server_id):
            MessageDialog(self.editor.stdscr, "SSH",
                         "‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!", "success").show()
        else:
            MessageDialog(self.editor.stdscr, "SSH",
                         "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è", "error").show()
    
    def _test_ssh_connection(self, server_id: str) -> bool:
        """–¢–µ—Å—Ç SSH —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        try:
            import paramiko
        except ImportError:
            MessageDialog(self.editor.stdscr, "–û—à–∏–±–∫–∞",
                         "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ paramiko: pip install paramiko",
                         "error").show()
            return False
        
        try:
            host_str = self.config.get(f"{server_id}_host", "")
            if '@' in host_str:
                username, hostname = host_str.split('@', 1)
            else:
                hostname = host_str
                username = os.environ.get('USER', 'root')
            
            port = int(self.config.get(f"{server_id}_port", 22))
            key_path = self.config.get(f"{server_id}_key")
            
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            if key_path and os.path.exists(key_path):
                client.connect(hostname, port=port, username=username,
                              key_filename=key_path, timeout=10)
            else:
                return False
            
            client.close()
            return True
            
        except Exception as e:
            return False
    
    def _setup_github(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ GitHub Actions"""
        token = InputDialog(self.editor.stdscr, "GitHub Actions",
                           "GitHub Personal Access Token:",
                           self.config.get("github_token", ""),
                           password=True).show()
        
        if token:
            self.config["github_token"] = token
            self._save_config()
            MessageDialog(self.editor.stdscr, "GitHub",
                         "‚úÖ –¢–æ–∫–µ–Ω —Å–æ—Ö—Ä–∞–Ω—ë–Ω!", "success").show()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 19: AI ASSISTANT - –£–ú–ù–´–ô AI –ü–û–ú–û–©–ù–ò–ö –° –ö–†–ê–°–ò–í–´–ú –ò–ù–¢–ï–†–§–ï–ô–°–û–ú
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AIAssistantPlugin(Plugin):
    """AI –ø–æ–º–æ—â–Ω–∏–∫ —Å –∫—Ä–∞—Å–∏–≤—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
    
    name = "AIAssistant"
    description = "AI –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞"
    
    PROVIDERS = {
        "openai": {
            "name": "OpenAI",
            "icon": "üü¢",
            "models": ["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"],
            "key_prefix": "sk-",
            "api_url": "https://api.openai.com/v1/chat/completions"
        },
        "anthropic": {
            "name": "Anthropic Claude",
            "icon": "üü£",
            "models": ["claude-3-opus", "claude-3-sonnet", "claude-3-haiku"],
            "key_prefix": "sk-ant-",
            "api_url": "https://api.anthropic.com/v1/messages"
        },
        "google": {
            "name": "Google Gemini",
            "icon": "üîµ",
            "models": ["gemini-pro", "gemini-1.5-pro", "gemini-1.5-flash"],
            "key_prefix": "AI",
            "api_url": "https://generativelanguage.googleapis.com/v1/models"
        },
        "groq": {
            "name": "Groq (–ë—ã—Å—Ç—Ä—ã–π)",
            "icon": "üü†",
            "models": ["llama3-70b", "llama3-8b", "mixtral-8x7b", "gemma-7b"],
            "key_prefix": "gsk_",
            "api_url": "https://api.groq.com/openai/v1/chat/completions"
        },
        "deepseek": {
            "name": "DeepSeek",
            "icon": "üî∑",
            "models": ["deepseek-coder", "deepseek-chat"],
            "key_prefix": "sk-",
            "api_url": "https://api.deepseek.com/v1/chat/completions"
        },
        "local": {
            "name": "–õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å (Ollama)",
            "icon": "‚ö´",
            "models": ["llama3", "codellama", "mistral", "phi3"],
            "key_prefix": "",
            "api_url": "http://localhost:11434/api/generate"
        }
    }
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
        self.config_file = AI_CONFIG_FILE
        self.config = self._load_config()
        self.chat_history: List[Dict] = []
        self.stars: List[Dict] = []  # –î–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∑–≤—ë–∑–¥
        self._init_stars()
    
    def _init_stars(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤—ë–∑–¥ –¥–ª—è —Ñ–æ–Ω–∞"""
        import random
        self.stars = []
        for _ in range(50):
            self.stars.append({
                'x': random.randint(0, 100),
                'y': random.randint(0, 40),
                'char': random.choice(['¬∑', '‚ú¶', '‚úß', '‚òÖ', '‚òÜ', '‚ú∂', '‚ú¥', '‚úµ']),
                'brightness': random.choice([0, 1, 2])
            })
    
    def _load_config(self) -> Dict:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é AI"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    # –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ (–ø—Ä–æ—Å—Ç–∞—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏—è)
                    data = json.load(f)
                    if 'api_key' in data:
                        data['api_key'] = self._decode_key(data['api_key'])
                    return data
        except:
            pass
        return {}
    
    def _save_config(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é AI"""
        try:
            data = self.config.copy()
            if 'api_key' in data:
                data['api_key'] = self._encode_key(data['api_key'])
            with open(self.config_file, 'w') as f:
                json.dump(data, f, indent=2)
            os.chmod(self.config_file, 0o600)  # –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü
        except:
            pass
    
    def _encode_key(self, key: str) -> str:
        """–ü—Ä–æ—Å—Ç–∞—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏—è –∫–ª—é—á–∞"""
        return base64.b64encode(key.encode()).decode()
    
    def _decode_key(self, encoded: str) -> str:
        """–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–∞"""
        try:
            return base64.b64decode(encoded.encode()).decode()
        except:
            return encoded
    
    def is_configured(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω –ª–∏ AI"""
        return bool(self.config.get('provider') and self.config.get('api_key'))
    
    def show_setup_wizard(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∫—Ä–∞—Å–∏–≤—ã–π –º–∞—Å—Ç–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ AI —Å–æ –∑–≤—ë–∑–¥–Ω—ã–º —Ñ–æ–Ω–æ–º"""
        height, width = self.editor.stdscr.getmaxyx()
        
        curses.curs_set(0)
        
        # –§–∞–∑–∞ 1: –í—ã–±–æ—Ä –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        provider = self._show_provider_selection(height, width)
        if not provider:
            return
        
        # –§–∞–∑–∞ 2: –í–≤–æ–¥ API –∫–ª—é—á–∞
        api_key = self._show_key_input(height, width, provider)
        if not api_key:
            return
        
        # –§–∞–∑–∞ 3: –í—ã–±–æ—Ä –º–æ–¥–µ–ª–∏
        model = self._show_model_selection(height, width, provider)
        if not model:
            return
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
        self.config['provider'] = provider
        self.config['api_key'] = api_key
        self.config['model'] = model
        self._save_config()
        
        # –ü–æ–∫–∞–∑–∞—Ç—å —É—Å–ø–µ—Ö
        self._show_success_screen(height, width)
    
    def _draw_starfield(self, height: int, width: int):
        """–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∑–≤—ë–∑–¥–Ω–æ–µ –Ω–µ–±–æ"""
        # –ì—Ä–∞–¥–∏–µ–Ω—Ç —Ñ–æ–Ω–∞ (—Ç—ë–º–Ω–æ-—Å–∏–Ω–∏–π/—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π)
        for y in range(height):
            for x in range(width):
                try:
                    # –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç —Ç—ë–º–Ω–æ-—Å–∏–Ω–µ–≥–æ –∫ —Ñ–∏–æ–ª–µ—Ç–æ–≤–æ–º—É
                    if y < height // 3:
                        color = Colors.get_pair(Colors.BLUE, -1) | curses.A_DIM
                    elif y < 2 * height // 3:
                        color = Colors.get_pair(Colors.MAGENTA, -1) | curses.A_DIM
                    else:
                        color = Colors.get_pair(Colors.BLUE, -1) | curses.A_DIM
                    
                    self.editor.stdscr.addch(y, x, ' ', color)
                except:
                    pass
        
        # –ó–≤—ë–∑–¥—ã
        for star in self.stars:
            sx = int(star['x'] * width / 100)
            sy = int(star['y'] * height / 40)
            
            if 0 <= sx < width and 0 <= sy < height:
                if star['brightness'] == 0:
                    attr = Colors.get_pair(Colors.WHITE, -1) | curses.A_DIM
                elif star['brightness'] == 1:
                    attr = Colors.get_pair(Colors.WHITE, -1)
                else:
                    attr = Colors.get_pair(Colors.YELLOW, -1) | curses.A_BOLD
                
                try:
                    self.editor.stdscr.addstr(sy, sx, star['char'], attr)
                except:
                    pass
    
    def _draw_card(self, y: int, x: int, card_height: int, card_width: int, title: str):
        """–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∫—Ä–∞—Å–∏–≤—É—é –∫–∞—Ä—Ç–æ—á–∫—É"""
        # –§–æ–Ω –∫–∞—Ä—Ç–æ—á–∫–∏
        card_bg = Colors.get_pair(Colors.WHITE, Colors.BLUE)
        border_color = Colors.get_pair(Colors.CYAN, -1)
        title_color = Colors.get_pair(Colors.YELLOW, Colors.BLUE) | curses.A_BOLD
        
        # –¢–µ–Ω—å
        for i in range(card_height):
            try:
                self.editor.stdscr.addstr(y + i + 1, x + 2, " " * card_width,
                                         Colors.get_pair(Colors.BLACK, -1) | curses.A_DIM)
            except:
                pass
        
        # –û—Å–Ω–æ–≤–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞
        for i in range(card_height):
            try:
                self.editor.stdscr.addstr(y + i, x, " " * card_width, card_bg)
            except:
                pass
        
        # –†–∞–º–∫–∞
        try:
            # –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
            self.editor.stdscr.addstr(y, x, "‚ïî" + "‚ïê" * (card_width - 2) + "‚ïó", border_color)
            # –ë–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
            for i in range(1, card_height - 1):
                self.editor.stdscr.addstr(y + i, x, "‚ïë", border_color)
                self.editor.stdscr.addstr(y + i, x + card_width - 1, "‚ïë", border_color)
            # –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
            self.editor.stdscr.addstr(y + card_height - 1, x, 
                                     "‚ïö" + "‚ïê" * (card_width - 2) + "‚ïù", border_color)
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            title_x = x + (card_width - len(title)) // 2
            self.editor.stdscr.addstr(y + 1, title_x, title, title_color)
            
            # –õ–∏–Ω–∏—è –ø–æ–¥ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
            self.editor.stdscr.addstr(y + 2, x + 1, "‚îÄ" * (card_width - 2),
                                     Colors.get_pair(Colors.CYAN, Colors.BLUE))
        except:
            pass
    
    def _show_provider_selection(self, height: int, width: int) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±–æ—Ä –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ AI"""
        providers = list(self.PROVIDERS.keys())
        selected = 0
        
        card_width = min(60, width - 10)
        card_height = len(providers) * 2 + 8
        card_y = (height - card_height) // 2
        card_x = (width - card_width) // 2
        
        while True:
            # –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
            self._draw_starfield(height, width)
            
            # –ö–∞—Ä—Ç–æ—á–∫–∞
            self._draw_card(card_y, card_x, card_height, card_width,
                           "ü§ñ –ù–ê–°–¢–†–û–ô–ö–ê AI –ü–û–ú–û–©–ù–ò–ö–ê")
            
            # –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫
            try:
                subtitle = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ AI:"
                self.editor.stdscr.addstr(card_y + 4, card_x + (card_width - len(subtitle)) // 2,
                                         subtitle, Colors.get_pair(Colors.WHITE, Colors.BLUE))
            except:
                pass
            
            # –°–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
            for i, provider_id in enumerate(providers):
                provider = self.PROVIDERS[provider_id]
                
                py = card_y + 6 + i * 2
                
                if i == selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.YELLOW) | curses.A_BOLD
                    prefix = " ‚ñ∂ "
                else:
                    attr = Colors.get_pair(Colors.WHITE, Colors.BLUE)
                    prefix = "   "
                
                line = f"{prefix}{provider['icon']} {provider['name']}"
                
                try:
                    self.editor.stdscr.addstr(py, card_x + 3, line.ljust(card_width - 6), attr)
                except:
                    pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∏
            hint_y = card_y + card_height - 2
            try:
                hint = " [‚Üë‚Üì] –í—ã–±–æ—Ä  [Enter] –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å  [Esc] –û—Ç–º–µ–Ω–∞ "
                hint_x = card_x + (card_width - len(hint)) // 2
                self.editor.stdscr.addstr(hint_y, hint_x, hint,
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key == 27:
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                return providers[selected]
            elif key in (curses.KEY_UP, ord('k')):
                selected = (selected - 1) % len(providers)
            elif key in (curses.KEY_DOWN, ord('j')):
                selected = (selected + 1) % len(providers)
    
    def _show_key_input(self, height: int, width: int, provider: str) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –≤–≤–æ–¥ API –∫–ª—é—á–∞"""
        provider_info = self.PROVIDERS[provider]
        
        card_width = min(65, width - 10)
        card_height = 14
        card_y = (height - card_height) // 2
        card_x = (width - card_width) // 2
        
        api_key = ""
        cursor_pos = 0
        show_key = False
        
        curses.curs_set(1)
        
        while True:
            # –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
            self._draw_starfield(height, width)
            
            # –ö–∞—Ä—Ç–æ—á–∫–∞
            self._draw_card(card_y, card_x, card_height, card_width,
                           f"üîë API –ö–õ–Æ–ß {provider_info['name'].upper()}")
            
            # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
            try:
                info_lines = [
                    f"–í–≤–µ–¥–∏—Ç–µ –≤–∞—à API –∫–ª—é—á –¥–ª—è {provider_info['name']}",
                    f"–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å: {provider_info['key_prefix']}...",
                    "",
                    "–ü–æ–ª—É—á–∏—Ç—å –∫–ª—é—á –º–æ–∂–Ω–æ –Ω–∞ —Å–∞–π—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞."
                ]
                
                for i, line in enumerate(info_lines):
                    self.editor.stdscr.addstr(card_y + 4 + i, card_x + 3, line[:card_width - 6],
                                             Colors.get_pair(Colors.WHITE, Colors.BLUE))
            except:
                pass
            
            # –ü–æ–ª–µ –≤–≤–æ–¥–∞
            input_y = card_y + 9
            input_width = card_width - 10
            
            try:
                # –†–∞–º–∫–∞ –ø–æ–ª—è
                self.editor.stdscr.addstr(input_y, card_x + 4, "‚îå" + "‚îÄ" * input_width + "‚îê",
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                self.editor.stdscr.addstr(input_y + 1, card_x + 4, "‚îÇ" + " " * input_width + "‚îÇ",
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                self.editor.stdscr.addstr(input_y + 2, card_x + 4, "‚îî" + "‚îÄ" * input_width + "‚îò",
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                
                # –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–æ–ª—è
                if show_key:
                    display_key = api_key
                else:
                    display_key = "*" * len(api_key)
                
                if len(display_key) > input_width - 2:
                    start = max(0, cursor_pos - input_width + 5)
                    display_key = display_key[start:start + input_width - 2]
                    display_cursor = cursor_pos - start
                else:
                    display_cursor = cursor_pos
                
                self.editor.stdscr.addstr(input_y + 1, card_x + 5, display_key,
                                         Colors.get_pair(Colors.YELLOW, Colors.BLUE) | curses.A_BOLD)
                
                # –ö—É—Ä—Å–æ—Ä
                self.editor.stdscr.move(input_y + 1, card_x + 5 + min(display_cursor, input_width - 2))
            except:
                pass
            
            # –ö–Ω–æ–ø–∫–∞ –ø–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å
            toggle_text = "[Tab] –ü–æ–∫–∞–∑–∞—Ç—å" if not show_key else "[Tab] –°–∫—Ä—ã—Ç—å"
            try:
                self.editor.stdscr.addstr(card_y + card_height - 3, card_x + 4, toggle_text,
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
            except:
                pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∏
            try:
                hint = " [Enter] –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å  [Esc] –ù–∞–∑–∞–¥ "
                self.editor.stdscr.addstr(card_y + card_height - 2, 
                                         card_x + (card_width - len(hint)) // 2,
                                         hint, Colors.get_pair(Colors.CYAN, Colors.BLUE))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key == 27:
                curses.curs_set(0)
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                if api_key:
                    curses.curs_set(0)
                    return api_key
            elif key == 9:  # Tab
                show_key = not show_key
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if cursor_pos > 0:
                    api_key = api_key[:cursor_pos-1] + api_key[cursor_pos:]
                    cursor_pos -= 1
            elif key == curses.KEY_LEFT:
                cursor_pos = max(0, cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                cursor_pos = min(len(api_key), cursor_pos + 1)
            elif key == curses.KEY_HOME:
                cursor_pos = 0
            elif key == curses.KEY_END:
                cursor_pos = len(api_key)
            elif 32 <= key <= 126:
                api_key = api_key[:cursor_pos] + chr(key) + api_key[cursor_pos:]
                cursor_pos += 1
    
    def _show_model_selection(self, height: int, width: int, provider: str) -> Optional[str]:
        """–ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–∏"""
        provider_info = self.PROVIDERS[provider]
        models = provider_info['models']
        selected = 0
        
        card_width = min(55, width - 10)
        card_height = len(models) + 10
        card_y = (height - card_height) // 2
        card_x = (width - card_width) // 2
        
        while True:
            # –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
            self._draw_starfield(height, width)
            
            # –ö–∞—Ä—Ç–æ—á–∫–∞
            self._draw_card(card_y, card_x, card_height, card_width,
                           "üéØ –í–´–ë–û–† –ú–û–î–ï–õ–ò")
            
            # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            try:
                info = f"–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏ {provider_info['name']}:"
                self.editor.stdscr.addstr(card_y + 4, card_x + 3, info,
                                         Colors.get_pair(Colors.WHITE, Colors.BLUE))
            except:
                pass
            
            # –°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π
            for i, model in enumerate(models):
                my = card_y + 6 + i
                
                if i == selected:
                    attr = Colors.get_pair(Colors.BLACK, Colors.YELLOW) | curses.A_BOLD
                    prefix = " ‚ñ∂ "
                else:
                    attr = Colors.get_pair(Colors.WHITE, Colors.BLUE)
                    prefix = "   "
                
                line = f"{prefix}üîπ {model}"
                
                try:
                    self.editor.stdscr.addstr(my, card_x + 3, line.ljust(card_width - 6), attr)
                except:
                    pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∏
            try:
                hint = " [‚Üë‚Üì] –í—ã–±–æ—Ä  [Enter] –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å  [Esc] –ù–∞–∑–∞–¥ "
                self.editor.stdscr.addstr(card_y + card_height - 2,
                                         card_x + (card_width - len(hint)) // 2,
                                         hint, Colors.get_pair(Colors.CYAN, Colors.BLUE))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key == 27:
                return None
            elif key in (10, 13, curses.KEY_ENTER):
                return models[selected]
            elif key in (curses.KEY_UP, ord('k')):
                selected = (selected - 1) % len(models)
            elif key in (curses.KEY_DOWN, ord('j')):
                selected = (selected + 1) % len(models)
    
    def _show_success_screen(self, height: int, width: int):
        """–ü–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω —É—Å–ø–µ—à–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        card_width = min(50, width - 10)
        card_height = 12
        card_y = (height - card_height) // 2
        card_x = (width - card_width) // 2
        
        # –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
        self._draw_starfield(height, width)
        
        # –ö–∞—Ä—Ç–æ—á–∫–∞
        self._draw_card(card_y, card_x, card_height, card_width,
                       "‚úÖ –ù–ê–°–¢–†–û–ô–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê")
        
        try:
            lines = [
                "",
                f"  –ü—Ä–æ–≤–∞–π–¥–µ—Ä: {self.PROVIDERS[self.config['provider']]['name']}",
                f"  –ú–æ–¥–µ–ª—å: {self.config['model']}",
                "",
                "  AI –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!",
                "",
                "  –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É :ai –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤",
            ]
            
            for i, line in enumerate(lines):
                attr = Colors.get_pair(Colors.WHITE, Colors.BLUE)
                if "–ü—Ä–æ–≤–∞–π–¥–µ—Ä" in line or "–ú–æ–¥–µ–ª—å" in line:
                    attr = Colors.get_pair(Colors.YELLOW, Colors.BLUE) | curses.A_BOLD
                elif "–≥–æ—Ç–æ–≤" in line:
                    attr = Colors.get_pair(Colors.GREEN, Colors.BLUE) | curses.A_BOLD
                
                self.editor.stdscr.addstr(card_y + 3 + i, card_x + 2, line[:card_width - 4], attr)
            
            self.editor.stdscr.addstr(card_y + card_height - 2,
                                     card_x + (card_width - 20) // 2,
                                     " [Enter] –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å ",
                                     Colors.get_pair(Colors.CYAN, Colors.BLUE))
        except:
            pass
        
        self.editor.stdscr.refresh()
        
        while True:
            key = self.editor.stdscr.getch()
            if key in (10, 13, 27, curses.KEY_ENTER):
                break
    
    def show_ai_chat(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∞—Ç–∞ —Å AI"""
        if not self.is_configured():
            self.show_setup_wizard()
            return
        
        height, width = self.editor.stdscr.getmaxyx()
        
        card_width = min(70, width - 6)
        card_height = height - 4
        card_y = 2
        card_x = (width - card_width) // 2
        
        input_buffer = ""
        cursor_pos = 0
        scroll = 0
        
        curses.curs_set(1)
        
        while True:
            # –§–æ–Ω
            self._draw_starfield(height, width)
            
            # –ö–∞—Ä—Ç–æ—á–∫–∞
            self._draw_card(card_y, card_x, card_height, card_width,
                           f"ü§ñ AI –ü–û–ú–û–©–ù–ò–ö - {self.config.get('model', 'AI')}")
            
            # –ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞
            chat_y = card_y + 4
            chat_height = card_height - 10
            
            visible_messages = []
            for msg in self.chat_history:
                role = msg.get('role', 'user')
                content = msg.get('content', '')
                
                prefix = "üë§ –í—ã: " if role == 'user' else "ü§ñ AI: "
                lines = self._wrap_text(prefix + content, card_width - 8)
                visible_messages.extend(lines)
            
            # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø—Ä–æ–∫—Ä—É—Ç–∫–æ–π
            start = max(0, len(visible_messages) - chat_height - scroll)
            end = start + chat_height
            
            for i, line in enumerate(visible_messages[start:end]):
                try:
                    if line.startswith("üë§"):
                        attr = Colors.get_pair(Colors.CYAN, Colors.BLUE)
                    elif line.startswith("ü§ñ"):
                        attr = Colors.get_pair(Colors.GREEN, Colors.BLUE)
                    else:
                        attr = Colors.get_pair(Colors.WHITE, Colors.BLUE)
                    
                    self.editor.stdscr.addstr(chat_y + i, card_x + 3, 
                                             line[:card_width - 6], attr)
                except:
                    pass
            
            # –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä –µ—Å–ª–∏ –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π
            if not self.chat_history:
                try:
                    placeholder = "–ó–¥–µ—Å—å –≤–≤–µ–¥–∏ —Å–≤–æ–π –ø—Ä–æ–º–ø—Ç..."
                    self.editor.stdscr.addstr(chat_y + chat_height // 2, 
                                             card_x + (card_width - len(placeholder)) // 2,
                                             placeholder,
                                             Colors.get_pair(Colors.CYAN, Colors.BLUE) | curses.A_DIM)
                except:
                    pass
            
            # –ü–æ–ª–µ –≤–≤–æ–¥–∞
            input_y = card_y + card_height - 5
            input_width = card_width - 10
            
            try:
                self.editor.stdscr.addstr(input_y, card_x + 4, "‚îÄ" * (input_width + 2),
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                self.editor.stdscr.addstr(input_y + 1, card_x + 4, "‚îÇ " + " " * input_width + "‚îÇ",
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                self.editor.stdscr.addstr(input_y + 2, card_x + 4, "‚îÄ" * (input_width + 2),
                                         Colors.get_pair(Colors.CYAN, Colors.BLUE))
                
                # –¢–µ–∫—Å—Ç –≤–≤–æ–¥–∞
                display_input = input_buffer
                if len(display_input) > input_width - 2:
                    start = max(0, cursor_pos - input_width + 5)
                    display_input = display_input[start:start + input_width - 2]
                    display_cursor = cursor_pos - start
                else:
                    display_cursor = cursor_pos
                
                self.editor.stdscr.addstr(input_y + 1, card_x + 6, display_input,
                                         Colors.get_pair(Colors.YELLOW, Colors.BLUE))
                
                self.editor.stdscr.move(input_y + 1, card_x + 6 + display_cursor)
            except:
                pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∏
            try:
                hint = " [Enter] –û—Ç–ø—Ä–∞–≤–∏—Ç—å  [Esc] –ó–∞–∫—Ä—ã—Ç—å  [Ctrl+L] –û—á–∏—Å—Ç–∏—Ç—å "
                self.editor.stdscr.addstr(card_y + card_height - 2,
                                         card_x + (card_width - len(hint)) // 2,
                                         hint, Colors.get_pair(Colors.CYAN, Colors.BLUE))
            except:
                pass
            
            self.editor.stdscr.refresh()
            
            key = self.editor.stdscr.getch()
            
            if key == 27:
                curses.curs_set(0)
                return
            elif key in (10, 13, curses.KEY_ENTER):
                if input_buffer.strip():
                    self._send_message(input_buffer.strip())
                    input_buffer = ""
                    cursor_pos = 0
            elif key == 12:  # Ctrl+L
                self.chat_history = []
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if cursor_pos > 0:
                    input_buffer = input_buffer[:cursor_pos-1] + input_buffer[cursor_pos:]
                    cursor_pos -= 1
            elif key == curses.KEY_LEFT:
                cursor_pos = max(0, cursor_pos - 1)
            elif key == curses.KEY_RIGHT:
                cursor_pos = min(len(input_buffer), cursor_pos + 1)
            elif key == curses.KEY_UP:
                scroll = min(len(visible_messages) - chat_height, scroll + 1)
            elif key == curses.KEY_DOWN:
                scroll = max(0, scroll - 1)
            elif 32 <= key <= 126:
                input_buffer = input_buffer[:cursor_pos] + chr(key) + input_buffer[cursor_pos:]
                cursor_pos += 1
    
    def _wrap_text(self, text: str, width: int) -> List[str]:
        """–†–∞–∑–±–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏"""
        lines = []
        for paragraph in text.split('\n'):
            if not paragraph:
                lines.append("")
                continue
            
            current_line = ""
            for word in paragraph.split():
                if len(current_line) + len(word) + 1 <= width:
                    current_line += (" " if current_line else "") + word
                else:
                    if current_line:
                        lines.append(current_line)
                    current_line = word
            if current_line:
                lines.append(current_line)
        
        return lines
    
    def _send_message(self, message: str):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ AI"""
        self.chat_history.append({"role": "user", "content": message})
        
        # –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
        self.chat_history.append({"role": "assistant", "content": "‚è≥ –î—É–º–∞—é..."})
        
        try:
            response = self._call_api(message)
            self.chat_history[-1] = {"role": "assistant", "content": response}
        except Exception as e:
            self.chat_history[-1] = {"role": "assistant", "content": f"‚ùå –û—à–∏–±–∫–∞: {str(e)}"}
    
    def _call_api(self, message: str) -> str:
        """–í—ã–∑–æ–≤ API –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"""
        provider = self.config.get('provider')
        api_key = self.config.get('api_key')
        model = self.config.get('model')
        
        if not provider or not api_key:
            return "‚ùå AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ :ai setup"
        
        provider_info = self.PROVIDERS.get(provider)
        if not provider_info:
            return "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        if provider in ['openai', 'groq', 'deepseek']:
            return self._call_openai_compatible(provider_info, api_key, model, message)
        elif provider == 'anthropic':
            return self._call_anthropic(api_key, model, message)
        elif provider == 'google':
            return self._call_google(api_key, model, message)
        elif provider == 'local':
            return self._call_ollama(model, message)
        
        return "‚ùå –ü—Ä–æ–≤–∞–π–¥–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
    
    def _call_openai_compatible(self, provider_info: Dict, api_key: str, 
                                 model: str, message: str) -> str:
        """–í—ã–∑–æ–≤ OpenAI-—Å–æ–≤–º–µ—Å—Ç–∏–º–æ–≥–æ API"""
        import urllib.request
        import urllib.error
        
        url = provider_info['api_url']
        
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        
        data = {
            'model': model,
            'messages': [
                {'role': 'system', 'content': '–¢—ã - –ø–æ–ª–µ–∑–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É.'},
                {'role': 'user', 'content': message}
            ],
            'max_tokens': 2000,
            'temperature': 0.7
        }
        
        try:
            req = urllib.request.Request(url, 
                                         data=json.dumps(data).encode(),
                                         headers=headers,
                                         method='POST')
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['choices'][0]['message']['content']
                
        except urllib.error.HTTPError as e:
            error_body = e.read().decode()
            return f"‚ùå HTTP {e.code}: {error_body[:200]}"
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞: {str(e)}"
    
    def _call_anthropic(self, api_key: str, model: str, message: str) -> str:
        """–í—ã–∑–æ–≤ Anthropic Claude API"""
        import urllib.request
        
        url = "https://api.anthropic.com/v1/messages"
        
        headers = {
            'Content-Type': 'application/json',
            'x-api-key': api_key,
            'anthropic-version': '2023-06-01'
        }
        
        data = {
            'model': model,
            'max_tokens': 2000,
            'messages': [{'role': 'user', 'content': message}]
        }
        
        try:
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers=headers,
                                         method='POST')
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['content'][0]['text']
                
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞: {str(e)}"
    
    def _call_google(self, api_key: str, model: str, message: str) -> str:
        """–í—ã–∑–æ–≤ Google Gemini API"""
        import urllib.request
        
        url = f"https://generativelanguage.googleapis.com/v1/models/{model}:generateContent?key={api_key}"
        
        headers = {'Content-Type': 'application/json'}
        
        data = {
            'contents': [{'parts': [{'text': message}]}]
        }
        
        try:
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers=headers,
                                         method='POST')
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['candidates'][0]['content']['parts'][0]['text']
                
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞: {str(e)}"
    
    def _call_ollama(self, model: str, message: str) -> str:
        """–í—ã–∑–æ–≤ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ Ollama"""
        import urllib.request
        
        url = "http://localhost:11434/api/generate"
        
        data = {
            'model': model,
            'prompt': message,
            'stream': False
        }
        
        try:
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers={'Content-Type': 'application/json'},
                                         method='POST')
            
            with urllib.request.urlopen(req, timeout=120) as response:
                result = json.loads(response.read().decode())
                return result.get('response', '‚ùå –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç')
                
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞ Ollama: {str(e)}\n–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ Ollama –∑–∞–ø—É—â–µ–Ω: ollama serve"
    
    def query(self, prompt: str) -> str:
        """–ü—Ä—è–º–æ–π –∑–∞–ø—Ä–æ—Å –∫ AI (–¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞)"""
        if not self.is_configured():
            return "‚ùå AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ :ai setup"
        
        return self._call_api(prompt)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ü–õ–ê–ì–ò–ù 20: SMART BOT - –£–ú–ù–´–ô –ë–û–¢ –ë–ï–ó AI (–ë–ï–°–ü–õ–ê–¢–ù–´–ô)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SmartBotPlugin(Plugin):
    """–£–º–Ω—ã–π –±–æ—Ç –±–µ–∑ AI - —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω–æ"""
    
    name = "SmartBot"
    description = "–õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞"
    
    TYPOS = {
        "pritn": "print", "improt": "import", "retrun": "return",
        "fucntion": "function", "funciton": "function", "funtion": "function",
        "ture": "True", "flase": "False", "Ture": "True", "Flase": "False",
        "slef": "self", "selef": "self", "sefl": "self",
        "dfe": "def", "clas": "class", "calss": "class",
        "whiel": "while", "wihle": "while", "forr": "for",
        "ipmort": "import", "impor": "import", "imoprt": "import",
        "reutrn": "return", "retunr": "return", "rteurn": "return",
        "breack": "break", "brak": "break", "contniue": "continue",
        "esle": "else", "elseif": "elif", "elfi": "elif",
        "lnegth": "length", "lenght": "length", "lenth": "length",
        "vlaue": "value", "valeu": "value", "valu": "value",
        "stirng": "string", "strign": "string", "sring": "string",
        "arary": "array", "arry": "array", "arrya": "array",
        "consle": "console", "consloe": "console", "cosole": "console",
        "docuemnt": "document", "documnet": "document", "documetn": "document",
        "windwo": "window", "widnow": "window", "winodw": "window",
    }
    
    ERROR_HINTS = {
        "SyntaxError: invalid syntax": [
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–∫–æ–±–∫–∏ (), [], {}",
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –ø–æ—Å–ª–µ if/for/def/class —Å—Ç–æ–∏—Ç –¥–≤–æ–µ—Ç–æ—á–∏–µ :",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–∞–≤—ã—á–∫–∏ –≤ —Å—Ç—Ä–æ–∫–∞—Ö",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç—Å—Ç—É–ø—ã"
        ],
        "NameError": [
            "‚Ä¢ –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ–ø–µ—á–∞—Ç–∫–∏ –≤ –∏–º–µ–Ω–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π",
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ import –≤—ã–ø–æ–ª–Ω–µ–Ω"
        ],
        "IndentationError": [
            "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –æ—Ç—Å—Ç—É–ø—ã (4 –ø—Ä–æ–±–µ–ª–∞)",
            "‚Ä¢ –ù–µ —Å–º–µ—à–∏–≤–∞–π—Ç–µ —Ç–∞–±—ã –∏ –ø—Ä–æ–±–µ–ª—ã",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç—Å—Ç—É–ø—ã –ø–æ—Å–ª–µ if/for/def/class"
        ],
        "TypeError": [
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö",
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤",
            "‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —è–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ (int(), str())"
        ],
        "AttributeError": [
            "‚Ä¢ –û–±—ä–µ–∫—Ç –Ω–µ –∏–º–µ–µ—Ç —ç—Ç–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞/–º–µ—Ç–æ–¥–∞",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∏–º–µ–Ω–∏ –º–µ—Ç–æ–¥–∞",
            "‚Ä¢ –í–æ–∑–º–æ–∂–Ω–æ –æ–±—ä–µ–∫—Ç None"
        ],
        "KeyError": [
            "‚Ä¢ –ö–ª—é—á –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ",
            "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ .get() –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∫–ª—é—á–∞"
        ],
        "IndexError": [
            "‚Ä¢ –ò–Ω–¥–µ–∫—Å –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã —Å–ø–∏—Å–∫–∞",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–ª–∏–Ω—É —Å–ø–∏—Å–∫–∞ –ø–µ—Ä–µ–¥ –¥–æ—Å—Ç—É–ø–æ–º",
            "‚Ä¢ –ò–Ω–¥–µ–∫—Å—ã –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å 0"
        ],
        "ModuleNotFoundError": [
            "‚Ä¢ –ú–æ–¥—É–ª—å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: pip install <module>",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∏–º–µ–Ω–∏ –º–æ–¥—É–ª—è",
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ"
        ],
        "FileNotFoundError": [
            "‚Ä¢ –§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—É—Ç–∏",
            "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å"
        ],
        "ValueError": [
            "‚Ä¢ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏",
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö",
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –æ–∂–∏–¥–∞–Ω–∏—è–º"
        ],
        "ZeroDivisionError": [
            "‚Ä¢ –î–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å",
            "‚Ä¢ –î–æ–±–∞–≤—å—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É: if divisor != 0",
            "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ try/except"
        ]
    }
    
    def __init__(self, editor: 'Editor'):
        super().__init__(editor)
    
    def check_typos(self, text: str) -> List[Dict]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ –æ–ø–µ—á–∞—Ç–∫–∏"""
        results = []
        words = re.findall(r'\b\w+\b', text)
        
        for word in words:
            if word.lower() in self.TYPOS:
                results.append({
                    "typo": word,
                    "correction": self.TYPOS[word.lower()],
                    "message": f"'{word}' ‚Üí '{self.TYPOS[word.lower()]}'"
                })
        
        return results
    
    def get_error_hints(self, error_message: str) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ –æ—à–∏–±–∫–µ"""
        for error_type, hints in self.ERROR_HINTS.items():
            if error_type in error_message:
                return hints
        
        return ["‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∫–æ–¥–∞", "‚Ä¢ –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –≤ –æ—à–∏–±–∫–µ"]
    
    def suggest_imports(self, code: str) -> List[str]:
        """–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∏–º–ø–æ—Ä—Ç—ã"""
        suggestions = []
        
        common_imports = {
            "os.path": "import os",
            "json.": "import json",
            "re.": "import re",
            "datetime": "from datetime import datetime",
            "Path(": "from pathlib import Path",
            "requests.": "import requests",
            "np.": "import numpy as np",
            "pd.": "import pandas as pd",
            "plt.": "import matplotlib.pyplot as plt",
            "sqrt": "from math import sqrt",
            "random.": "import random",
            "time.": "import time",
            "sys.": "import sys",
            "subprocess": "import subprocess",
            "threading": "import threading",
            "asyncio": "import asyncio",
        }
        
        for pattern, import_stmt in common_imports.items():
            if pattern in code and import_stmt not in code:
                suggestions.append(import_stmt)
        
        return suggestions
    
    def analyze_code(self, code: str, language: str = "python") -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞"""
        result = {
            "typos": self.check_typos(code),
            "suggested_imports": self.suggest_imports(code) if language == "python" else [],
            "issues": [],
            "tips": []
        }
        
        lines = code.split('\n')
        
        for i, line in enumerate(lines, 1):
            # –î–ª–∏–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
            if len(line) > 100:
                result["issues"].append({
                    "line": i,
                    "type": "warning",
                    "message": f"–°—Ç—Ä–æ–∫–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è ({len(line)} —Å–∏–º–≤–æ–ª–æ–≤)"
                })
            
            # TODO –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
            if "TODO" in line or "FIXME" in line:
                result["tips"].append({
                    "line": i,
                    "message": "–ï—Å—Ç—å –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω–æ–µ TODO/FIXME"
                })
            
            # –ü—É—Å—Ç–æ–π except
            if language == "python" and "except:" in line:
                result["issues"].append({
                    "line": i,
                    "type": "warning",
                    "message": "–ü—É—Å—Ç–æ–π except: –ª–æ–≤–∏—Ç –≤—Å–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è. –£–∫–∞–∂–∏—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø."
                })
            
            # print –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            if "print(" in line and "#" not in line.split("print")[0]:
                result["tips"].append({
                    "line": i,
                    "message": "print() –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ - –Ω–µ –∑–∞–±—É–¥—å—Ç–µ —É–¥–∞–ª–∏—Ç—å –ø–µ—Ä–µ–¥ —Ä–µ–ª–∏–∑–æ–º"
                })
        
        return result


print("‚úÖ –ß–∞—Å—Ç—å 5/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: Terminal, MultiCursor, Minimap, APK Builder, AI Assistant, SmartBot")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ú–ï–ù–ï–î–ñ–ï–† –ü–õ–ê–ì–ò–ù–û–í
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PluginManager:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ–º–∏ –ø–ª–∞–≥–∏–Ω–∞–º–∏"""
    
    def __init__(self, editor: 'Editor'):
        self.editor = editor
        self.plugins: Dict[str, Plugin] = {}
        self._load_builtin_plugins()
    
    def _load_builtin_plugins(self):
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –ø–ª–∞–≥–∏–Ω—ã"""
        self.plugins = {
            'runner': RunnerPlugin(self.editor),
            'file_explorer': FileExplorerPlugin(self.editor),
            'git': GitPlugin(self.editor),
            'snippets': SnippetsPlugin(self.editor),
            'linter': LinterPlugin(self.editor),
            'formatter': FormatterPlugin(self.editor),
            'bookmarks': BookmarksPlugin(self.editor),
            'folding': FoldingPlugin(self.editor),
            'autocomplete': AutoCompletePlugin(self.editor),
            'comments': CommentsPlugin(self.editor),
            'autosave': AutoSavePlugin(self.editor),
            'session': SessionPlugin(self.editor),
            'terminal': TerminalPlugin(self.editor),
            'multicursor': MultiCursorPlugin(self.editor),
            'minimap': MinimapPlugin(self.editor),
            'brackets': BracketsPlugin(self.editor),
            'indent': IndentPlugin(self.editor),
            'apk_builder': APKBuilderPlugin(self.editor),
            'ai': AIAssistantPlugin(self.editor),
            'smartbot': SmartBotPlugin(self.editor),
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–æ–≤
        for plugin in self.plugins.values():
            try:
                plugin.on_load()
            except:
                pass
    
    def get(self, name: str) -> Optional[Plugin]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–ª–∞–≥–∏–Ω –ø–æ –∏–º–µ–Ω–∏"""
        return self.plugins.get(name)
    
    def call_event(self, event: str, *args, **kwargs):
        """–í—ã–∑–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –≤—Å–µ—Ö –ø–ª–∞–≥–∏–Ω–æ–≤"""
        for plugin in self.plugins.values():
            if plugin.enabled:
                try:
                    handler = getattr(plugin, f'on_{event}', None)
                    if handler:
                        handler(*args, **kwargs)
                except:
                    pass
    
    def list_plugins(self) -> List[Dict]:
        """–°–ø–∏—Å–æ–∫ –ø–ª–∞–≥–∏–Ω–æ–≤"""
        result = []
        for name, plugin in self.plugins.items():
            result.append({
                'id': name,
                'name': plugin.name,
                'description': plugin.description,
                'enabled': plugin.enabled,
                'version': plugin.version
            })
        return result


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ó–ê–°–¢–ê–í–ö–ê (SPLASH SCREEN)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SplashScreen:
    """–ö—Ä–∞—Å–∏–≤–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
    
    LOGO = """
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë
    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
    """
    
    LOGO_SMALL = """
     ____  ___ ____   ___  
    |  _ \\|_ _|  _ \\ / _ \\ 
    | | | || || |_) | | | |
    | |_| || ||  __/| |_| |
    |____/___|_|    \\___/ 
    """
    
    @classmethod
    def show(cls, stdscr, duration: float = 2.0):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É"""
        height, width = stdscr.getmaxyx()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–æ–≤
        Colors.init(stdscr)
        
        curses.curs_set(0)
        stdscr.clear()
        
        # –ê–Ω–∏–º–∞—Ü–∏—è –∑–≤—ë–∑–¥ –Ω–∞ —Ñ–æ–Ω–µ
        import random
        stars = []
        for _ in range(60):
            stars.append({
                'x': random.randint(0, width - 1),
                'y': random.randint(0, height - 1),
                'char': random.choice(['¬∑', '‚ú¶', '‚úß', '‚òÖ', '‚ú∂', '*', '.']),
                'color': random.choice([Colors.WHITE, Colors.CYAN, Colors.YELLOW, Colors.MAGENTA])
            })
        
        # –í—ã–±–æ—Ä –ª–æ–≥–æ—Ç–∏–ø–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É —ç–∫—Ä–∞–Ω–∞
        logo = cls.LOGO if width > 50 else cls.LOGO_SMALL
        logo_lines = [l for l in logo.split('\n') if l.strip()]
        
        logo_height = len(logo_lines)
        logo_width = max(len(l) for l in logo_lines)
        
        start_y = (height - logo_height - 12) // 2
        start_x = (width - logo_width) // 2
        
        # –¶–≤–µ—Ç–∞ –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ –ª–æ–≥–æ—Ç–∏–ø–∞
        logo_colors = [
            Colors.get_pair(Colors.MAGENTA, -1) | curses.A_BOLD,  # –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            Colors.get_pair(Colors.BLUE, -1) | curses.A_BOLD,     # –°–∏–Ω–∏–π
            Colors.get_pair(Colors.CYAN, -1) | curses.A_BOLD,     # –ì–æ–ª—É–±–æ–π
        ]
        
        frames = int(duration * 10)
        
        for frame in range(frames):
            stdscr.clear()
            
            # –†–∏—Å—É–µ–º –∑–≤—ë–∑–¥—ã (–º–µ—Ä—Ü–∞–Ω–∏–µ)
            for star in stars:
                if random.random() > 0.3:  # –ú–µ—Ä—Ü–∞–Ω–∏–µ
                    try:
                        attr = Colors.get_pair(star['color'], -1)
                        if random.random() > 0.7:
                            attr |= curses.A_BOLD
                        else:
                            attr |= curses.A_DIM
                        stdscr.addstr(star['y'], star['x'], star['char'], attr)
                    except:
                        pass
            
            # –†–∏—Å—É–µ–º –ª–æ–≥–æ—Ç–∏–ø —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
            for i, line in enumerate(logo_lines):
                color_idx = i % len(logo_colors)
                color = logo_colors[color_idx]
                
                try:
                    # –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è
                    if frame < 5:
                        visible_chars = (frame + 1) * len(line) // 5
                        line = line[:visible_chars]
                    
                    stdscr.addstr(start_y + i, start_x, line, color)
                except:
                    pass
            
            # –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫
            subtitle = "S T U D I O"
            sub_x = (width - len(subtitle)) // 2
            try:
                stdscr.addstr(start_y + logo_height + 1, sub_x, subtitle,
                             Colors.get_pair(Colors.YELLOW, -1) | curses.A_BOLD)
            except:
                pass
            
            # –í–µ—Ä—Å–∏—è
            version_text = f"v{__version__}"
            try:
                stdscr.addstr(start_y + logo_height + 2, (width - len(version_text)) // 2,
                             version_text, Colors.get_pair(Colors.WHITE, -1))
            except:
                pass
            
            # –û–ø–∏—Å–∞–Ω–∏–µ
            desc = "üöÄ –ú–æ—â–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏"
            try:
                stdscr.addstr(start_y + logo_height + 4, (width - len(desc)) // 2,
                             desc, Colors.get_pair(Colors.CYAN, -1))
            except:
                pass
            
            # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤
            if frame >= 10:
                instructions = [
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                    "",
                    "üì± –ë–´–°–¢–†–´–ô –°–¢–ê–†–¢:",
                    "",
                    "  :h  - –°–ø—Ä–∞–≤–∫–∞           :s  - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                    "  :q  - –í—ã—Ö–æ–¥             :r  - –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥",
                    "  :f  - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫         :ai - AI –ø–æ–º–æ—â–Ω–∏–∫",
                    "",
                    "  –î–ª—è –ü–ö: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ F1-F12 –∏ Ctrl+–∫–ª–∞–≤–∏—à–∏",
                    "",
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                ]
                
                inst_start_y = start_y + logo_height + 6
                for i, line in enumerate(instructions):
                    try:
                        x = (width - len(line)) // 2 if line else (width - 50) // 2
                        color = Colors.get_pair(Colors.WHITE, -1)
                        if "–ë–´–°–¢–†–´–ô" in line:
                            color = Colors.get_pair(Colors.YELLOW, -1) | curses.A_BOLD
                        elif line.startswith("  :"):
                            color = Colors.get_pair(Colors.GREEN, -1)
                        elif "‚îÅ" in line:
                            color = Colors.get_pair(Colors.MAGENTA, -1)
                        stdscr.addstr(inst_start_y + i, x, line, color)
                    except:
                        pass
            
            # Telegram
            tg_y = height - 3
            try:
                tg_line = "üì± Telegram: @MARADANIL"
                stdscr.addstr(tg_y, (width - len(tg_line)) // 2, tg_line,
                             Colors.get_pair(Colors.CYAN, -1))
                
                channel_line = "üì¢ –ö–∞–Ω–∞–ª: https://t.me/DIPO_OFFICIAL"
                stdscr.addstr(tg_y + 1, (width - len(channel_line)) // 2, channel_line,
                             Colors.get_pair(Colors.BLUE, -1))
            except:
                pass
            
            # –ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ –∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
            if frame < frames - 5:
                progress = int((frame / frames) * 30)
                progress_bar = "‚ñà" * progress + "‚ñë" * (30 - progress)
                try:
                    stdscr.addstr(height - 1, (width - 32) // 2, f"[{progress_bar}]",
                                 Colors.get_pair(Colors.MAGENTA, -1))
                except:
                    pass
            else:
                try:
                    msg = "–ù–∞–∂–º–∏—Ç–µ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É..."
                    stdscr.addstr(height - 1, (width - len(msg)) // 2, msg,
                                 Colors.get_pair(Colors.YELLOW, -1) | curses.A_BLINK)
                except:
                    pass
            
            stdscr.refresh()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞
            stdscr.nodelay(True)
            key = stdscr.getch()
            stdscr.nodelay(False)
            
            if key != -1 and frame > 10:
                break
            
            curses.napms(100)
        
        # –ñ–¥—ë–º –Ω–∞–∂–∞—Ç–∏—è –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å
        if frame >= frames - 1:
            stdscr.nodelay(False)
            stdscr.getch()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ì–õ–ê–í–ù–´–ô –ö–õ–ê–°–° EDITOR
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Editor:
    """–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ Dipo Studio"""
    
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.running = True
        self.mode = "normal"  # normal, command, search, zen
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è curses
        self._init_curses()
        
        # –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self.tab_manager = TabManager()
        self.highlighter = SyntaxHighlighter()
        self.clipboard = Clipboard()
        self.plugin_manager = PluginManager(self)
        
        # –¢–µ–∫—É—â–∞—è —Ç–µ–º–∞
        self.theme_name = settings.get("theme", "cosmos")
        self.theme = THEMES.get(self.theme_name, THEMES["cosmos"])
        
        # –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        self.command_buffer = ""
        self.command_cursor = 0
        self.search_text = ""
        self.search_results: List[Tuple[int, int]] = []
        self.search_index = 0
        self.status_message = ""
        self.status_type = "info"  # info, success, warning, error
        self.status_time = 0
        
        # Zen mode
        self.zen_mode = False
        
        # –í—Ä–µ–º—è –¥–ª—è –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        self.last_autosave = time.time()
        
        # –†–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞
        self.height, self.width = stdscr.getmaxyx()
    
    def _init_curses(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è curses"""
        curses.curs_set(1)
        self.stdscr.keypad(True)
        self.stdscr.timeout(100)  # 100ms –¥–ª—è –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–≥–æ –≤–≤–æ–¥–∞
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–æ–≤
        Colors.init(self.stdscr)
        
        # –ú—ã—à—å (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)
        try:
            curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        except:
            pass
    
    def run(self, files: List[str] = None, restore_session: bool = True):
        """–ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞"""
        # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Å—Å–∏—é –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª—ã
        if files:
            for f in files:
                self.tab_manager.open_file(f)
        elif restore_session:
            session_plugin = self.plugin_manager.get('session')
            if session_plugin:
                session_plugin.load_session()
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –≤–∫–ª–∞–¥–æ–∫ - —Å–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç—É—é
        if not self.tab_manager.tabs:
            self.tab_manager.new_tab()
        
        # –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
        while self.running:
            try:
                self._update_size()
                self._draw()
                self._handle_input()
                self._check_autosave()
            except KeyboardInterrupt:
                if self._confirm_exit():
                    break
            except Exception as e:
                self._show_error(f"–û—à–∏–±–∫–∞: {str(e)}")
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–µ—Å—Å–∏—é –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
        session_plugin = self.plugin_manager.get('session')
        if session_plugin:
            session_plugin.save_session()
    
    def _update_size(self):
        """–û–±–Ω–æ–≤–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞"""
        new_height, new_width = self.stdscr.getmaxyx()
        if new_height != self.height or new_width != self.width:
            self.height, self.width = new_height, new_width
            self.stdscr.clear()
    
    def _draw(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""
        self.stdscr.erase()
        
        if self.zen_mode:
            self._draw_zen_mode()
        else:
            self._draw_header()
            self._draw_editor()
            self._draw_footer()
        
        # –°—Ç–∞—Ç—É—Å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if self.status_message and time.time() - self.status_time < 3:
            self._draw_status_message()
        
        # –ö–æ–º–∞–Ω–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
        if self.mode == "command":
            self._draw_command_line()
        
        self.stdscr.refresh()
    
    def _draw_header(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞"""
        # –§–æ–Ω –∑–∞–≥–æ–ª–æ–≤–∫–∞
        header_bg = Colors.get_pair(self.theme.get("header_fg", Colors.WHITE),
                                    self.theme.get("header_bg", Colors.BLUE))
        
        try:
            self.stdscr.addstr(0, 0, " " * self.width, header_bg)
        except:
            pass
        
        # –õ–æ–≥–æ—Ç–∏–ø
        logo = "üöÄ DIPO"
        try:
            self.stdscr.addstr(0, 1, logo, header_bg | curses.A_BOLD)
        except:
            pass
        
        # –í–∫–ª–∞–¥–∫–∏
        tabs_start = len(logo) + 3
        tabs_width = self.width - tabs_start - 25
        
        current_x = tabs_start
        for i, tab in enumerate(self.tab_manager.tabs):
            if current_x >= tabs_start + tabs_width - 15:
                try:
                    self.stdscr.addstr(0, current_x, "...", header_bg)
                except:
                    pass
                break
            
            title = f" {tab.icon} {tab.title} "
            
            if i == self.tab_manager.active_index:
                tab_attr = Colors.get_pair(Colors.BLACK, Colors.WHITE) | curses.A_BOLD
            else:
                tab_attr = header_bg
            
            try:
                self.stdscr.addstr(0, current_x, title[:15], tab_attr)
                current_x += min(len(title), 15) + 1
            except:
                pass
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —è–∑—ã–∫–µ –∏ —Ç–µ–º–µ
        tab = self.tab_manager.active_tab
        if tab:
            lang = tab.buffer.language or "text"
            lang_info = LANGUAGES.get(lang, {})
            lang_display = f"{lang_info.get('icon', 'üìÑ')} {lang_info.get('name', lang)}"
            theme_icon = self.theme.get('name', 'üåå')[:2]
            
            right_info = f" {lang_display} ‚îÇ {theme_icon} "
            try:
                self.stdscr.addstr(0, self.width - len(right_info) - 1, right_info, header_bg)
            except:
                pass
    
    def _draw_editor(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –æ–±–ª–∞—Å—Ç–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞"""
        tab = self.tab_manager.active_tab
        if not tab:
            self._draw_welcome_screen()
            return
        
        # –í—ã—á–∏—Å–ª–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã
        start_y = 1
        end_y = self.height - 2
        editor_height = end_y - start_y
        
        # –®–∏—Ä–∏–Ω–∞ –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–æ–∫
        line_count = tab.buffer.line_count
        line_num_width = max(4, len(str(line_count)) + 2)
        
        # –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞
        minimap_plugin = self.plugin_manager.get('minimap')
        minimap_width = 0
        if minimap_plugin and minimap_plugin.visible:
            minimap_width = minimap_plugin.width + 1
        
        text_width = self.width - line_num_width - minimap_width
        
        # –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –∫—É—Ä—Å–æ—Ä –≤–∏–¥–∏–º
        tab.ensure_cursor_visible(editor_height, self.width, line_num_width)
        
        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
        highlighted = self.highlighter.get_highlighted_lines(tab.buffer, self.theme)
        
        # –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        bookmarks_plugin = self.plugin_manager.get('bookmarks')
        folding_plugin = self.plugin_manager.get('folding')
        linter_plugin = self.plugin_manager.get('linter')
        
        # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫
        screen_row = 0
        buffer_row = tab.scroll_row
        
        while screen_row < editor_height and buffer_row < line_count:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è
            if folding_plugin and folding_plugin.is_hidden(tab.id, buffer_row):
                buffer_row += 1
                continue
            
            y = start_y + screen_row
            
            # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏
            is_current_line = buffer_row == tab.cursor.row
            if is_current_line and settings.get("highlight_current_line", True):
                line_bg = Colors.get_pair(Colors.WHITE, self.theme.get("current_line_bg", Colors.BLUE))
                try:
                    self.stdscr.addstr(y, 0, " " * (self.width - minimap_width), line_bg | curses.A_DIM)
                except:
                    pass
            
            # –ù–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏
            line_num = str(buffer_row + 1).rjust(line_num_width - 1)
            
            # –ú–∞—Ä–∫–µ—Ä—ã (–∑–∞–∫–ª–∞–¥–∫–∞, –æ—à–∏–±–∫–∞, —Å–≤—ë—Ä—Ç–∫–∞)
            marker = " "
            marker_color = Colors.get_pair(self.theme.get("line_num", Colors.CYAN), -1)
            
            if bookmarks_plugin and bookmarks_plugin.has_bookmark(tab.id, buffer_row):
                marker = "‚óè"
                marker_color = Colors.get_pair(Colors.YELLOW, -1) | curses.A_BOLD
            
            if linter_plugin:
                errors = linter_plugin.get_errors_for_line(tab.id, buffer_row + 1)
                if errors:
                    for err in errors:
                        if err["type"] == "error":
                            marker = "‚úñ"
                            marker_color = Colors.get_pair(Colors.RED, -1) | curses.A_BOLD
                            break
                        elif err["type"] == "warning":
                            marker = "‚ö†"
                            marker_color = Colors.get_pair(Colors.YELLOW, -1)
            
            if folding_plugin and folding_plugin.is_folded(tab.id, buffer_row):
                marker = "‚ñ∂"
                marker_color = Colors.get_pair(Colors.CYAN, -1)
            
            try:
                num_color = Colors.get_pair(self.theme.get("line_num", Colors.CYAN), -1)
                if is_current_line:
                    num_color |= curses.A_BOLD
                
                self.stdscr.addstr(y, 0, line_num, num_color)
                self.stdscr.addstr(y, line_num_width - 1, marker, marker_color)
            except:
                pass
            
            # –¢–µ–∫—Å—Ç —Å—Ç—Ä–æ–∫–∏ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
            if buffer_row < len(highlighted):
                tokens = highlighted[buffer_row]
                x = line_num_width
                col = tab.scroll_col
                
                for token_text, token_attr in tokens:
                    if col > 0:
                        if len(token_text) <= col:
                            col -= len(token_text)
                            continue
                        token_text = token_text[col:]
                        col = 0
                    
                    if x >= self.width - minimap_width:
                        break
                    
                    visible_text = token_text[:self.width - minimap_width - x]
                    
                    try:
                        self.stdscr.addstr(y, x, visible_text, token_attr)
                        x += len(visible_text)
                    except:
                        pass
            
            # –ö—É—Ä—Å–æ—Ä
            if is_current_line:
                cursor_screen_x = line_num_width + tab.cursor.col - tab.scroll_col
                if 0 <= cursor_screen_x < self.width - minimap_width:
                    try:
                        self.stdscr.move(y, cursor_screen_x)
                    except:
                        pass
            
            screen_row += 1
            buffer_row += 1
        
        # –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞
        if minimap_plugin and minimap_plugin.visible:
            minimap_plugin.draw(self.stdscr, self.width - minimap_width, 
                               start_y, editor_height, tab, self.highlighter)
    
    def _draw_footer(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –Ω–∏–∂–Ω–µ–π –ø–∞–Ω–µ–ª–∏"""
        footer_y = self.height - 2
        status_y = self.height - 1
        
        tab = self.tab_manager.active_tab
        
        # –°—Ç—Ä–æ–∫–∞ —Å—Ç–∞—Ç—É—Å–∞
        footer_bg = Colors.get_pair(self.theme.get("footer_fg", Colors.WHITE),
                                    self.theme.get("footer_bg", Colors.MAGENTA))
        
        try:
            self.stdscr.addstr(footer_y, 0, " " * self.width, footer_bg)
        except:
            pass
        
        if tab:
            # –ü–æ–∑–∏—Ü–∏—è –∫—É—Ä—Å–æ—Ä–∞
            pos_info = f" üìç –°—Ç—Ä–æ–∫–∞ {tab.cursor.row + 1}, –ö–æ–ª–æ–Ω–∫–∞ {tab.cursor.col + 1}"
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            words = tab.buffer.total_words
            stats = f"‚îÇ üìä {words} —Å–ª–æ–≤ ‚îÇ {tab.buffer.encoding.upper()} ‚îÇ "
            
            # –í—Ä–µ–º—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–ø—Ä–æ—Å—Ç–æ–π —Å—á—ë—Ç—á–∏–∫)
            edit_time = Utils.format_time(int(time.time() - self.last_autosave) % 3600)
            stats += f"‚è±Ô∏è {edit_time} "
            
            # –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω?
            if tab.buffer.modified:
                stats += "‚îÇ ‚óè –ò–∑–º–µ–Ω–µ–Ω–æ "
            
            try:
                self.stdscr.addstr(footer_y, 0, pos_info, footer_bg)
                self.stdscr.addstr(footer_y, self.width - len(stats) - 1, stats, footer_bg)
            except:
                pass
        
        # –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
        if Platform.IS_MOBILE:
            hints = " :s –°–æ—Ö—Ä ‚îÇ :q –í—ã—Ö–æ–¥ ‚îÇ :r –ó–∞–ø—É—Å–∫ ‚îÇ :f –§–∞–π–ª—ã ‚îÇ :ai AI ‚îÇ :h –°–ø—Ä–∞–≤–∫–∞ "
        else:
            hints = " ^S –°–æ—Ö—Ä ‚îÇ ^Q –í—ã—Ö–æ–¥ ‚îÇ F5 –ó–∞–ø—É—Å–∫ ‚îÇ F6 –§–∞–π–ª—ã ‚îÇ ^G Git ‚îÇ F1 –°–ø—Ä–∞–≤–∫–∞ "
        
        hint_color = Colors.get_pair(Colors.BLACK, Colors.CYAN)
        
        try:
            self.stdscr.addstr(status_y, 0, hints.ljust(self.width), hint_color)
        except:
            pass
    
    def _draw_zen_mode(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤ —Ä–µ–∂–∏–º–µ Zen (–º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π)"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        # –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
        margin = max(5, (self.width - 80) // 2)
        text_width = self.width - margin * 2
        
        start_y = 2
        end_y = self.height - 3
        editor_height = end_y - start_y
        
        tab.ensure_cursor_visible(editor_height, text_width, 0)
        
        highlighted = self.highlighter.get_highlighted_lines(tab.buffer, self.theme)
        
        for screen_row in range(editor_height):
            buffer_row = tab.scroll_row + screen_row
            
            if buffer_row >= tab.buffer.line_count:
                break
            
            y = start_y + screen_row
            
            if buffer_row < len(highlighted):
                tokens = highlighted[buffer_row]
                x = margin
                col = tab.scroll_col
                
                for token_text, token_attr in tokens:
                    if col > 0:
                        if len(token_text) <= col:
                            col -= len(token_text)
                            continue
                        token_text = token_text[col:]
                        col = 0
                    
                    if x >= margin + text_width:
                        break
                    
                    visible_text = token_text[:margin + text_width - x]
                    
                    try:
                        self.stdscr.addstr(y, x, visible_text, token_attr)
                        x += len(visible_text)
                    except:
                        pass
            
            if buffer_row == tab.cursor.row:
                cursor_x = margin + tab.cursor.col - tab.scroll_col
                if 0 <= cursor_x < self.width:
                    try:
                        self.stdscr.move(y, cursor_x)
                    except:
                        pass
        
        # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å –≤–Ω–∏–∑—É
        status = f"–°—Ç—Ä–æ–∫–∞ {tab.cursor.row + 1} ‚îÇ {tab.buffer.total_words} —Å–ª–æ–≤"
        try:
            self.stdscr.addstr(self.height - 1, (self.width - len(status)) // 2, status,
                              Colors.get_pair(Colors.CYAN, -1) | curses.A_DIM)
        except:
            pass
    
    def _draw_welcome_screen(self):
        """–≠–∫—Ä–∞–Ω –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è –∫–æ–≥–¥–∞ –Ω–µ—Ç —Ñ–∞–π–ª–æ–≤"""
        center_y = self.height // 2 - 5
        
        lines = [
            ("üöÄ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ DIPO Studio!", Colors.MAGENTA, True),
            ("", 0, False),
            ("–û—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π:", Colors.WHITE, False),
            ("", 0, False),
            ("  :new <–∏–º—è>    - –ù–æ–≤—ã–π —Ñ–∞–π–ª", Colors.GREEN, False),
            ("  :open <–ø—É—Ç—å>  - –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª", Colors.GREEN, False),
            ("  :f            - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤", Colors.GREEN, False),
            ("", 0, False),
            ("–ù–µ–¥–∞–≤–Ω–∏–µ —Ñ–∞–π–ª—ã:", Colors.YELLOW, False),
        ]
        
        # –î–æ–±–∞–≤–∏—Ç—å –Ω–µ–¥–∞–≤–Ω–∏–µ —Ñ–∞–π–ª—ã
        recent = settings.get_recent_files()[:5]
        for f in recent:
            name = os.path.basename(f)
            lines.append((f"  üìÑ {name}", Colors.CYAN, False))
        
        if not recent:
            lines.append(("  (–Ω–µ—Ç –Ω–µ–¥–∞–≤–Ω–∏—Ö —Ñ–∞–π–ª–æ–≤)", Colors.WHITE, False))
        
        for i, (text, color, bold) in enumerate(lines):
            y = center_y + i
            x = (self.width - len(text)) // 2
            
            attr = Colors.get_pair(color, -1)
            if bold:
                attr |= curses.A_BOLD
            
            try:
                self.stdscr.addstr(y, x, text, attr)
            except:
                pass
    
    def _draw_command_line(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
        y = self.height - 1
        
        # –§–æ–Ω
        cmd_bg = Colors.get_pair(Colors.WHITE, Colors.BLUE)
        try:
            self.stdscr.addstr(y, 0, " " * self.width, cmd_bg)
        except:
            pass
        
        # –ü—Ä–æ–º–ø—Ç –∏ –∫–æ–º–∞–Ω–¥–∞
        prompt = ":"
        display_cmd = self.command_buffer
        
        try:
            self.stdscr.addstr(y, 0, prompt, cmd_bg | curses.A_BOLD)
            self.stdscr.addstr(y, 1, display_cmd, cmd_bg)
            self.stdscr.move(y, 1 + self.command_cursor)
        except:
            pass
    
    def _draw_status_message(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        colors = {
            "info": Colors.CYAN,
            "success": Colors.GREEN,
            "warning": Colors.YELLOW,
            "error": Colors.RED
        }
        
        icons = {
            "info": "‚ÑπÔ∏è",
            "success": "‚úÖ",
            "warning": "‚ö†Ô∏è",
            "error": "‚ùå"
        }
        
        color = colors.get(self.status_type, Colors.WHITE)
        icon = icons.get(self.status_type, "")
        
        msg = f" {icon} {self.status_message} "
        x = (self.width - len(msg)) // 2
        y = self.height // 2
        
        try:
            # –§–æ–Ω
            for dy in range(-1, 2):
                self.stdscr.addstr(y + dy, x - 2, " " * (len(msg) + 4),
                                  Colors.get_pair(Colors.BLACK, color))
            
            self.stdscr.addstr(y, x, msg, 
                              Colors.get_pair(Colors.WHITE, color) | curses.A_BOLD)
        except:
            pass
    
    def _handle_input(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞"""
        try:
            key = self.stdscr.getch()
        except:
            return
        
        if key == -1:  # Timeout
            return
        
        # –†–µ–∂–∏–º –∫–æ–º–∞–Ω–¥
        if self.mode == "command":
            self._handle_command_input(key)
            return
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ
        self._handle_normal_input(key)
    
    def _handle_command_input(self, key: int):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –≤ —Ä–µ–∂–∏–º–µ –∫–æ–º–∞–Ω–¥"""
        if key == 27:  # Esc
            self.mode = "normal"
            self.command_buffer = ""
            self.command_cursor = 0
        
        elif key in (10, 13, curses.KEY_ENTER):  # Enter
            self._execute_command(self.command_buffer)
            self.mode = "normal"
            self.command_buffer = ""
            self.command_cursor = 0
        
        elif key in (curses.KEY_BACKSPACE, 127, 8):
            if self.command_cursor > 0:
                self.command_buffer = (self.command_buffer[:self.command_cursor-1] + 
                                       self.command_buffer[self.command_cursor:])
                self.command_cursor -= 1
            elif not self.command_buffer:
                self.mode = "normal"
        
        elif key == curses.KEY_LEFT:
            self.command_cursor = max(0, self.command_cursor - 1)
        
        elif key == curses.KEY_RIGHT:
            self.command_cursor = min(len(self.command_buffer), self.command_cursor + 1)
        
        elif key == curses.KEY_HOME:
            self.command_cursor = 0
        
        elif key == curses.KEY_END:
            self.command_cursor = len(self.command_buffer)
        
        elif 32 <= key <= 126:
            self.command_buffer = (self.command_buffer[:self.command_cursor] + 
                                  chr(key) + 
                                  self.command_buffer[self.command_cursor:])
            self.command_cursor += 1
    
    def _handle_normal_input(self, key: int):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ"""
        tab = self.tab_manager.active_tab
        
        # –ù–∞—á–∞–ª–æ –∫–æ–º–∞–Ω–¥—ã
        if key == ord(':'):
            self.mode = "command"
            self.command_buffer = ""
            self.command_cursor = 0
            return
        
        # Escape
        if key == 27:
            autocomplete = self.plugin_manager.get('autocomplete')
            if autocomplete and autocomplete.is_active:
                autocomplete.hide_popup()
            else:
                multicursor = self.plugin_manager.get('multicursor')
                if multicursor and multicursor.active:
                    multicursor.clear_cursors()
            return
        
        # –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∫–ª–∞–≤–∏—à–∏
        if self._handle_function_keys(key):
            return
        
        # Ctrl –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏
        if self._handle_ctrl_keys(key):
            return
        
        # Alt –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏
        if self._handle_alt_keys(key):
            return
        
        # –ù–∞–≤–∏–≥–∞—Ü–∏—è –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        if tab:
            self._handle_editing_keys(key, tab)
    
    def _handle_function_keys(self, key: int) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ F-–∫–ª–∞–≤–∏—à"""
        if key == curses.KEY_F1:  # F1 - –°–ø—Ä–∞–≤–∫–∞
            self._show_help()
            return True
        
        elif key == curses.KEY_F2:  # F2 - Zen mode
            self.zen_mode = not self.zen_mode
            return True
        
        elif key == curses.KEY_F3:  # F3 - –ù–∞–π—Ç–∏ —Å–ª–µ–¥—É—é—â–µ–µ
            self._find_next()
            return True
        
        elif key == curses.KEY_F4:  # F4 - –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É
            self._change_theme()
            return True
        
        elif key == curses.KEY_F5:  # F5 - –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥
            self._run_code()
            return True
        
        elif key == curses.KEY_F6:  # F6 - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫
            self._show_file_explorer()
            return True
        
        elif key == curses.KEY_F7:  # F7 - –õ–∏–Ω—Ç–µ—Ä
            linter = self.plugin_manager.get('linter')
            if linter:
                linter.show_errors_dialog()
            return True
        
        elif key == curses.KEY_F8:  # F8 - –°–ª–µ–¥—É—é—â–∞—è –æ—à–∏–±–∫–∞
            self._goto_next_error()
            return True
        
        elif key == curses.KEY_F9:  # F9 - –°–Ω–∏–ø–ø–µ—Ç—ã
            snippets = self.plugin_manager.get('snippets')
            if snippets:
                snippets.show_snippets_menu()
            return True
        
        elif key == curses.KEY_F10:  # F10 - –ú–µ–Ω—é
            self._show_main_menu()
            return True
        
        elif key == curses.KEY_F11:  # F11 - –ü–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω / Zen
            self.zen_mode = not self.zen_mode
            return True
        
        elif key == curses.KEY_F12:  # F12 - –¢–µ—Ä–º–∏–Ω–∞–ª
            terminal = self.plugin_manager.get('terminal')
            if terminal:
                terminal.show()
            return True
        
        return False
    
    def _handle_ctrl_keys(self, key: int) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Ctrl –∫–æ–º–±–∏–Ω–∞—Ü–∏–π"""
        tab = self.tab_manager.active_tab
        
        # Ctrl+S - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
        if key == ord('s') - 96 or key == 19:
            self._save_file()
            return True
        
        # Ctrl+Q - –í—ã–π—Ç–∏
        elif key == ord('q') - 96 or key == 17:
            if self._confirm_exit():
                self.running = False
            return True
        
        # Ctrl+W - –ó–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É
        elif key == ord('w') - 96 or key == 23:
            self._close_tab()
            return True
        
        # Ctrl+N - –ù–æ–≤—ã–π —Ñ–∞–π–ª
        elif key == ord('n') - 96 or key == 14:
            self.tab_manager.new_tab()
            return True
        
        # Ctrl+O - –û—Ç–∫—Ä—ã—Ç—å
        elif key == ord('o') - 96 or key == 15:
            self._open_file_dialog()
            return True
        
        # Ctrl+Z - –û—Ç–º–µ–Ω–∏—Ç—å
        elif key == ord('z') - 96 or key == 26:
            if tab:
                tab.history.undo(tab.buffer, tab.cursor)
            return True
        
        # Ctrl+Y - –ü–æ–≤—Ç–æ—Ä–∏—Ç—å
        elif key == ord('y') - 96 or key == 25:
            if tab:
                tab.history.redo(tab.buffer, tab.cursor)
            return True
        
        # Ctrl+C - –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
        elif key == ord('c') - 96 or key == 3:
            self._copy()
            return True
        
        # Ctrl+X - –í—ã—Ä–µ–∑–∞—Ç—å
        elif key == ord('x') - 96 or key == 24:
            self._cut()
            return True
        
        # Ctrl+V - –í—Å—Ç–∞–≤–∏—Ç—å
        elif key == ord('v') - 96 or key == 22:
            self._paste()
            return True
        
        # Ctrl+A - –í—ã–¥–µ–ª–∏—Ç—å –≤—Å—ë
        elif key == ord('a') - 96 or key == 1:
            if tab:
                tab.cursor.selection_start = (0, 0)
                tab.cursor.move_file_end(tab.buffer)
            return True
        
        # Ctrl+F - –ü–æ–∏—Å–∫
        elif key == ord('f') - 96 or key == 6:
            self._show_search()
            return True
        
        # Ctrl+H - –ó–∞–º–µ–Ω–∞
        elif key == ord('h') - 96 or key == 8:
            self._show_replace()
            return True
        
        # Ctrl+G - Git / –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ
        elif key == ord('g') - 96 or key == 7:
            git = self.plugin_manager.get('git')
            if git:
                git.show_menu()
            return True
        
        # Ctrl+D - –î–æ–±–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        elif key == ord('d') - 96 or key == 4:
            multicursor = self.plugin_manager.get('multicursor')
            if multicursor:
                multicursor.add_cursor_at_next_occurrence()
            return True
        
        # Ctrl+/ - –ö–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
        elif key == ord('/') - 96 or key == 31:
            comments = self.plugin_manager.get('comments')
            if comments:
                comments.toggle_comment()
            return True
        
        # Ctrl+B - –ó–∞–∫–ª–∞–¥–∫–∞
        elif key == ord('b') - 96 or key == 2:
            bookmarks = self.plugin_manager.get('bookmarks')
            if bookmarks:
                bookmarks.toggle_bookmark()
            return True
        
        # Ctrl+M - –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞
        elif key == ord('m') - 96 or key == 13:
            minimap = self.plugin_manager.get('minimap')
            if minimap:
                minimap.toggle()
            return True
        
        # Ctrl+Space - –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
        elif key == 0:
            autocomplete = self.plugin_manager.get('autocomplete')
            if autocomplete:
                autocomplete.show_popup()
            return True
        
        # Ctrl+Tab - –°–ª–µ–¥—É—é—â–∞—è –≤–∫–ª–∞–¥–∫–∞
        elif key == 9 and (curses.A_NORMAL):  # Tab
            pass  # –û–±—Ä–∞–±–æ—Ç–∫–∞ Tab –æ—Ç–¥–µ–ª—å–Ω–æ
        
        return False
    
    def _handle_alt_keys(self, key: int) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ Alt –∫–æ–º–±–∏–Ω–∞—Ü–∏–π"""
        # Alt –æ–±—ã—á–Ω–æ = Esc + –∫–ª–∞–≤–∏—à–∞
        # –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ–º —Å–ª–æ–∂–Ω—ã–µ Alt-–∫–æ–º–±–∏–Ω–∞—Ü–∏–∏
        return False
    
    def _handle_editing_keys(self, key: int, tab: Tab):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
        cursor = tab.cursor
        buffer = tab.buffer
        
        # –°—Ç—Ä–µ–ª–∫–∏
        if key == curses.KEY_UP:
            cursor.move_up(buffer)
        
        elif key == curses.KEY_DOWN:
            cursor.move_down(buffer)
        
        elif key == curses.KEY_LEFT:
            cursor.move_left(buffer)
        
        elif key == curses.KEY_RIGHT:
            cursor.move_right(buffer)
        
        # Home/End
        elif key == curses.KEY_HOME:
            cursor.move_home(buffer)
        
        elif key == curses.KEY_END:
            cursor.move_end(buffer)
        
        # Page Up/Down
        elif key == curses.KEY_PPAGE:
            height = self.height - 3
            for _ in range(height):
                cursor.move_up(buffer)
        
        elif key == curses.KEY_NPAGE:
            height = self.height - 3
            for _ in range(height):
                cursor.move_down(buffer)
        
        # Backspace
        elif key in (curses.KEY_BACKSPACE, 127, 8):
            if cursor.has_selection():
                self._delete_selection(tab)
            else:
                brackets = self.plugin_manager.get('brackets')
                if brackets and brackets.handle_backspace(tab):
                    pass  # –ü–∞—Ä–∞ —Å–∫–æ–±–æ–∫ —É–¥–∞–ª–µ–Ω–∞
                elif cursor.col > 0 or cursor.row > 0:
                    buffer.delete_char(cursor.row, cursor.col)
                    cursor.move_left(buffer)
        
        # Delete
        elif key == curses.KEY_DC:
            if cursor.has_selection():
                self._delete_selection(tab)
            else:
                buffer.delete_char_forward(cursor.row, cursor.col)
        
        # Enter
        elif key in (10, 13, curses.KEY_ENTER):
            indent_plugin = self.plugin_manager.get('indent')
            
            if cursor.has_selection():
                self._delete_selection(tab)
            
            # –í—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
            indent = buffer.insert_newline(cursor.row, cursor.col)
            cursor.row += 1
            
            # –£–º–Ω—ã–π –æ—Ç—Å—Ç—É–ø
            if indent_plugin:
                smart_indent = indent_plugin.calculate_indent(tab, cursor.row)
                if smart_indent:
                    line = buffer.get_line(cursor.row)
                    buffer.set_line(cursor.row, smart_indent + line.lstrip())
                    cursor.col = len(smart_indent)
                else:
                    cursor.col = indent
            else:
                cursor.col = indent
        
        # Tab
        elif key == 9:
            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–∏–ø–ø–µ—Ç—ã
            snippets = self.plugin_manager.get('snippets')
            if snippets:
                line = buffer.get_line(cursor.row)
                # –ù–∞–π—Ç–∏ —Å–ª–æ–≤–æ –ø–µ—Ä–µ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
                word_start = cursor.col
                while word_start > 0 and (line[word_start-1].isalnum() or line[word_start-1] == '_'):
                    word_start -= 1
                word = line[word_start:cursor.col]
                
                if word and snippets.expand_snippet(tab, word):
                    return
            
            # –û–±—ã—á–Ω—ã–π Tab
            indent_plugin = self.plugin_manager.get('indent')
            if indent_plugin:
                indent_str = indent_plugin.get_indent_string()
            else:
                indent_str = "    "
            
            buffer.insert_char(cursor.row, cursor.col, indent_str)
            cursor.col += len(indent_str)
        
        # –û–±—ã—á–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
        elif 32 <= key <= 126:
            char = chr(key)
            
            if cursor.has_selection():
                self._delete_selection(tab)
            
            # –ê–≤—Ç–æ-—Å–∫–æ–±–∫–∏
            brackets = self.plugin_manager.get('brackets')
            if brackets:
                result = brackets.handle_char(char, tab)
                if result == "SKIP":
                    cursor.move_right(buffer)
                    return
                elif result:
                    buffer.insert_char(cursor.row, cursor.col, char)
                    cursor.col += 1
                    buffer.insert_char(cursor.row, cursor.col, result)
                    return
            
            buffer.insert_char(cursor.row, cursor.col, char)
            cursor.col += 1
        
        # Unicode —Å–∏–º–≤–æ–ª—ã
        elif key > 127:
            try:
                char = chr(key)
                buffer.insert_char(cursor.row, cursor.col, char)
                cursor.col += 1
            except:
                pass


print("‚úÖ –ß–∞—Å—Ç—å 6/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: PluginManager, SplashScreen, Editor (–æ—Å–Ω–æ–≤–∞)")

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –ú–ï–¢–û–î–´ –ö–û–ú–ê–ù–î (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –∫–ª–∞—Å—Å–∞ Editor)
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _execute_command(self, cmd: str):
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –∏–∑ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
        cmd = cmd.strip()
        
        if not cmd:
            return
        
        # –†–∞–∑–±–æ—Ä –∫–æ–º–∞–Ω–¥—ã –∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
        parts = cmd.split(None, 1)
        command = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ""
        
        # –ú–æ–±–∏–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
        full_cmd = ":" + cmd
        if full_cmd in MOBILE_COMMANDS:
            action = MOBILE_COMMANDS[full_cmd]
            self._execute_action(action, args)
            return
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ–º–∞–Ω–¥—ã
        for mobile_cmd, action in MOBILE_COMMANDS.items():
            if mobile_cmd.startswith(":" + command):
                self._execute_action(action, args)
                return
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
        if command in ("q", "quit", "exit"):
            if self._confirm_exit():
                self.running = False
        
        elif command in ("q!", "quit!"):
            self.running = False
        
        elif command in ("w", "s", "save"):
            self._save_file(args if args else None)
        
        elif command in ("wq", "x"):
            self._save_file()
            if self._confirm_exit():
                self.running = False
        
        elif command in ("e", "edit", "open"):
            if args:
                self.tab_manager.open_file(args)
            else:
                self._open_file_dialog()
        
        elif command in ("new", "n"):
            tab = self.tab_manager.new_tab()
            if args:
                tab.buffer.filename = os.path.abspath(args)
                tab.buffer.detect_language()
        
        elif command == "close":
            self._close_tab()
        
        elif command in ("h", "help"):
            self._show_help()
        
        elif command in ("f", "files", "explorer"):
            self._show_file_explorer()
        
        elif command in ("r", "run"):
            self._run_code()
        
        elif command in ("t", "theme"):
            if args:
                self._set_theme(args)
            else:
                self._change_theme()
        
        elif command in ("g", "goto"):
            if args:
                try:
                    line = int(args)
                    self._goto_line(line)
                except ValueError:
                    self._show_message("–£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏", "error")
            else:
                self._show_goto_dialog()
        
        elif command == "find":
            self._show_search(args)
        
        elif command == "replace":
            self._show_replace()
        
        elif command in ("ai",):
            if args == "setup":
                ai = self.plugin_manager.get('ai')
                if ai:
                    ai.show_setup_wizard()
            elif args:
                self._ai_query(args)
            else:
                ai = self.plugin_manager.get('ai')
                if ai:
                    ai.show_ai_chat()
        
        elif command == "build":
            apk = self.plugin_manager.get('apk_builder')
            if apk:
                apk.show_build_menu()
        
        elif command == "git":
            git = self.plugin_manager.get('git')
            if git:
                git.show_menu()
        
        elif command == "term" or command == "terminal":
            terminal = self.plugin_manager.get('terminal')
            if terminal:
                terminal.show()
        
        elif command == "format":
            formatter = self.plugin_manager.get('formatter')
            if formatter:
                if formatter.format_current():
                    self._show_message("–ö–æ–¥ –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω", "success")
                else:
                    self._show_message("–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è", "error")
        
        elif command == "lint":
            linter = self.plugin_manager.get('linter')
            if linter:
                linter.show_errors_dialog()
        
        elif command == "snippets":
            snippets = self.plugin_manager.get('snippets')
            if snippets:
                snippets.show_snippets_menu()
        
        elif command == "bookmarks":
            bookmarks = self.plugin_manager.get('bookmarks')
            if bookmarks:
                bookmarks.show_bookmarks()
        
        elif command == "fold":
            folding = self.plugin_manager.get('folding')
            if folding:
                folding.toggle_fold()
        
        elif command == "foldall":
            folding = self.plugin_manager.get('folding')
            if folding:
                folding.fold_all()
        
        elif command == "unfoldall":
            folding = self.plugin_manager.get('folding')
            if folding:
                folding.unfold_all()
        
        elif command == "mini" or command == "minimap":
            minimap = self.plugin_manager.get('minimap')
            if minimap:
                minimap.toggle()
        
        elif command == "zen":
            self.zen_mode = not self.zen_mode
        
        elif command == "plugins":
            self._show_plugins_list()
        
        elif command == "settings":
            self._show_settings()
        
        elif command == "doctor":
            self._show_doctor()
        
        elif command == "about":
            self._show_about()
        
        elif command == "reload":
            tab = self.tab_manager.active_tab
            if tab and tab.buffer.filename:
                tab.load_file(tab.buffer.filename)
                self._show_message("–§–∞–π–ª –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω", "success")
        
        elif command == "encoding":
            if args:
                tab = self.tab_manager.active_tab
                if tab:
                    tab.buffer.encoding = args.upper()
                    self._show_message(f"–ö–æ–¥–∏—Ä–æ–≤–∫–∞: {args.upper()}", "info")
        
        elif command == "set":
            self._handle_set_command(args)
        
        elif command.isdigit():
            self._goto_line(int(command))
        
        else:
            self._show_message(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: {command}", "error")
    
    def _execute_action(self, action: str, args: str = ""):
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ –∏–º–µ–Ω–∏"""
        actions = {
            "save": lambda: self._save_file(),
            "quit": lambda: self._try_quit(),
            "save_quit": lambda: (self._save_file(), self._try_quit()),
            "force_quit": lambda: setattr(self, 'running', False),
            "help": lambda: self._show_help(),
            "zen": lambda: setattr(self, 'zen_mode', not self.zen_mode),
            "theme": lambda: self._change_theme(),
            "run": lambda: self._run_code(),
            "files": lambda: self._show_file_explorer(),
            "lint": lambda: self.plugin_manager.get('linter').show_errors_dialog() if self.plugin_manager.get('linter') else None,
            "goto": lambda: self._show_goto_dialog(),
            "search": lambda: self._show_search(args),
            "replace": lambda: self._show_replace(),
            "ai_menu": lambda: self.plugin_manager.get('ai').show_ai_chat() if self.plugin_manager.get('ai') else None,
            "ai_setup": lambda: self.plugin_manager.get('ai').show_setup_wizard() if self.plugin_manager.get('ai') else None,
            "build_apk": lambda: self.plugin_manager.get('apk_builder').show_build_menu() if self.plugin_manager.get('apk_builder') else None,
            "git_menu": lambda: self.plugin_manager.get('git').show_menu() if self.plugin_manager.get('git') else None,
            "new_file": lambda: self.tab_manager.new_tab(),
            "open_file": lambda: self._open_file_dialog(),
            "close_tab": lambda: self._close_tab(),
            "show_tabs": lambda: self._show_tabs_menu(),
            "plugins": lambda: self._show_plugins_list(),
            "settings": lambda: self._show_settings(),
            "undo": lambda: self._undo(),
            "redo": lambda: self._redo(),
            "copy": lambda: self._copy(),
            "paste": lambda: self._paste(),
            "cut": lambda: self._cut(),
            "comment": lambda: self.plugin_manager.get('comments').toggle_comment() if self.plugin_manager.get('comments') else None,
            "format": lambda: self.plugin_manager.get('formatter').format_current() if self.plugin_manager.get('formatter') else None,
            "fold": lambda: self.plugin_manager.get('folding').toggle_fold() if self.plugin_manager.get('folding') else None,
            "unfold": lambda: self.plugin_manager.get('folding').unfold_all() if self.plugin_manager.get('folding') else None,
            "minimap": lambda: self.plugin_manager.get('minimap').toggle() if self.plugin_manager.get('minimap') else None,
            "terminal": lambda: self.plugin_manager.get('terminal').show() if self.plugin_manager.get('terminal') else None,
            "snippets": lambda: self.plugin_manager.get('snippets').show_snippets_menu() if self.plugin_manager.get('snippets') else None,
            "bookmark": lambda: self.plugin_manager.get('bookmarks').toggle_bookmark() if self.plugin_manager.get('bookmarks') else None,
            "doctor": lambda: self._show_doctor(),
        }
        
        if action in actions:
            try:
                actions[action]()
            except Exception as e:
                self._show_message(f"–û—à–∏–±–∫–∞: {str(e)}", "error")
    
    def _handle_set_command(self, args: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã :set"""
        if not args:
            self._show_settings()
            return
        
        parts = args.split("=", 1)
        key = parts[0].strip()
        value = parts[1].strip() if len(parts) > 1 else "true"
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
        if value.lower() in ("true", "yes", "on", "1"):
            value = True
        elif value.lower() in ("false", "no", "off", "0"):
            value = False
        elif value.isdigit():
            value = int(value)
        
        settings.set(key, value)
        self._show_message(f"{key} = {value}", "info")
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –î–ò–ê–õ–û–ì–ò –ò –î–ï–ô–°–¢–í–ò–Ø
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _save_file(self, filename: str = None):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        if filename:
            success, msg = tab.save_file(filename)
        elif tab.buffer.filename:
            success, msg = tab.save_file()
        else:
            # –ó–∞–ø—Ä–æ—Å–∏—Ç—å –∏–º—è —Ñ–∞–π–ª–∞
            dialog = InputDialog(self.stdscr, "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫", "–ò–º—è —Ñ–∞–π–ª–∞:")
            new_name = dialog.show()
            if new_name:
                success, msg = tab.save_file(new_name)
            else:
                return
        
        if success:
            self._show_message("–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω", "success")
        else:
            self._show_message(msg, "error")
    
    def _open_file_dialog(self):
        """–û—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞"""
        dialog = InputDialog(self.stdscr, "üìÇ –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª", "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É:")
        filename = dialog.show()
        
        if filename:
            filename = os.path.expanduser(filename)
            if self.tab_manager.open_file(filename):
                self._show_message(f"–û—Ç–∫—Ä—ã—Ç: {os.path.basename(filename)}", "success")
            else:
                self._show_message("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª", "error")
    
    def _close_tab(self):
        """–ó–∞–∫—Ä—ã—Ç—å —Ç–µ–∫—É—â—É—é –≤–∫–ª–∞–¥–∫—É"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        if tab.buffer.modified:
            dialog = ConfirmDialog(
                self.stdscr,
                "‚ö†Ô∏è –ù–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è",
                f"–°–æ—Ö—Ä–∞–Ω–∏—Ç—å '{tab.title}' –ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã—Ç–∏–µ–º?",
                ["–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", "–ù–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å", "–û—Ç–º–µ–Ω–∞"]
            )
            choice = dialog.show()
            
            if choice == 0:  # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
                self._save_file()
                self.tab_manager.close_tab()
            elif choice == 1:  # –ù–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å
                tab.buffer.modified = False
                self.tab_manager.close_tab()
            # else: –û—Ç–º–µ–Ω–∞ - –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        else:
            self.tab_manager.close_tab()
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –≤–∫–ª–∞–¥–æ–∫ - —Å–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç—É—é
        if not self.tab_manager.tabs:
            self.tab_manager.new_tab()
    
    def _try_quit(self):
        """–ü–æ–ø—ã—Ç–∫–∞ –≤—ã—Ö–æ–¥–∞"""
        if self._confirm_exit():
            self.running = False
    
    def _confirm_exit(self) -> bool:
        """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–∞"""
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        unsaved = [tab for tab in self.tab_manager.tabs if tab.buffer.modified]
        
        if not unsaved:
            return True
        
        names = ", ".join(tab.title for tab in unsaved[:3])
        if len(unsaved) > 3:
            names += f" –∏ –µ—â—ë {len(unsaved) - 3}"
        
        dialog = ConfirmDialog(
            self.stdscr,
            "‚ö†Ô∏è –ù–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è",
            f"–ï—Å—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã: {names}. –í—ã–π—Ç–∏ –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è?",
            ["–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ", "–í—ã–π—Ç–∏ –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è", "–û—Ç–º–µ–Ω–∞"]
        )
        choice = dialog.show()
        
        if choice == 0:  # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ
            for tab in unsaved:
                if tab.buffer.filename:
                    tab.save_file()
                else:
                    self.tab_manager.active_index = self.tab_manager.tabs.index(tab)
                    self._save_file()
            return True
        elif choice == 1:  # –í—ã–π—Ç–∏ –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            return True
        
        return False
    
    def _show_file_explorer(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤"""
        explorer = self.plugin_manager.get('file_explorer')
        if explorer:
            result = explorer.show()
            if result:
                self.tab_manager.open_file(result)
    
    def _run_code(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥"""
        runner = self.plugin_manager.get('runner')
        if runner:
            success, output = runner.run_current_file()
            runner.show_output_dialog(output, success)
    
    def _show_search(self, initial_text: str = ""):
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –ø–æ–∏—Å–∫–∞"""
        dialog = SearchDialog(self.stdscr, replace_mode=False)
        if initial_text:
            dialog.search_text = initial_text
        
        result = dialog.show()
        
        if result and result.get("search"):
            self.search_text = result["search"]
            self._find_all(
                result["search"],
                result.get("case_sensitive", False),
                result.get("whole_word", False),
                result.get("regex", False)
            )
            self._find_next()
    
    def _show_replace(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∑–∞–º–µ–Ω—ã"""
        dialog = SearchDialog(self.stdscr, replace_mode=True)
        result = dialog.show()
        
        if result and result.get("search"):
            self._replace_all(
                result["search"],
                result.get("replace", ""),
                result.get("case_sensitive", False),
                result.get("whole_word", False),
                result.get("regex", False)
            )
    
    def _find_all(self, text: str, case_sensitive: bool = False, 
                  whole_word: bool = False, regex: bool = False):
        """–ù–∞–π—Ç–∏ –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        self.search_results = []
        
        for row, line in enumerate(tab.buffer.lines):
            search_line = line if case_sensitive else line.lower()
            search_text = text if case_sensitive else text.lower()
            
            if regex:
                try:
                    flags = 0 if case_sensitive else re.IGNORECASE
                    for match in re.finditer(text, line, flags):
                        self.search_results.append((row, match.start()))
                except re.error:
                    pass
            else:
                start = 0
                while True:
                    idx = search_line.find(search_text, start)
                    if idx == -1:
                        break
                    
                    if whole_word:
                        before_ok = idx == 0 or not line[idx-1].isalnum()
                        after_ok = idx + len(text) >= len(line) or not line[idx + len(text)].isalnum()
                        if not (before_ok and after_ok):
                            start = idx + 1
                            continue
                    
                    self.search_results.append((row, idx))
                    start = idx + 1
        
        self.search_index = 0
        
        if self.search_results:
            self._show_message(f"–ù–∞–π–¥–µ–Ω–æ: {len(self.search_results)} —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π", "info")
        else:
            self._show_message("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "warning")
    
    def _find_next(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –ø–æ–∏—Å–∫–∞"""
        tab = self.tab_manager.active_tab
        if not tab or not self.search_results:
            return
        
        # –ù–∞–π—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–π –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
        current_pos = (tab.cursor.row, tab.cursor.col)
        
        for i, (row, col) in enumerate(self.search_results):
            if (row, col) > current_pos:
                self.search_index = i
                tab.cursor.move_to(row, col, tab.buffer)
                return
        
        # –ù–∞—á–∞—Ç—å —Å–Ω–∞—á–∞–ª–∞
        if self.search_results:
            self.search_index = 0
            row, col = self.search_results[0]
            tab.cursor.move_to(row, col, tab.buffer)
    
    def _find_prev(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –ø–æ–∏—Å–∫–∞"""
        tab = self.tab_manager.active_tab
        if not tab or not self.search_results:
            return
        
        current_pos = (tab.cursor.row, tab.cursor.col)
        
        for i in range(len(self.search_results) - 1, -1, -1):
            row, col = self.search_results[i]
            if (row, col) < current_pos:
                self.search_index = i
                tab.cursor.move_to(row, col, tab.buffer)
                return
        
        # –° –∫–æ–Ω—Ü–∞
        if self.search_results:
            self.search_index = len(self.search_results) - 1
            row, col = self.search_results[self.search_index]
            tab.cursor.move_to(row, col, tab.buffer)
    
    def _replace_all(self, search: str, replace: str, case_sensitive: bool = False,
                     whole_word: bool = False, regex: bool = False):
        """–ó–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        count = 0
        
        for row in range(tab.buffer.line_count):
            line = tab.buffer.get_line(row)
            original = line
            
            if regex:
                try:
                    flags = 0 if case_sensitive else re.IGNORECASE
                    new_line, n = re.subn(search, replace, line, flags=flags)
                    if n > 0:
                        tab.buffer.set_line(row, new_line)
                        count += n
                except re.error:
                    pass
            else:
                if case_sensitive:
                    new_line = line.replace(search, replace)
                else:
                    # Case-insensitive replace
                    pattern = re.compile(re.escape(search), re.IGNORECASE)
                    new_line = pattern.sub(replace, line)
                
                if new_line != original:
                    tab.buffer.set_line(row, new_line)
                    count += line.lower().count(search.lower())
        
        if count > 0:
            self._show_message(f"–ó–∞–º–µ–Ω–µ–Ω–æ: {count} –≤—Ö–æ–∂–¥–µ–Ω–∏–π", "success")
        else:
            self._show_message("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è –∑–∞–º–µ–Ω—ã", "warning")
    
    def _show_goto_dialog(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Å—Ç—Ä–æ–∫–µ"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        dialog = InputDialog(
            self.stdscr,
            "üìç –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ",
            f"–ù–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ (1-{tab.buffer.line_count}):"
        )
        result = dialog.show()
        
        if result:
            try:
                line = int(result)
                self._goto_line(line)
            except ValueError:
                self._show_message("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ", "error")
    
    def _goto_line(self, line: int):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        line = max(1, min(line, tab.buffer.line_count))
        tab.cursor.move_to(line - 1, 0, tab.buffer)
    
    def _goto_next_error(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–π –æ—à–∏–±–∫–µ"""
        linter = self.plugin_manager.get('linter')
        if not linter:
            return
        
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        errors = linter.errors.get(tab.id, [])
        if not errors:
            linter.lint_current()
            errors = linter.errors.get(tab.id, [])
        
        if not errors:
            self._show_message("–û—à–∏–±–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "success")
            return
        
        current_line = tab.cursor.row + 1
        
        for err in errors:
            if err["line"] > current_line:
                tab.cursor.move_to(err["line"] - 1, err.get("col", 0), tab.buffer)
                self._show_message(err["message"], "warning")
                return
        
        # –° –Ω–∞—á–∞–ª–∞
        err = errors[0]
        tab.cursor.move_to(err["line"] - 1, err.get("col", 0), tab.buffer)
        self._show_message(err["message"], "warning")
    
    def _change_theme(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ç–µ–º—ã"""
        theme_names = list(THEMES.keys())
        items = [THEMES[t].get("name", t) for t in theme_names]
        icons = ["üé®"] * len(items)
        
        dialog = ListDialog(self.stdscr, "üé® –í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É", items, icons)
        choice = dialog.show()
        
        if choice is not None:
            self._set_theme(theme_names[choice])
    
    def _set_theme(self, theme_name: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–º—É"""
        if theme_name in THEMES:
            self.theme_name = theme_name
            self.theme = THEMES[theme_name]
            settings.set("theme", theme_name)
            self._show_message(f"–¢–µ–º–∞: {self.theme.get('name', theme_name)}", "success")
        else:
            self._show_message(f"–¢–µ–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {theme_name}", "error")
    
    def _copy(self):
        """–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        if tab.cursor.has_selection():
            selection = tab.cursor.get_selection_range()
            if selection:
                text = tab.buffer.get_selection(selection[0], selection[1])
                self.clipboard.copy(text)
                self._show_message("–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ", "info")
        else:
            # –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—Å—é —Å—Ç—Ä–æ–∫—É
            line = tab.buffer.get_line(tab.cursor.row)
            self.clipboard.copy(line + "\n")
            self._show_message("–°—Ç—Ä–æ–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞", "info")
    
    def _cut(self):
        """–í—ã—Ä–µ–∑–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        if tab.cursor.has_selection():
            selection = tab.cursor.get_selection_range()
            if selection:
                text = tab.buffer.get_selection(selection[0], selection[1])
                self.clipboard.copy(text)
                self._delete_selection(tab)
                self._show_message("–í—ã—Ä–µ–∑–∞–Ω–æ", "info")
        else:
            # –í—ã—Ä–µ–∑–∞—Ç—å –≤—Å—é —Å—Ç—Ä–æ–∫—É
            line = tab.buffer.get_line(tab.cursor.row)
            self.clipboard.copy(line + "\n")
            tab.buffer.delete_line(tab.cursor.row)
            self._show_message("–°—Ç—Ä–æ–∫–∞ –≤—ã—Ä–µ–∑–∞–Ω–∞", "info")
    
    def _paste(self):
        """–í—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –∏–∑ –±—É—Ñ–µ—Ä–∞"""
        tab = self.tab_manager.active_tab
        if not tab:
            return
        
        text = self.clipboard.paste()
        if not text:
            return
        
        if tab.cursor.has_selection():
            self._delete_selection(tab)
        
        new_pos = tab.buffer.insert_text(tab.cursor.row, tab.cursor.col, text)
        tab.cursor.move_to(new_pos[0], new_pos[1], tab.buffer)
    
    def _delete_selection(self, tab: Tab):
        """–£–¥–∞–ª–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç"""
        selection = tab.cursor.get_selection_range()
        if selection:
            tab.buffer.delete_selection(selection[0], selection[1])
            tab.cursor.move_to(selection[0][0], selection[0][1], tab.buffer)
            tab.cursor.end_selection()
    
    def _undo(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ"""
        tab = self.tab_manager.active_tab
        if tab:
            if tab.history.undo(tab.buffer, tab.cursor):
                self._show_message("–û—Ç–º–µ–Ω–µ–Ω–æ", "info")
    
    def _redo(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ"""
        tab = self.tab_manager.active_tab
        if tab:
            if tab.history.redo(tab.buffer, tab.cursor):
                self._show_message("–ü–æ–≤—Ç–æ—Ä–µ–Ω–æ", "info")
    
    def _ai_query(self, query: str):
        """–ó–∞–ø—Ä–æ—Å –∫ AI"""
        ai = self.plugin_manager.get('ai')
        if not ai:
            self._show_message("AI –ø–ª–∞–≥–∏–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
            return
        
        if not ai.is_configured():
            ai.show_setup_wizard()
            return
        
        self._show_message("‚è≥ AI –¥—É–º–∞–µ—Ç...", "info")
        self.stdscr.refresh()
        
        response = ai.query(query)
        
        # –ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–≤–µ—Ç –≤ –¥–∏–∞–ª–æ–≥–µ
        height, width = self.stdscr.getmaxyx()
        dialog_height = min(height - 4, 20)
        dialog_width = min(width - 4, 70)
        y, x = Dialog.center_pos(height, width, dialog_height, dialog_width)
        
        lines = []
        for line in response.split('\n'):
            while len(line) > dialog_width - 4:
                lines.append(line[:dialog_width - 4])
                line = line[dialog_width - 4:]
            lines.append(line)
        
        scroll = 0
        max_scroll = max(0, len(lines) - dialog_height + 4)
        
        while True:
            for i in range(dialog_height):
                try:
                    self.stdscr.addstr(y + i, x, " " * dialog_width)
                except:
                    pass
            
            Dialog.draw_box(self.stdscr, y, x, dialog_height, dialog_width,
                           "ü§ñ AI –û—Ç–≤–µ—Ç", Colors.get_pair(Colors.GREEN, -1))
            
            for i, line in enumerate(lines[scroll:scroll + dialog_height - 4]):
                try:
                    self.stdscr.addstr(y + 2 + i, x + 2, line[:dialog_width - 4])
                except:
                    pass
            
            try:
                self.stdscr.addstr(y + dialog_height - 1, x + 2,
                                  " [‚Üë‚Üì] –°–∫—Ä–æ–ª–ª [Enter/Esc] –ó–∞–∫—Ä—ã—Ç—å [C] –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å ",
                                  Colors.get_pair(Colors.CYAN, -1))
            except:
                pass
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key in (27, 10, 13, ord('q')):
                break
            elif key == curses.KEY_UP:
                scroll = max(0, scroll - 1)
            elif key == curses.KEY_DOWN:
                scroll = min(max_scroll, scroll + 1)
            elif key in (ord('c'), ord('C')):
                self.clipboard.copy(response)
                self._show_message("–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä", "success")
    
    def _show_tabs_menu(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –≤–∫–ª–∞–¥–æ–∫"""
        if not self.tab_manager.tabs:
            return
        
        items = []
        for i, tab in enumerate(self.tab_manager.tabs):
            marker = "‚óè" if tab.buffer.modified else " "
            items.append(f"{marker} {tab.icon} {tab.title}")
        
        dialog = ListDialog(self.stdscr, "üìë –í–∫–ª–∞–¥–∫–∏", items)
        dialog.selected = self.tab_manager.active_index
        
        choice = dialog.show()
        
        if choice is not None:
            self.tab_manager.active_index = choice
    
    def _show_plugins_list(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–≥–∏–Ω–æ–≤"""
        plugins = self.plugin_manager.list_plugins()
        
        items = []
        for p in plugins:
            status = "‚úÖ" if p["enabled"] else "‚ùå"
            items.append(f"{status} {p['name']} - {p['description']}")
        
        dialog = ListDialog(self.stdscr, "üîå –ü–ª–∞–≥–∏–Ω—ã", items)
        dialog.show()
    
    def _show_settings(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        items = [
            f"–¢–µ–º–∞: {self.theme.get('name', self.theme_name)}",
            f"–†–∞–∑–º–µ—Ä —Ç–∞–±–∞: {settings.get('tab_size', 4)}",
            f"–ü—Ä–æ–±–µ–ª—ã –≤–º–µ—Å—Ç–æ —Ç–∞–±–æ–≤: {'–î–∞' if settings.get('use_spaces', True) else '–ù–µ—Ç'}",
            f"–ê–≤—Ç–æ–æ—Ç—Å—Ç—É–ø: {'–î–∞' if settings.get('auto_indent', True) else '–ù–µ—Ç'}",
            f"–ê–≤—Ç–æ—Å–∫–æ–±–∫–∏: {'–î–∞' if settings.get('auto_pairs', True) else '–ù–µ—Ç'}",
            f"–ù–æ–º–µ—Ä–∞ —Å—Ç—Ä–æ–∫: {'–î–∞' if settings.get('show_line_numbers', True) else '–ù–µ—Ç'}",
            f"–ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏: {'–î–∞' if settings.get('highlight_current_line', True) else '–ù–µ—Ç'}",
            f"–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: {'–î–∞' if settings.get('autosave', True) else '–ù–µ—Ç'}",
            f"–ò–Ω—Ç–µ—Ä–≤–∞–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä.: {settings.get('autosave_interval', 60)}—Å",
            f"–ö–æ–¥–∏—Ä–æ–≤–∫–∞: {settings.get('encoding', 'utf-8')}",
        ]
        
        dialog = ListDialog(self.stdscr, "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", items)
        dialog.show()
    
    def _show_doctor(self):
        """–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã"""
        lines = [
            "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó",
            "‚ïë           üè• –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê DIPO STUDIO             ‚ïë",
            "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£",
        ]
        
        # Python
        py_version = sys.version.split()[0]
        lines.append(f"‚ïë  ‚úÖ Python {py_version.ljust(40)}‚ïë")
        
        # –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
        platform_name = Platform.get_name()
        lines.append(f"‚ïë  ‚úÖ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: {platform_name.ljust(33)}‚ïë")
        
        # Curses
        lines.append(f"‚ïë  ‚úÖ Curses –º–æ–¥—É–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                      ‚ïë")
        
        # –¶–≤–µ—Ç–∞
        if Platform.supports_256_colors():
            lines.append(f"‚ïë  ‚úÖ 256 —Ü–≤–µ—Ç–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è                     ‚ïë")
        else:
            lines.append(f"‚ïë  ‚ö†Ô∏è –¢–æ–ª—å–∫–æ 16 –±–∞–∑–æ–≤—ã—Ö —Ü–≤–µ—Ç–æ–≤                     ‚ïë")
        
        # Git
        try:
            subprocess.run(['git', '--version'], capture_output=True, check=True)
            lines.append(f"‚ïë  ‚úÖ Git —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                                ‚ïë")
        except:
            lines.append(f"‚ïë  ‚ö†Ô∏è Git –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                            ‚ïë")
        
        # Node.js
        try:
            subprocess.run(['node', '--version'], capture_output=True, check=True)
            lines.append(f"‚ïë  ‚úÖ Node.js —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                            ‚ïë")
        except:
            lines.append(f"‚ïë  ‚ö†Ô∏è Node.js –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                        ‚ïë")
        
        # Python3
        try:
            subprocess.run(['python3', '--version'], capture_output=True, check=True)
            lines.append(f"‚ïë  ‚úÖ Python3 –≤ PATH                                ‚ïë")
        except:
            lines.append(f"‚ïë  ‚ö†Ô∏è Python3 –Ω–µ –≤ PATH                            ‚ïë")
        
        # AI
        ai = self.plugin_manager.get('ai')
        if ai and ai.is_configured():
            provider = ai.config.get('provider', 'unknown')
            lines.append(f"‚ïë  ‚úÖ AI –Ω–∞—Å—Ç—Ä–æ–µ–Ω ({provider.ljust(28)})‚ïë")
        else:
            lines.append(f"‚ïë  ‚ö†Ô∏è AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω                               ‚ïë")
        
        # –ü–∞–º—è—Ç—å
        try:
            import resource
            mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024
            lines.append(f"‚ïë  üìä –ü–∞–º—è—Ç—å: {mem:.1f} MB".ljust(51) + "‚ïë")
        except:
            pass
        
        lines.append("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
        lines.append("‚ïë              –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ! üöÄ         ‚ïë")
        lines.append("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        
        height, width = self.stdscr.getmaxyx()
        start_y = (height - len(lines)) // 2
        
        for i, line in enumerate(lines):
            try:
                x = (width - len(line)) // 2
                color = Colors.get_pair(Colors.CYAN, -1)
                if "‚úÖ" in line:
                    color = Colors.get_pair(Colors.GREEN, -1)
                elif "‚ö†Ô∏è" in line or "‚ùå" in line:
                    color = Colors.get_pair(Colors.YELLOW, -1)
                elif "‚ïê" in line or "‚ïë" in line:
                    color = Colors.get_pair(Colors.MAGENTA, -1)
                
                self.stdscr.addstr(start_y + i, x, line, color)
            except:
                pass
        
        self.stdscr.refresh()
        self.stdscr.getch()
    
    def _show_about(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–≥—Ä–∞–º–º–µ"""
        lines = [
            "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó",
            "‚ïë                                                  ‚ïë",
            "‚ïë           üöÄ DIPO STUDIO v" + __version__.ljust(23) + "‚ïë",
            "‚ïë                                                  ‚ïë",
            "‚ïë     –ú–æ—â–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω–æ–π          ‚ïë",
            "‚ïë     —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏. –†–∞–±–æ—Ç–∞–µ—Ç –≤–µ–∑–¥–µ: Termux,         ‚ïë",
            "‚ïë     Linux, macOS, Windows.                       ‚ïë",
            "‚ïë                                                  ‚ïë",
            "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£",
            "‚ïë                                                  ‚ïë",
            "‚ïë     üì± Telegram: @MARADANIL                      ‚ïë",
            "‚ïë     üì¢ –ö–∞–Ω–∞–ª: t.me/DIPO_OFFICIAL                ‚ïë",
            "‚ïë                                                  ‚ïë",
            "‚ïë     ¬© 2024 DIPO Team. All rights reserved.      ‚ïë",
            "‚ïë                                                  ‚ïë",
            "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù",
        ]
        
        height, width = self.stdscr.getmaxyx()
        start_y = (height - len(lines)) // 2
        
        for i, line in enumerate(lines):
            try:
                x = (width - len(line)) // 2
                if "DIPO STUDIO" in line:
                    color = Colors.get_pair(Colors.MAGENTA, -1) | curses.A_BOLD
                elif "Telegram" in line or "–ö–∞–Ω–∞–ª" in line:
                    color = Colors.get_pair(Colors.CYAN, -1)
                elif "‚ïê" in line or "‚ïë" in line:
                    color = Colors.get_pair(Colors.BLUE, -1)
                else:
                    color = Colors.get_pair(Colors.WHITE, -1)
                
                self.stdscr.addstr(start_y + i, x, line, color)
            except:
                pass
        
        self.stdscr.refresh()
        self.stdscr.getch()
    
    def _show_help(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É"""
        help_text = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                         üöÄ DIPO STUDIO - –°–ü–†–ê–í–ö–ê                             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                              ‚ïë
‚ïë  üì± –ö–û–ú–ê–ù–î–´ –î–õ–Ø –ú–û–ë–ò–õ–¨–ù–´–• (–≤–≤–æ–¥–∏—Ç–µ —á–µ—Ä–µ–∑ :)                                 ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                               ‚ïë
‚ïë   :s  :w      - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª                                               ‚ïë
‚ïë   :q          - –í—ã–π—Ç–∏                                                        ‚ïë
‚ïë   :wq         - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏                                            ‚ïë
‚ïë   :h          - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞                                                  ‚ïë
‚ïë   :f          - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤                                             ‚ïë
‚ïë   :r          - –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥                                                ‚ïë
‚ïë   :t          - –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É                                                 ‚ïë
‚ïë   :g 42       - –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å—Ç—Ä–æ–∫–µ 42                                          ‚ïë
‚ïë   :find text  - –ü–æ–∏—Å–∫ —Ç–µ–∫—Å—Ç–∞                                                 ‚ïë
‚ïë   :ai         - AI –ø–æ–º–æ—â–Ω–∏–∫                                                  ‚ïë
‚ïë   :ai setup   - –ù–∞—Å—Ç—Ä–æ–π–∫–∞ AI                                                 ‚ïë
‚ïë   :build      - –°–±–æ—Ä–∫–∞ APK                                                   ‚ïë
‚ïë   :git        - Git –º–µ–Ω—é                                                     ‚ïë
‚ïë   :term       - –¢–µ—Ä–º–∏–Ω–∞–ª                                                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚å®Ô∏è  –ì–û–†–Ø–ß–ò–ï –ö–õ–ê–í–ò–®–ò (–¥–ª—è –ü–ö)                                               ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                               ‚ïë
‚ïë   Ctrl+S      - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å         Ctrl+Q      - –í—ã–π—Ç–∏                        ‚ïë
‚ïë   Ctrl+Z      - –û—Ç–º–µ–Ω–∏—Ç—å          Ctrl+Y      - –ü–æ–≤—Ç–æ—Ä–∏—Ç—å                    ‚ïë
‚ïë   Ctrl+C      - –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å        Ctrl+V      - –í—Å—Ç–∞–≤–∏—Ç—å                     ‚ïë
‚ïë   Ctrl+X      - –í—ã—Ä–µ–∑–∞—Ç—å          Ctrl+A      - –í—ã–¥–µ–ª–∏—Ç—å –≤—Å—ë                 ‚ïë
‚ïë   Ctrl+F      - –ü–æ–∏—Å–∫             Ctrl+H      - –ó–∞–º–µ–Ω–∞                       ‚ïë
‚ïë   Ctrl+G      - Git               Ctrl+D      - –ú—É–ª—å—Ç–∏–∫—É—Ä—Å–æ—Ä                 ‚ïë
‚ïë   Ctrl+/      - –ö–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å    Ctrl+B      - –ó–∞–∫–ª–∞–¥–∫–∞                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  üéπ F-–ö–õ–ê–í–ò–®–ò                                                                ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                               ‚ïë
‚ïë   F1  - –°–ø—Ä–∞–≤–∫–∞       F2  - Zen —Ä–µ–∂–∏–º     F3  - –ù–∞–π—Ç–∏ –¥–∞–ª–µ–µ                  ‚ïë
‚ïë   F4  - –¢–µ–º—ã          F5  - –ó–∞–ø—É—Å–∫        F6  - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫                    ‚ïë
‚ïë   F7  - –õ–∏–Ω—Ç–µ—Ä        F8  - –°–ª–µ–¥. –æ—à–∏–±–∫–∞  F9  - –°–Ω–∏–ø–ø–µ—Ç—ã                     ‚ïë
‚ïë   F10 - –ú–µ–Ω—é          F11 - –ü–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω  F12 - –¢–µ—Ä–º–∏–Ω–∞–ª                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  üí° –ü–û–î–°–ö–ê–ó–ö–ò                                                                ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                               ‚ïë
‚ïë   ‚Ä¢ Tab –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ = —Å–Ω–∏–ø–ø–µ—Ç (def, class, for, if...)            ‚ïë
‚ïë   ‚Ä¢ –°–∫–æ–±–∫–∏ –∏ –∫–∞–≤—ã—á–∫–∏ –∑–∞–∫—Ä—ã–≤–∞—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏                               ‚ïë
‚ïë   ‚Ä¢ :ai <–≤–æ–ø—Ä–æ—Å> - —Å–ø—Ä–æ—Å–∏—Ç—å AI –Ω–∞–ø—Ä—è–º—É—é                                      ‚ïë
‚ïë   ‚Ä¢ :set <–æ–ø—Ü–∏—è>=<–∑–Ω–∞—á–µ–Ω–∏–µ> - –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É                             ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        
        lines = help_text.strip().split('\n')
        height, width = self.stdscr.getmaxyx()
        
        scroll = 0
        max_scroll = max(0, len(lines) - height + 2)
        
        while True:
            self.stdscr.clear()
            
            for i, line in enumerate(lines[scroll:scroll + height - 1]):
                try:
                    if "‚ïê" in line or "‚ïë" in line or "‚ïî" in line or "‚ïö" in line or "‚ï†" in line:
                        color = Colors.get_pair(Colors.MAGENTA, -1)
                    elif line.strip().startswith(":") or "Ctrl+" in line or line.strip().startswith("F"):
                        color = Colors.get_pair(Colors.GREEN, -1)
                    elif "‚îÄ" in line:
                        color = Colors.get_pair(Colors.CYAN, -1)
                    elif "‚Ä¢" in line or "üí°" in line:
                        color = Colors.get_pair(Colors.YELLOW, -1)
                    else:
                        color = Colors.get_pair(Colors.WHITE, -1)
                    
                    x = max(0, (width - len(line)) // 2)
                    self.stdscr.addstr(i, x, line[:width-1], color)
                except:
                    pass
            
            # –ü–æ–¥—Å–∫–∞–∑–∫–∞ –≤–Ω–∏–∑—É
            try:
                hint = " [‚Üë‚Üì] –°–∫—Ä–æ–ª–ª  [q/Esc] –ó–∞–∫—Ä—ã—Ç—å "
                self.stdscr.addstr(height - 1, (width - len(hint)) // 2, hint,
                                  Colors.get_pair(Colors.BLACK, Colors.CYAN))
            except:
                pass
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key in (27, ord('q'), ord('Q')):
                break
            elif key == curses.KEY_UP:
                scroll = max(0, scroll - 1)
            elif key == curses.KEY_DOWN:
                scroll = min(max_scroll, scroll + 1)
            elif key == curses.KEY_PPAGE:
                scroll = max(0, scroll - height + 2)
            elif key == curses.KEY_NPAGE:
                scroll = min(max_scroll, scroll + height - 2)
            elif key == curses.KEY_HOME:
                scroll = 0
            elif key == curses.KEY_END:
                scroll = max_scroll
    
    def _show_main_menu(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
        items = [
            "üìÑ –ù–æ–≤—ã–π —Ñ–∞–π–ª",
            "üìÇ –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª",
            "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
            "üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫...",
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            "‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥",
            "üîç –ü–æ–∏—Å–∫",
            "üîÑ –ó–∞–º–µ–Ω–∞",
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            "üìÇ –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤",
            "üåø Git",
            "üíª –¢–µ—Ä–º–∏–Ω–∞–ª",
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            "ü§ñ AI –ø–æ–º–æ—â–Ω–∏–∫",
            "üì¶ –°–±–æ—Ä–∫–∞ APK",
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            "üé® –¢–µ–º—ã",
            "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
            "üîå –ü–ª–∞–≥–∏–Ω—ã",
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
            "‚ùì –°–ø—Ä–∞–≤–∫–∞",
            "‚ÑπÔ∏è –û –ø—Ä–æ–≥—Ä–∞–º–º–µ",
            "üö™ –í—ã—Ö–æ–¥",
        ]
        
        dialog = ListDialog(self.stdscr, "üìã –ú–µ–Ω—é", items)
        choice = dialog.show()
        
        if choice is None:
            return
        
        item = items[choice]
        
        if "–ù–æ–≤—ã–π" in item:
            self.tab_manager.new_tab()
        elif "–û—Ç–∫—Ä—ã—Ç—å" in item:
            self._open_file_dialog()
        elif "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫" in item:
            self._save_file()  # –ó–∞–ø—Ä–æ—Å–∏—Ç –∏–º—è
        elif "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å" in item:
            self._save_file()
        elif "–ó–∞–ø—É—Å—Ç–∏—Ç—å" in item:
            self._run_code()
        elif "–ü–æ–∏—Å–∫" in item:
            self._show_search()
        elif "–ó–∞–º–µ–Ω–∞" in item:
            self._show_replace()
        elif "–ü—Ä–æ–≤–æ–¥–Ω–∏–∫" in item:
            self._show_file_explorer()
        elif "Git" in item:
            git = self.plugin_manager.get('git')
            if git:
                git.show_menu()
        elif "–¢–µ—Ä–º–∏–Ω–∞–ª" in item:
            terminal = self.plugin_manager.get('terminal')
            if terminal:
                terminal.show()
        elif "AI" in item:
            ai = self.plugin_manager.get('ai')
            if ai:
                ai.show_ai_chat()
        elif "APK" in item:
            apk = self.plugin_manager.get('apk_builder')
            if apk:
                apk.show_build_menu()
        elif "–¢–µ–º—ã" in item:
            self._change_theme()
        elif "–ù–∞—Å—Ç—Ä–æ–π–∫–∏" in item:
            self._show_settings()
        elif "–ü–ª–∞–≥–∏–Ω—ã" in item:
            self._show_plugins_list()
        elif "–°–ø—Ä–∞–≤–∫–∞" in item:
            self._show_help()
        elif "–û –ø—Ä–æ–≥—Ä–∞–º–º–µ" in item:
            self._show_about()
        elif "–í—ã—Ö–æ–¥" in item:
            if self._confirm_exit():
                self.running = False
    
    def _check_autosave(self):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ"""
        autosave = self.plugin_manager.get('autosave')
        if autosave:
            autosave.check_autosave()
    
    def _show_message(self, message: str, msg_type: str = "info"):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Å—Ç–∞—Ç—É—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ"""
        self.status_message = message
        self.status_type = msg_type
        self.status_time = time.time()
    
    def _show_error(self, message: str):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"""
        self._show_message(message, "error")


print("‚úÖ –ß–∞—Å—Ç—å 7/8 –∑–∞–≥—Ä—É–∂–µ–Ω–∞: –ú–µ—Ç–æ–¥—ã Editor (–∫–æ–º–∞–Ω–¥—ã, –¥–∏–∞–ª–æ–≥–∏, –¥–µ–π—Å—Ç–≤–∏—è)")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –û–ë–†–ê–ë–û–¢–ö–ê –ê–†–ì–£–ú–ï–ù–¢–û–í –ö–û–ú–ê–ù–î–ù–û–ô –°–¢–†–û–ö–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CommandLineParser:
    """–ü–∞—Ä—Å–µ—Ä –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
    
    HELP_TEXT = f"""
üöÄ DIPO STUDIO v{__version__} - –ú–æ—â–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞

–ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï:
    dipo [–æ–ø—Ü–∏–∏] [—Ñ–∞–π–ª1] [—Ñ–∞–π–ª2] ...

–û–ü–¶–ò–ò:
    -h, --help          –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
    -v, --version       –ü–æ–∫–∞–∑–∞—Ç—å –≤–µ—Ä—Å–∏—é
    -n, --new           –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª
    --theme <–∏–º—è>       –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–º—É (cosmos, dracula, monokai...)
    --no-splash         –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É
    --no-session        –ù–µ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å —Å–µ—Å—Å–∏—é
    --doctor            –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã
    --config            –ü–æ–∫–∞–∑–∞—Ç—å –ø—É—Ç—å –∫ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

AI –ö–û–ú–ê–ù–î–´:
    dipo ai --setup     –ù–∞—Å—Ç—Ä–æ–∏—Ç—å AI –ø–æ–º–æ—â–Ω–∏–∫
    dipo ai --status    –°—Ç–∞—Ç—É—Å AI –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    dipo ai: <–∑–∞–ø—Ä–æ—Å>   –í—ã–ø–æ–ª–Ω–∏—Ç—å AI –∑–∞–ø—Ä–æ—Å

–ü–†–ò–ú–ï–†–´:
    dipo                        # –û—Ç–∫—Ä—ã—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä
    dipo file.py                # –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª
    dipo file1.py file2.js      # –û—Ç–∫—Ä—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤
    dipo .                      # –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–≤–æ–¥–Ω–∏–∫ –≤ —Ç–µ–∫—É—â–µ–π –ø–∞–ø–∫–µ
    dipo --theme dracula        # –û—Ç–∫—Ä—ã—Ç—å —Å —Ç–µ–º–æ–π Dracula
    dipo ai: –Ω–∞–ø–∏—à–∏ hello world # AI –∑–∞–ø—Ä–æ—Å

–ú–û–ë–ò–õ–¨–ù–´–ï –ö–û–ú–ê–ù–î–´ (–≤–Ω—É—Ç—Ä–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞, —á–µ—Ä–µ–∑ :):
    :s, :w      - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
    :q          - –í—ã–π—Ç–∏
    :wq         - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏
    :h          - –°–ø—Ä–∞–≤–∫–∞
    :f          - –ü—Ä–æ–≤–æ–¥–Ω–∏–∫ —Ñ–∞–π–ª–æ–≤
    :r          - –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥
    :ai         - AI –ø–æ–º–æ—â–Ω–∏–∫
    :build      - –°–±–æ—Ä–∫–∞ APK
    :git        - Git –º–µ–Ω—é

üì± Telegram: {__telegram__}
üì¢ –ö–∞–Ω–∞–ª: {__channel__}
"""
    
    def __init__(self, args: List[str]):
        self.args = args
        self.files: List[str] = []
        self.options: Dict[str, Any] = {
            "show_splash": True,
            "restore_session": True,
            "theme": None,
            "new_file": False,
        }
        self.action: Optional[str] = None  # help, version, doctor, ai_setup, ai_query
        self.ai_query: Optional[str] = None
    
    def parse(self) -> bool:
        """–ü–∞—Ä—Å–∏—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç—ã. –í–µ—Ä–Ω—É—Ç—å False –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –≤—ã–π—Ç–∏ –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
        i = 0
        while i < len(self.args):
            arg = self.args[i]
            
            if arg in ("-h", "--help"):
                self.action = "help"
                return False
            
            elif arg in ("-v", "--version"):
                self.action = "version"
                return False
            
            elif arg == "--doctor":
                self.action = "doctor"
                return False
            
            elif arg == "--config":
                self.action = "config"
                return False
            
            elif arg in ("-n", "--new"):
                self.options["new_file"] = True
            
            elif arg == "--no-splash":
                self.options["show_splash"] = False
            
            elif arg == "--no-session":
                self.options["restore_session"] = False
            
            elif arg == "--theme":
                if i + 1 < len(self.args):
                    i += 1
                    self.options["theme"] = self.args[i]
            
            elif arg == "ai":
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ AI –∫–æ–º–∞–Ω–¥
                if i + 1 < len(self.args):
                    next_arg = self.args[i + 1]
                    if next_arg == "--setup":
                        self.action = "ai_setup"
                        return False
                    elif next_arg == "--status":
                        self.action = "ai_status"
                        return False
            
            elif arg.startswith("ai:") or arg.startswith("ai :"):
                # AI –∑–∞–ø—Ä–æ—Å –∏–∑ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
                query_start = arg.find(":") + 1
                query = arg[query_start:].strip()
                
                # –°–æ–±—Ä–∞—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–∞–∫ —á–∞—Å—Ç—å –∑–∞–ø—Ä–æ—Å–∞
                remaining = self.args[i + 1:]
                if remaining:
                    query += " " + " ".join(remaining)
                
                self.ai_query = query
                self.action = "ai_query"
                return False
            
            elif arg.startswith("-"):
                print(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–ø—Ü–∏—è: {arg}")
                print("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --help –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏")
                return False
            
            else:
                # –≠—Ç–æ —Ñ–∞–π–ª
                self.files.append(arg)
            
            i += 1
        
        return True
    
    def execute_action(self) -> int:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ. –í–µ—Ä–Ω—É—Ç—å –∫–æ–¥ –≤—ã—Ö–æ–¥–∞"""
        if self.action == "help":
            print(self.HELP_TEXT)
            return 0
        
        elif self.action == "version":
            print(f"üöÄ DIPO Studio v{__version__}")
            print(f"üì± Platform: {Platform.get_name()}")
            print(f"üêç Python: {sys.version.split()[0]}")
            return 0
        
        elif self.action == "doctor":
            self._run_doctor()
            return 0
        
        elif self.action == "config":
            print(f"üìÇ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: {CONFIG_DIR}")
            print(f"üìÑ –ù–∞—Å—Ç—Ä–æ–π–∫–∏: {SETTINGS_FILE}")
            print(f"ü§ñ AI –∫–æ–Ω—Ñ–∏–≥: {AI_CONFIG_FILE}")
            return 0
        
        elif self.action == "ai_setup":
            return self._run_ai_setup()
        
        elif self.action == "ai_status":
            return self._show_ai_status()
        
        elif self.action == "ai_query":
            return self._run_ai_query()
        
        return 0
    
    def _run_doctor(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ"""
        print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print("‚ïë           üè• –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê DIPO STUDIO             ‚ïë")
        print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
        
        # Python
        print(f"‚ïë  ‚úÖ Python {sys.version.split()[0].ljust(40)}‚ïë")
        
        # –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
        print(f"‚ïë  ‚úÖ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: {Platform.get_name().ljust(33)}‚ïë")
        
        # Curses
        try:
            import curses
            print(f"‚ïë  ‚úÖ Curses –º–æ–¥—É–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                      ‚ïë")
        except ImportError:
            print(f"‚ïë  ‚ùå Curses –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                          ‚ïë")
        
        # Git
        try:
            result = subprocess.run(['git', '--version'], capture_output=True, text=True)
            version = result.stdout.strip().replace("git version ", "")
            print(f"‚ïë  ‚úÖ Git {version.ljust(41)}‚ïë")
        except:
            print(f"‚ïë  ‚ö†Ô∏è Git –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                            ‚ïë")
        
        # Node.js
        try:
            result = subprocess.run(['node', '--version'], capture_output=True, text=True)
            version = result.stdout.strip()
            print(f"‚ïë  ‚úÖ Node.js {version.ljust(37)}‚ïë")
        except:
            print(f"‚ïë  ‚ö†Ô∏è Node.js –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω                        ‚ïë")
        
        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        print(f"‚ïë  üìÇ –ö–æ–Ω—Ñ–∏–≥: {CONFIG_DIR[:36].ljust(37)}‚ïë")
        
        # AI
        if os.path.exists(AI_CONFIG_FILE):
            try:
                with open(AI_CONFIG_FILE, 'r') as f:
                    config = json.load(f)
                    provider = config.get('provider', 'unknown')
                    print(f"‚ïë  ‚úÖ AI –Ω–∞—Å—Ç—Ä–æ–µ–Ω ({provider.ljust(31)})‚ïë")
            except:
                print(f"‚ïë  ‚ö†Ô∏è AI –∫–æ–Ω—Ñ–∏–≥ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω                          ‚ïë")
        else:
            print(f"‚ïë  ‚ö†Ô∏è AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω (dipo ai --setup)             ‚ïë")
        
        print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
        print("‚ïë              –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ! üöÄ         ‚ïë")
        print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    
    def _run_ai_setup(self) -> int:
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É AI –≤ curses"""
        def setup(stdscr):
            Colors.init(stdscr)
            
            # –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π editor –¥–ª—è –ø–ª–∞–≥–∏–Ω–∞
            class MinimalEditor:
                def __init__(self, scr):
                    self.stdscr = scr
            
            editor = MinimalEditor(stdscr)
            ai = AIAssistantPlugin(editor)
            ai.show_setup_wizard()
        
        try:
            curses.wrapper(setup)
            return 0
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            return 1
    
    def _show_ai_status(self) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å AI"""
        if not os.path.exists(AI_CONFIG_FILE):
            print("‚ùå AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
            print("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: dipo ai --setup")
            return 1
        
        try:
            with open(AI_CONFIG_FILE, 'r') as f:
                config = json.load(f)
            
            provider = config.get('provider', 'unknown')
            model = config.get('model', 'unknown')
            has_key = bool(config.get('api_key'))
            
            print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print("‚ïë        ü§ñ AI –°–¢–ê–¢–£–°                  ‚ïë")
            print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
            print(f"‚ïë  –ü—Ä–æ–≤–∞–π–¥–µ—Ä: {provider.ljust(25)}‚ïë")
            print(f"‚ïë  –ú–æ–¥–µ–ª—å: {model.ljust(28)}‚ïë")
            print(f"‚ïë  API –∫–ª—é—á: {'‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' if has_key else '‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}".ljust(40) + "‚ïë")
            print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            
            return 0 if has_key else 1
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞: {e}")
            return 1
    
    def _run_ai_query(self) -> int:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å AI –∑–∞–ø—Ä–æ—Å –∏–∑ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
        if not self.ai_query:
            print("‚ùå –ü—É—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å")
            return 1
        
        if not os.path.exists(AI_CONFIG_FILE):
            print("‚ùå AI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
            print("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: dipo ai --setup")
            return 1
        
        try:
            with open(AI_CONFIG_FILE, 'r') as f:
                config = json.load(f)
            
            provider = config.get('provider')
            api_key = config.get('api_key')
            model = config.get('model')
            
            if not provider or not api_key:
                print("‚ùå AI –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
                return 1
            
            # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
            try:
                api_key = base64.b64decode(api_key.encode()).decode()
            except:
                pass
            
            print(f"ü§ñ –ó–∞–ø—Ä–æ—Å –∫ {provider} ({model})...")
            print()
            
            # –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å
            response = self._call_ai_api(provider, api_key, model, self.ai_query)
            
            print("‚îÅ" * 50)
            print(response)
            print("‚îÅ" * 50)
            
            return 0
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            return 1
    
    def _call_ai_api(self, provider: str, api_key: str, model: str, query: str) -> str:
        """–í—ã–∑–æ–≤ AI API"""
        import urllib.request
        import urllib.error
        
        # OpenAI-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ API
        if provider in ['openai', 'groq', 'deepseek']:
            urls = {
                'openai': 'https://api.openai.com/v1/chat/completions',
                'groq': 'https://api.groq.com/openai/v1/chat/completions',
                'deepseek': 'https://api.deepseek.com/v1/chat/completions'
            }
            
            url = urls.get(provider)
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {api_key}'
            }
            
            data = {
                'model': model,
                'messages': [{'role': 'user', 'content': query}],
                'max_tokens': 2000
            }
            
            req = urllib.request.Request(url, 
                                         data=json.dumps(data).encode(),
                                         headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['choices'][0]['message']['content']
        
        elif provider == 'anthropic':
            url = 'https://api.anthropic.com/v1/messages'
            headers = {
                'Content-Type': 'application/json',
                'x-api-key': api_key,
                'anthropic-version': '2023-06-01'
            }
            
            data = {
                'model': model,
                'max_tokens': 2000,
                'messages': [{'role': 'user', 'content': query}]
            }
            
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['content'][0]['text']
        
        elif provider == 'google':
            url = f'https://generativelanguage.googleapis.com/v1/models/{model}:generateContent?key={api_key}'
            
            data = {'contents': [{'parts': [{'text': query}]}]}
            
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers={'Content-Type': 'application/json'})
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode())
                return result['candidates'][0]['content']['parts'][0]['text']
        
        elif provider == 'local':
            url = 'http://localhost:11434/api/generate'
            data = {'model': model, 'prompt': query, 'stream': False}
            
            req = urllib.request.Request(url,
                                         data=json.dumps(data).encode(),
                                         headers={'Content-Type': 'application/json'})
            
            with urllib.request.urlopen(req, timeout=120) as response:
                result = json.loads(response.read().decode())
                return result.get('response', '–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç')
        
        return "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä"


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞"""
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–∫–∞–ª–∏ –¥–ª—è Unicode
    try:
        locale.setlocale(locale.LC_ALL, '')
    except:
        pass
    
    # –ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
    parser = CommandLineParser(sys.argv[1:])
    
    if not parser.parse():
        # –ù—É–∂–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –∏ –≤—ã–π—Ç–∏
        sys.exit(parser.execute_action())
    
    # –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ç–µ–º—É –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
    if parser.options.get("theme"):
        settings.set("theme", parser.options["theme"])
    
    # –ó–∞–ø—É—Å–∫ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
    def run_editor(stdscr):
        # –ü–æ–∫–∞–∑–∞—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É
        if parser.options.get("show_splash", True) and not parser.files:
            try:
                SplashScreen.show(stdscr, duration=2.5)
            except:
                pass
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞
        Colors.init(stdscr)
        
        # –°–æ–∑–¥–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä
        editor = Editor(stdscr)
        
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á—Ç–æ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å
        files_to_open = parser.files
        
        # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ –ø–∞–ø–∫–∞ - –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–≤–æ–¥–Ω–∏–∫
        if len(files_to_open) == 1 and os.path.isdir(files_to_open[0]):
            explorer = editor.plugin_manager.get('file_explorer')
            if explorer:
                explorer.current_path = os.path.abspath(files_to_open[0])
            files_to_open = []
        
        # –ù–æ–≤—ã–π —Ñ–∞–π–ª
        if parser.options.get("new_file"):
            editor.tab_manager.new_tab()
            files_to_open = []
        
        # –ó–∞–ø—É—Å—Ç–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä
        editor.run(
            files=files_to_open if files_to_open else None,
            restore_session=parser.options.get("restore_session", True) and not files_to_open
        )
    
    try:
        curses.wrapper(run_editor)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—à–∏–±–∫—É –≤ –ª–æ–≥
        error_log = os.path.join(CONFIG_DIR, "error.log")
        try:
            with open(error_log, 'a') as f:
                f.write(f"\n{'='*50}\n")
                f.write(f"Time: {datetime.now().isoformat()}\n")
                f.write(f"Error: {str(e)}\n")
                f.write(traceback.format_exc())
        except:
            pass
        
        print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        print(f"üìÑ –õ–æ–≥ –æ—à–∏–±–æ–∫: {error_log}")
        print(f"üì± –°–æ–æ–±—â–∏—Ç–µ –æ–± –æ—à–∏–±–∫–µ: {__telegram__}")
        sys.exit(1)
    
    print("\nüëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è! –°–ø–∞—Å–∏–±–æ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ DIPO Studio!")
    print(f"üì¢ –ü–æ–¥–ø–∏—Å—ã–≤–∞–π—Ç–µ—Å—å: {__channel__}")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –¢–û–ß–ö–ê –í–•–û–î–ê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

if __name__ == "__main__":
    main()


