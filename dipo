#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                               â•‘
â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘
â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•— â•‘
â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•‘
â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•‘
â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•‘
â•‘     â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•      â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•â•   â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â• â•šâ•â•â•â•â•â•  â•‘
â•‘                                                                               â•‘
â•‘                    ğŸš€ Ğ Ğ•Ğ’ĞĞ›Ğ®Ğ¦Ğ˜ĞĞĞĞ«Ğ™ Ğ Ğ•Ğ”ĞĞšĞ¢ĞĞ  ĞšĞĞ”Ğ v3.0 ğŸš€                      â•‘
â•‘                                                                               â•‘
â•‘     Telegram: @MARADANIL | https://t.me/DIPO_OFFICIAL                         â•‘
â•‘                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Dipo Studio - ĞœĞ¾Ñ‰Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°
Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ² Termux (Android), Linux, macOS, Windows (WSL)

ĞĞ²Ñ‚Ğ¾Ñ€: Dipo Team
Ğ›Ğ¸Ñ†ĞµĞ½Ğ·Ğ¸Ñ: MIT
"""

__version__ = "3.0.0"
__author__ = "Dipo Team"
__telegram__ = "@MARADANIL"
__telegram_link__ = "https://t.me/DIPO_OFFICIAL"

import curses
import curses.ascii
import os
import sys
import re
import json
import time
import subprocess
import signal
import locale
import shutil
import tempfile
import hashlib
import base64
import threading
import queue
import traceback
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple, Optional, Any, Set, Callable, Union
from dataclasses import dataclass, field
from enum import Enum, auto
from collections import deque, defaultdict
from abc import ABC, abstractmethod
import urllib.request
import urllib.error
import urllib.parse

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¬ Ğ—ĞĞ¡Ğ¢ĞĞ’ĞšĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SPLASH_SCREEN = """
\033[38;5;51m
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
    â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•      â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•â•   â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â• â•šâ•â•â•â•â•â• 
\033[0m
\033[38;5;226m                    âš¡ Ğ Ğ•Ğ’ĞĞ›Ğ®Ğ¦Ğ˜ĞĞĞĞ«Ğ™ Ğ Ğ•Ğ”ĞĞšĞ¢ĞĞ  ĞšĞĞ”Ğ v3.0 âš¡\033[0m

\033[38;5;250m    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ Python    ğŸ“œ JavaScript   ğŸ’ Ruby      ğŸ¦€ Rust     â˜• Java   â”‚
    â”‚  ğŸ¹ Go        ğŸ’  TypeScript   ğŸ˜ PHP       âš™ï¸  C/C++    ğŸ”· C#     â”‚
    â”‚  ğŸŒ™ Lua       ğŸª Perl         ğŸ“Š R         ğŸ Swift    ğŸ¯ Kotlin â”‚
    â”‚  ğŸ’» Bash      ğŸ³ Docker       ğŸ“‹ YAML      ğŸ“¦ JSON     ğŸ“ MD     â”‚
    â”‚  ğŸŒ HTML      ğŸ¨ CSS          ğŸ—ƒï¸  SQL       âš¡ Zig      ğŸ”¥ 30+    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\033[0m

\033[38;5;123m    âœ¨ ĞÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸:
       â€¢ ĞœĞ³Ğ½Ğ¾Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº - Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ±ĞµĞ· Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
       â€¢ 30+ ÑĞ·Ñ‹ĞºĞ¾Ğ² Ñ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ¾Ğ¹ ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸ÑĞ°
       â€¢ AI Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº (GPT-4, Claude, Gemini, Groq, Ollama)
       â€¢ Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ», Git, Ğ»Ğ¸Ğ½Ñ‚ĞµÑ€
       â€¢ ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ñ‹ Ğ¸ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚Ñ‹
       â€¢ Ğ£Ğ¼Ğ½Ñ‹Ğ¹ Ğ°Ğ²Ñ‚Ğ¾ĞºĞ¾Ğ¼Ğ¿Ğ»Ğ¸Ñ‚ Ğ¸ Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³
       â€¢ ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ñ Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
       â€¢ Ğ¢ĞµĞ¼Ñ‹ Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¸ ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ\033[0m

\033[38;5;213m    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    ğŸ“± Telegram: @MARADANIL
    ğŸ”— https://t.me/DIPO_OFFICIAL
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m
"""

LOADING_FRAMES = [
    "â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "
]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Config:
    """Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ°Ñ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ"""
    
    # ĞŸÑƒÑ‚Ğ¸
    HOME_DIR = Path.home()
    CONFIG_DIR = HOME_DIR / ".dipo"
    CONFIG_FILE = CONFIG_DIR / "config.json"
    AI_CONFIG_FILE = CONFIG_DIR / "ai_config.json"
    THEMES_DIR = CONFIG_DIR / "themes"
    SNIPPETS_DIR = CONFIG_DIR / "snippets"
    PLUGINS_DIR = CONFIG_DIR / "plugins"
    SESSIONS_DIR = CONFIG_DIR / "sessions"
    BACKUPS_DIR = CONFIG_DIR / "backups"
    HISTORY_FILE = CONFIG_DIR / "command_history.json"
    
    # Ğ”ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
    DEFAULTS = {
        "theme": "cosmos",
        "font_size": 12,
        "tab_size": 4,
        "use_spaces": True,
        "show_line_numbers": True,
        "show_minimap": False,
        "show_whitespace": False,
        "word_wrap": False,
        "auto_save": True,
        "auto_save_interval": 60,
        "auto_indent": True,
        "auto_pairs": True,
        "highlight_current_line": True,
        "highlight_matching_brackets": True,
        "smooth_scrolling": True,
        "cursor_blink": True,
        "show_git_status": True,
        "lint_on_save": True,
        "format_on_save": False,
        "trim_trailing_whitespace": True,
        "insert_final_newline": True,
        "max_recent_files": 20,
        "terminal_shell": os.environ.get("SHELL", "/bin/bash"),
        "ai_provider": None,
        "language": "auto",
        "encoding": "utf-8",
    }
    
    _instance = None
    _config = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._load()
        return cls._instance
    
    def _load(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ"""
        self._ensure_dirs()
        try:
            if self.CONFIG_FILE.exists():
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    self._config = {**self.DEFAULTS, **json.load(f)}
            else:
                self._config = self.DEFAULTS.copy()
                self._save()
        except Exception:
            self._config = self.DEFAULTS.copy()
    
    def _save(self):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ"""
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(self._config, f, indent=2, ensure_ascii=False)
        except Exception:
            pass
    
    def _ensure_dirs(self):
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸"""
        for d in [self.CONFIG_DIR, self.THEMES_DIR, self.SNIPPETS_DIR, 
                  self.PLUGINS_DIR, self.SESSIONS_DIR, self.BACKUPS_DIR]:
            d.mkdir(parents=True, exist_ok=True)
    
    def get(self, key: str, default=None):
        return self._config.get(key, default)
    
    def set(self, key: str, value):
        self._config[key] = value
        self._save()
    
    def __getitem__(self, key):
        return self._config.get(key, self.DEFAULTS.get(key))
    
    def __setitem__(self, key, value):
        self.set(key, value)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ¦Ğ’Ğ•Ğ¢ĞĞ’
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ColorManager:
    """ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ² Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ 256 Ğ¸ True Color"""
    
    _pairs: Dict[tuple, int] = {}
    _pair_counter = 1
    _initialized = False
    
    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ñ†Ğ²ĞµÑ‚Ğ° curses
    BASE_COLORS = {
        'black': curses.COLOR_BLACK,
        'red': curses.COLOR_RED,
        'green': curses.COLOR_GREEN,
        'yellow': curses.COLOR_YELLOW,
        'blue': curses.COLOR_BLUE,
        'magenta': curses.COLOR_MAGENTA,
        'cyan': curses.COLOR_CYAN,
        'white': curses.COLOR_WHITE,
        'default': -1,
    }
    
    # Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğµ Ñ†Ğ²ĞµÑ‚Ğ° (256)
    EXTENDED_COLORS = {
        'gray': 245,
        'dark_gray': 238,
        'light_gray': 252,
        'orange': 208,
        'pink': 212,
        'purple': 141,
        'brown': 130,
        'lime': 118,
        'teal': 30,
        'navy': 17,
        'olive': 142,
        'maroon': 88,
        'aqua': 51,
        'silver': 7,
        'gold': 220,
    }
    
    @classmethod
    def init(cls):
        """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹"""
        if cls._initialized:
            return
        
        try:
            curses.start_color()
            curses.use_default_colors()
            cls._initialized = True
        except Exception:
            pass
    
    @classmethod
    def get_color(cls, name: str) -> int:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ†Ğ²ĞµÑ‚Ğ° Ğ¿Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸"""
        if name in cls.BASE_COLORS:
            return cls.BASE_COLORS[name]
        if name in cls.EXTENDED_COLORS:
            return cls.EXTENDED_COLORS[name]
        # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¿Ğ°Ñ€ÑĞ¸Ñ‚ÑŒ ĞºĞ°Ğº Ñ‡Ğ¸ÑĞ»Ğ¾
        try:
            return int(name)
        except ValueError:
            return -1
    
    @classmethod
    def get_pair(cls, fg: str = 'default', bg: str = 'default', 
                 bold: bool = False, dim: bool = False,
                 underline: bool = False, reverse: bool = False) -> int:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‹"""
        key = (fg, bg, bold, dim, underline, reverse)
        
        if key not in cls._pairs:
            fg_color = cls.get_color(fg)
            bg_color = cls.get_color(bg)
            
            try:
                curses.init_pair(cls._pair_counter, fg_color, bg_color)
                attr = curses.color_pair(cls._pair_counter)
                cls._pair_counter += 1
            except Exception:
                attr = 0
            
            if bold:
                attr |= curses.A_BOLD
            if dim:
                attr |= curses.A_DIM
            if underline:
                attr |= curses.A_UNDERLINE
            if reverse:
                attr |= curses.A_REVERSE
            
            cls._pairs[key] = attr
        
        return cls._pairs[key]
    
    @classmethod
    def hex_to_curses(cls, hex_color: str) -> int:
        """ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ HEX Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğ¹ curses Ñ†Ğ²ĞµÑ‚"""
        if not hex_color.startswith('#'):
            return -1
        
        try:
            r = int(hex_color[1:3], 16)
            g = int(hex_color[3:5], 16)
            b = int(hex_color[5:7], 16)
            
            # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ² 256 Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²
            if r == g == b:
                if r < 8:
                    return 16
                if r > 248:
                    return 231
                return round((r - 8) / 247 * 24) + 232
            
            return 16 + 36 * round(r / 255 * 5) + 6 * round(g / 255 * 5) + round(b / 255 * 5)
        except Exception:
            return -1


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ Ğ¢Ğ•ĞœĞ« ĞĞ¤ĞĞ ĞœĞ›Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

THEMES = {
    "cosmos": {
        "name": "ğŸŒŒ ĞšĞ¾ÑĞ¼Ğ¾Ñ",
        "description": "Ğ“Ğ»ÑƒĞ±Ğ¾ĞºĞ°Ñ Ñ‚Ñ‘Ğ¼Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ° Ñ ĞºĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼Ğ¸ Ğ°ĞºÑ†ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸",
        "colors": {
            "bg": "default",
            "fg": "white",
            "header_bg": "blue",
            "header_fg": "white",
            "footer_bg": "blue",
            "footer_fg": "white",
            "sidebar_bg": "default",
            "sidebar_fg": "cyan",
            "line_number": "cyan",
            "line_number_active": "white",
            "current_line": "236",
            "selection": "24",
            "cursor": "white",
            "matching_bracket": "yellow",
            "search_match": "yellow",
            "error": "red",
            "warning": "yellow",
            "info": "cyan",
            "success": "green",
        },
        "syntax": {
            "keyword": {"fg": "magenta", "bold": True},
            "keyword2": {"fg": "red", "bold": True},
            "builtin": {"fg": "cyan"},
            "function": {"fg": "blue", "bold": True},
            "class": {"fg": "cyan", "bold": True},
            "string": {"fg": "green"},
            "string_escape": {"fg": "yellow"},
            "number": {"fg": "208"},
            "comment": {"fg": "gray", "dim": True},
            "operator": {"fg": "white"},
            "punctuation": {"fg": "white"},
            "decorator": {"fg": "yellow", "bold": True},
            "type": {"fg": "cyan"},
            "variable": {"fg": "white"},
            "constant": {"fg": "208", "bold": True},
            "tag": {"fg": "red"},
            "attribute": {"fg": "yellow"},
            "property": {"fg": "cyan"},
            "regex": {"fg": "orange"},
            "error": {"fg": "red", "underline": True},
        }
    },
    "matrix": {
        "name": "ğŸ’š ĞœĞ°Ñ‚Ñ€Ğ¸Ñ†Ğ°",
        "description": "Ğ—ĞµĞ»Ñ‘Ğ½Ñ‹Ğ¹ Ğ½Ğ° Ñ‡Ñ‘Ñ€Ğ½Ğ¾Ğ¼ - ĞºĞ»Ğ°ÑÑĞ¸ĞºĞ° ĞºĞ¸Ğ±ĞµÑ€Ğ¿Ğ°Ğ½ĞºĞ°",
        "colors": {
            "bg": "default",
            "fg": "green",
            "header_bg": "green",
            "header_fg": "black",
            "footer_bg": "green",
            "footer_fg": "black",
            "sidebar_bg": "default",
            "sidebar_fg": "green",
            "line_number": "34",
            "line_number_active": "green",
            "current_line": "22",
            "selection": "22",
            "cursor": "green",
            "matching_bracket": "lime",
            "search_match": "lime",
            "error": "red",
            "warning": "yellow",
            "info": "green",
            "success": "lime",
        },
        "syntax": {
            "keyword": {"fg": "green", "bold": True},
            "keyword2": {"fg": "lime", "bold": True},
            "builtin": {"fg": "34"},
            "function": {"fg": "green", "bold": True},
            "class": {"fg": "lime", "bold": True},
            "string": {"fg": "28"},
            "number": {"fg": "40"},
            "comment": {"fg": "22", "dim": True},
            "operator": {"fg": "green"},
            "decorator": {"fg": "lime"},
            "type": {"fg": "34"},
        }
    },
    "dracula": {
        "name": "ğŸ§› Ğ”Ñ€Ğ°ĞºÑƒĞ»Ğ°",
        "description": "ĞŸĞ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ğ°Ñ Ñ‚Ñ‘Ğ¼Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ° Ñ ÑÑ€ĞºĞ¸Ğ¼Ğ¸ Ğ°ĞºÑ†ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸",
        "colors": {
            "bg": "default",
            "fg": "white",
            "header_bg": "141",
            "header_fg": "black",
            "footer_bg": "141",
            "footer_fg": "black",
            "sidebar_bg": "default",
            "sidebar_fg": "141",
            "line_number": "61",
            "line_number_active": "141",
            "current_line": "236",
            "selection": "60",
            "cursor": "white",
        },
        "syntax": {
            "keyword": {"fg": "212", "bold": True},
            "builtin": {"fg": "117"},
            "function": {"fg": "84", "bold": True},
            "class": {"fg": "117", "bold": True},
            "string": {"fg": "228"},
            "number": {"fg": "141"},
            "comment": {"fg": "103"},
            "decorator": {"fg": "84"},
        }
    },
    "monokai": {
        "name": "ğŸ¨ Monokai",
        "description": "Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ° Ğ¸Ğ· Sublime Text",
        "colors": {
            "bg": "default",
            "fg": "white",
            "header_bg": "208",
            "header_fg": "black",
            "footer_bg": "208",
            "footer_fg": "black",
            "line_number": "59",
            "current_line": "237",
            "selection": "59",
        },
        "syntax": {
            "keyword": {"fg": "197", "bold": True},
            "builtin": {"fg": "81"},
            "function": {"fg": "148", "bold": True},
            "class": {"fg": "81", "bold": True},
            "string": {"fg": "186"},
            "number": {"fg": "141"},
            "comment": {"fg": "59"},
            "decorator": {"fg": "148"},
        }
    },
    "ocean": {
        "name": "ğŸŒŠ ĞĞºĞµĞ°Ğ½",
        "description": "Ğ¡Ğ¿Ğ¾ĞºĞ¾Ğ¹Ğ½Ñ‹Ğµ Ğ¼Ğ¾Ñ€ÑĞºĞ¸Ğµ Ğ¾Ñ‚Ñ‚ĞµĞ½ĞºĞ¸",
        "colors": {
            "bg": "default",
            "fg": "cyan",
            "header_bg": "30",
            "header_fg": "white",
            "footer_bg": "30",
            "footer_fg": "white",
            "line_number": "24",
            "current_line": "23",
        },
        "syntax": {
            "keyword": {"fg": "75", "bold": True},
            "builtin": {"fg": "44"},
            "function": {"fg": "39", "bold": True},
            "string": {"fg": "29"},
            "number": {"fg": "147"},
            "comment": {"fg": "24"},
        }
    },
    "sunset": {
        "name": "ğŸŒ… Ğ—Ğ°ĞºĞ°Ñ‚",
        "description": "Ğ¢Ñ‘Ğ¿Ğ»Ñ‹Ğµ Ğ¾Ñ€Ğ°Ğ½Ğ¶ĞµĞ²Ñ‹Ğµ Ğ¸ ĞºÑ€Ğ°ÑĞ½Ñ‹Ğµ Ñ‚Ğ¾Ğ½Ğ°",
        "colors": {
            "bg": "default",
            "fg": "223",
            "header_bg": "166",
            "header_fg": "black",
            "footer_bg": "166",
            "footer_fg": "black",
            "line_number": "130",
            "current_line": "52",
        },
        "syntax": {
            "keyword": {"fg": "203", "bold": True},
            "builtin": {"fg": "216"},
            "function": {"fg": "220", "bold": True},
            "string": {"fg": "180"},
            "number": {"fg": "215"},
            "comment": {"fg": "95"},
        }
    },
    "nord": {
        "name": "â„ï¸ Nord",
        "description": "Ğ¥Ğ¾Ğ»Ğ¾Ğ´Ğ½Ğ°Ñ ÑĞºĞ°Ğ½Ğ´Ğ¸Ğ½Ğ°Ğ²ÑĞºĞ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°",
        "colors": {
            "bg": "default",
            "fg": "253",
            "header_bg": "67",
            "header_fg": "white",
            "footer_bg": "67",
            "footer_fg": "white",
            "line_number": "60",
            "current_line": "236",
        },
        "syntax": {
            "keyword": {"fg": "110", "bold": True},
            "builtin": {"fg": "138"},
            "function": {"fg": "109", "bold": True},
            "string": {"fg": "108"},
            "number": {"fg": "175"},
            "comment": {"fg": "60"},
        }
    },
    "gruvbox": {
        "name": "ğŸ“¦ Gruvbox",
        "description": "Ğ ĞµÑ‚Ñ€Ğ¾ Ñ‚Ñ‘Ğ¿Ğ»Ñ‹Ğµ Ñ‚Ğ¾Ğ½Ğ°",
        "colors": {
            "bg": "default",
            "fg": "223",
            "header_bg": "106",
            "header_fg": "black",
            "footer_bg": "106",
            "footer_fg": "black",
            "line_number": "245",
            "current_line": "237",
        },
        "syntax": {
            "keyword": {"fg": "167", "bold": True},
            "builtin": {"fg": "142"},
            "function": {"fg": "108", "bold": True},
            "string": {"fg": "142"},
            "number": {"fg": "175"},
            "comment": {"fg": "102"},
        }
    },
    "solarized_dark": {
        "name": "â˜€ï¸ Solarized Dark",
        "description": "ĞĞ°ÑƒÑ‡Ğ½Ğ¾ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°",
        "colors": {
            "bg": "default",
            "fg": "245",
            "header_bg": "33",
            "header_fg": "white",
            "footer_bg": "33",
            "footer_fg": "white",
            "line_number": "240",
            "current_line": "235",
        },
        "syntax": {
            "keyword": {"fg": "136", "bold": True},
            "builtin": {"fg": "33"},
            "function": {"fg": "37", "bold": True},
            "string": {"fg": "64"},
            "number": {"fg": "166"},
            "comment": {"fg": "240"},
        }
    },
    "high_contrast": {
        "name": "ğŸ‘ï¸ Ğ’Ñ‹ÑĞ¾ĞºĞ¸Ğ¹ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ÑÑ‚",
        "description": "Ğ”Ğ»Ñ Ğ»ÑĞ´ĞµĞ¹ Ñ Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ·Ñ€ĞµĞ½Ğ¸Ñ",
        "colors": {
            "bg": "black",
            "fg": "white",
            "header_bg": "white",
            "header_fg": "black",
            "footer_bg": "white",
            "footer_fg": "black",
            "line_number": "white",
            "current_line": "236",
        },
        "syntax": {
            "keyword": {"fg": "yellow", "bold": True},
            "builtin": {"fg": "cyan", "bold": True},
            "function": {"fg": "green", "bold": True},
            "string": {"fg": "magenta", "bold": True},
            "number": {"fg": "cyan", "bold": True},
            "comment": {"fg": "green"},
        }
    },
}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• ĞšĞ›ĞĞ¡Ğ¡Ğ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Position:
    """ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² Ñ‚ĞµĞºÑÑ‚Ğµ"""
    __slots__ = ['line', 'col']
    
    def __init__(self, line: int = 0, col: int = 0):
        self.line = line
        self.col = col
    
    def __eq__(self, other):
        return self.line == other.line and self.col == other.col
    
    def __lt__(self, other):
        if self.line != other.line:
            return self.line < other.line
        return self.col < other.col
    
    def __le__(self, other):
        return self == other or self < other
    
    def __hash__(self):
        return hash((self.line, self.col))
    
    def copy(self):
        return Position(self.line, self.col)
    
    def __repr__(self):
        return f"Pos({self.line}:{self.col})"


class Selection:
    """Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑÑ‚Ğ°"""
    __slots__ = ['start', 'end']
    
    def __init__(self, start: Position = None, end: Position = None):
        self.start = start or Position()
        self.end = end or Position()
    
    @property
    def is_empty(self) -> bool:
        return self.start == self.end
    
    @property
    def normalized(self) -> 'Selection':
        """Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ start <= end"""
        if self.start <= self.end:
            return Selection(self.start.copy(), self.end.copy())
        return Selection(self.end.copy(), self.start.copy())
    
    def contains(self, pos: Position) -> bool:
        """Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ"""
        n = self.normalized
        return n.start <= pos <= n.end


class Cursor:
    """ĞšÑƒÑ€ÑĞ¾Ñ€ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ñ"""
    
    def __init__(self, line: int = 0, col: int = 0):
        self.position = Position(line, col)
        self.selection_anchor: Optional[Position] = None
        self.preferred_col: int = 0  # Ğ”Ğ»Ñ Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ
    
    @property
    def line(self) -> int:
        return self.position.line
    
    @line.setter
    def line(self, value: int):
        self.position.line = value
    
    @property
    def col(self) -> int:
        return self.position.col
    
    @col.setter
    def col(self, value: int):
        self.position.col = value
        self.preferred_col = value
    
    def start_selection(self):
        """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ"""
        self.selection_anchor = self.position.copy()
    
    def clear_selection(self):
        """ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ"""
        self.selection_anchor = None
    
    @property
    def has_selection(self) -> bool:
        return self.selection_anchor is not None and self.selection_anchor != self.position
    
    @property
    def selection(self) -> Optional[Selection]:
        if not self.has_selection:
            return None
        return Selection(self.selection_anchor, self.position).normalized
    
    def copy(self) -> 'Cursor':
        c = Cursor(self.line, self.col)
        c.preferred_col = self.preferred_col
        if self.selection_anchor:
            c.selection_anchor = self.selection_anchor.copy()
        return c


class UndoAction:
    """Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹"""
    
    def __init__(self, action_type: str, data: dict, cursor_before: Cursor, cursor_after: Cursor = None):
        self.action_type = action_type
        self.data = data
        self.cursor_before = cursor_before.copy()
        self.cursor_after = cursor_after.copy() if cursor_after else cursor_before.copy()
        self.timestamp = time.time()


class UndoManager:
    """ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ undo/redo Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹"""
    
    def __init__(self, max_size: int = 1000):
        self.undo_stack: deque = deque(maxlen=max_size)
        self.redo_stack: deque = deque(maxlen=max_size)
        self.current_group: List[UndoAction] = []
        self.grouping = False
    
    def begin_group(self):
        """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹"""
        self.grouping = True
        self.current_group = []
    
    def end_group(self):
        """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹"""
        if self.current_group:
            self.undo_stack.append(self.current_group)
            self.redo_stack.clear()
        self.grouping = False
        self.current_group = []
    
    def push(self, action: UndoAction):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ"""
        if self.grouping:
            self.current_group.append(action)
        else:
            self.undo_stack.append([action])
            self.redo_stack.clear()
    
    def undo(self) -> Optional[List[UndoAction]]:
        """ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ/Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ"""
        if not self.undo_stack:
            return None
        actions = self.undo_stack.pop()
        self.redo_stack.append(actions)
        return actions
    
    def redo(self) -> Optional[List[UndoAction]]:
        """ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ğ¾Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ"""
        if not self.redo_stack:
            return None
        actions = self.redo_stack.pop()
        self.undo_stack.append(actions)
        return actions
    
    def clear(self):
        """ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ"""
        self.undo_stack.clear()
        self.redo_stack.clear()
        self.current_group = []
        self.grouping = False
    
    @property
    def can_undo(self) -> bool:
        return len(self.undo_stack) > 0
    
    @property
    def can_redo(self) -> bool:
        return len(self.redo_stack) > 0


class EventEmitter:
    """ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ event emitter Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ¾Ğ²"""
    
    def __init__(self):
        self._listeners: Dict[str, List[Callable]] = defaultdict(list)
    
    def on(self, event: str, callback: Callable):
        """ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ"""
        self._listeners[event].append(callback)
    
    def off(self, event: str, callback: Callable):
        """ĞÑ‚Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ¾Ñ‚ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ"""
        if callback in self._listeners[event]:
            self._listeners[event].remove(callback)
    
    def emit(self, event: str, *args, **kwargs):
        """Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ"""
        for callback in self._listeners[event]:
            try:
                callback(*args, **kwargs)
            except Exception as e:
                pass  # Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ² Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ°Ñ…


# ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ§Ğ°ÑÑ‚Ğ¸ 2...
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Ğ¯Ğ—Ğ«ĞšĞ˜ ĞŸĞ ĞĞ“Ğ ĞĞœĞœĞ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ (30+)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LANGUAGES = {
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ PYTHON
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "python": {
        "name": "Python",
        "icon": "ğŸ",
        "extensions": [".py", ".pyw", ".pyi", ".pyx", ".pxd"],
        "filenames": ["Pipfile", "SConstruct", "SConscript"],
        "shebangs": ["python", "python3"],
        "run_command": "python3 {file}",
        "repl": "python3",
        "comment_single": "#",
        "comment_multi": ('"""', '"""'),
        "string_delimiters": ['"""', "'''", '"', "'"],
        "indent": 4,
        "keywords": [
            "and", "as", "assert", "async", "await", "break", "class", "continue",
            "def", "del", "elif", "else", "except", "finally", "for", "from",
            "global", "if", "import", "in", "is", "lambda", "nonlocal", "not",
            "or", "pass", "raise", "return", "try", "while", "with", "yield",
            "True", "False", "None", "match", "case", "type"
        ],
        "builtins": [
            "abs", "aiter", "all", "any", "anext", "ascii", "bin", "bool",
            "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod",
            "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate",
            "eval", "exec", "filter", "float", "format", "frozenset", "getattr",
            "globals", "hasattr", "hash", "help", "hex", "id", "input", "int",
            "isinstance", "issubclass", "iter", "len", "list", "locals", "map",
            "max", "memoryview", "min", "next", "object", "oct", "open", "ord",
            "pow", "print", "property", "range", "repr", "reversed", "round",
            "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum",
            "super", "tuple", "type", "vars", "zip", "__import__"
        ],
        "types": [
            "int", "str", "float", "bool", "list", "dict", "set", "tuple",
            "bytes", "bytearray", "complex", "frozenset", "type", "object",
            "Optional", "Union", "List", "Dict", "Set", "Tuple", "Any",
            "Callable", "Iterable", "Iterator", "Generator", "Sequence"
        ],
        "constants": ["True", "False", "None", "Ellipsis", "NotImplemented", "__debug__"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {
            "def": "def ${1:name}(${2:args}):\n    ${3:pass}",
            "class": "class ${1:Name}:\n    def __init__(self${2:, args}):\n        ${3:pass}",
            "if": "if ${1:condition}:\n    ${2:pass}",
            "elif": "elif ${1:condition}:\n    ${2:pass}",
            "else": "else:\n    ${1:pass}",
            "for": "for ${1:item} in ${2:iterable}:\n    ${3:pass}",
            "while": "while ${1:condition}:\n    ${2:pass}",
            "try": "try:\n    ${1:pass}\nexcept ${2:Exception} as ${3:e}:\n    ${4:pass}",
            "tryf": "try:\n    ${1:pass}\nexcept ${2:Exception} as ${3:e}:\n    ${4:pass}\nfinally:\n    ${5:pass}",
            "with": "with ${1:context} as ${2:var}:\n    ${3:pass}",
            "lambda": "lambda ${1:x}: ${2:x}",
            "list": "[${1:x} for ${1:x} in ${2:iterable}]",
            "dict": "{${1:k}: ${2:v} for ${1:k}, ${2:v} in ${3:items}}",
            "set": "{${1:x} for ${1:x} in ${2:iterable}}",
            "gen": "(${1:x} for ${1:x} in ${2:iterable})",
            "main": 'if __name__ == "__main__":\n    ${1:main()}',
            "print": 'print(${1:"message"})',
            "pf": 'print(f"${1:message}")',
            "pd": 'print(f"{${1:var}=}")',
            "input": '${1:var} = input("${2:prompt}: ")',
            "open": 'with open("${1:file}", "${2:r}") as ${3:f}:\n    ${4:pass}',
            "async": "async def ${1:name}(${2:args}):\n    ${3:pass}",
            "await": "await ${1:coroutine}",
            "deco": "def ${1:decorator}(func):\n    def wrapper(*args, **kwargs):\n        ${2:pass}\n        return func(*args, **kwargs)\n    return wrapper",
            "prop": "@property\ndef ${1:name}(self):\n    return self._${1:name}",
            "setter": "@${1:name}.setter\ndef ${1:name}(self, value):\n    self._${1:name} = value",
            "dataclass": "@dataclass\nclass ${1:Name}:\n    ${2:field}: ${3:type}",
            "namedtuple": "${1:Name} = namedtuple('${1:Name}', [${2:'field1', 'field2'}])",
            "enum": "class ${1:Name}(Enum):\n    ${2:VALUE} = ${3:1}",
            "logger": 'logger = logging.getLogger(__name__)',
            "argparse": 'parser = argparse.ArgumentParser(description="${1:description}")\nparser.add_argument("${2:arg}", help="${3:help}")\nargs = parser.parse_args()',
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“œ JAVASCRIPT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "javascript": {
        "name": "JavaScript",
        "icon": "ğŸ“œ",
        "extensions": [".js", ".mjs", ".cjs", ".jsx"],
        "filenames": [".eslintrc.js", "webpack.config.js", "rollup.config.js"],
        "run_command": "node {file}",
        "repl": "node",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "string_delimiters": ['`', '"', "'"],
        "indent": 2,
        "keywords": [
            "async", "await", "break", "case", "catch", "class", "const",
            "continue", "debugger", "default", "delete", "do", "else", "export",
            "extends", "finally", "for", "function", "if", "import", "in",
            "instanceof", "let", "new", "of", "return", "static", "super",
            "switch", "this", "throw", "try", "typeof", "var", "void", "while",
            "with", "yield", "true", "false", "null", "undefined", "NaN", "Infinity"
        ],
        "builtins": [
            "Array", "ArrayBuffer", "Atomics", "BigInt", "BigInt64Array",
            "BigUint64Array", "Boolean", "DataView", "Date", "Error", "EvalError",
            "Float32Array", "Float64Array", "Function", "Generator", "GeneratorFunction",
            "Int16Array", "Int32Array", "Int8Array", "Intl", "JSON", "Map", "Math",
            "Number", "Object", "Promise", "Proxy", "RangeError", "ReferenceError",
            "Reflect", "RegExp", "Set", "SharedArrayBuffer", "String", "Symbol",
            "SyntaxError", "TypeError", "URIError", "Uint16Array", "Uint32Array",
            "Uint8Array", "Uint8ClampedArray", "WeakMap", "WeakRef", "WeakSet",
            "console", "window", "document", "globalThis", "fetch", "setTimeout",
            "setInterval", "clearTimeout", "clearInterval", "alert", "confirm", "prompt"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "`": "`"},
        "snippets": {
            "fn": "function ${1:name}(${2:args}) {\n  ${3}\n}",
            "afn": "async function ${1:name}(${2:args}) {\n  ${3}\n}",
            "arrow": "const ${1:name} = (${2:args}) => {\n  ${3}\n}",
            "arrowone": "const ${1:name} = (${2:args}) => ${3}",
            "class": "class ${1:Name} {\n  constructor(${2:args}) {\n    ${3}\n  }\n}",
            "extends": "class ${1:Name} extends ${2:Parent} {\n  constructor(${3:args}) {\n    super(${4});\n    ${5}\n  }\n}",
            "if": "if (${1:condition}) {\n  ${2}\n}",
            "ife": "if (${1:condition}) {\n  ${2}\n} else {\n  ${3}\n}",
            "for": "for (let ${1:i} = 0; ${1:i} < ${2:length}; ${1:i}++) {\n  ${3}\n}",
            "forin": "for (const ${1:key} in ${2:object}) {\n  ${3}\n}",
            "forof": "for (const ${1:item} of ${2:iterable}) {\n  ${3}\n}",
            "foreach": "${1:array}.forEach((${2:item}) => {\n  ${3}\n})",
            "map": "${1:array}.map((${2:item}) => ${3})",
            "filter": "${1:array}.filter((${2:item}) => ${3})",
            "reduce": "${1:array}.reduce((${2:acc}, ${3:item}) => ${4}, ${5:initial})",
            "try": "try {\n  ${1}\n} catch (${2:error}) {\n  ${3}\n}",
            "tryf": "try {\n  ${1}\n} catch (${2:error}) {\n  ${3}\n} finally {\n  ${4}\n}",
            "promise": "new Promise((resolve, reject) => {\n  ${1}\n})",
            "async": "async (${1:args}) => {\n  ${2}\n}",
            "await": "await ${1:promise}",
            "import": "import ${1:module} from '${2:path}'",
            "importd": "import { ${1:named} } from '${2:path}'",
            "export": "export ${1:const ${2:name} = ${3}}",
            "exportd": "export default ${1}",
            "log": "console.log(${1})",
            "logv": "console.log('${1}:', ${1})",
            "error": "console.error(${1})",
            "warn": "console.warn(${1})",
            "fetch": "fetch('${1:url}')\n  .then(res => res.json())\n  .then(data => {\n    ${2}\n  })\n  .catch(err => console.error(err))",
            "afetch": "const ${1:response} = await fetch('${2:url}')\nconst ${3:data} = await ${1:response}.json()",
            "timeout": "setTimeout(() => {\n  ${1}\n}, ${2:1000})",
            "interval": "setInterval(() => {\n  ${1}\n}, ${2:1000})",
            "qs": "document.querySelector('${1:selector}')",
            "qsa": "document.querySelectorAll('${1:selector}')",
            "el": "document.getElementById('${1:id}')",
            "ce": "document.createElement('${1:tag}')",
            "ae": "${1:element}.addEventListener('${2:event}', (${3:e}) => {\n  ${4}\n})",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ’  TYPESCRIPT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "typescript": {
        "name": "TypeScript",
        "icon": "ğŸ’ ",
        "extensions": [".ts", ".tsx", ".mts", ".cts"],
        "run_command": "npx ts-node {file}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 2,
        "keywords": [
            "abstract", "as", "async", "await", "break", "case", "catch", "class",
            "const", "continue", "debugger", "declare", "default", "delete", "do",
            "else", "enum", "export", "extends", "finally", "for", "from",
            "function", "get", "if", "implements", "import", "in", "infer",
            "instanceof", "interface", "is", "keyof", "let", "module", "namespace",
            "never", "new", "of", "package", "private", "protected", "public",
            "readonly", "return", "require", "set", "static", "super", "switch",
            "this", "throw", "try", "type", "typeof", "undefined", "unique",
            "unknown", "var", "void", "while", "with", "yield", "true", "false", "null"
        ],
        "types": [
            "any", "boolean", "number", "string", "symbol", "void", "never",
            "unknown", "null", "undefined", "object", "bigint", "Array", "Record",
            "Partial", "Required", "Readonly", "Pick", "Omit", "Exclude", "Extract",
            "NonNullable", "Parameters", "ReturnType", "InstanceType", "Promise"
        ],
        "builtins": [
            "Array", "Boolean", "Date", "Error", "Function", "JSON", "Map", "Math",
            "Number", "Object", "Promise", "Proxy", "Reflect", "RegExp", "Set",
            "String", "Symbol", "WeakMap", "WeakSet", "console", "setTimeout",
            "setInterval", "clearTimeout", "clearInterval", "fetch"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "`": "`", "<": ">"},
        "snippets": {
            "interface": "interface ${1:Name} {\n  ${2:property}: ${3:type};\n}",
            "type": "type ${1:Name} = ${2:type}",
            "enum": "enum ${1:Name} {\n  ${2:Value} = ${3}'value'},\n}",
            "class": "class ${1:Name} {\n  constructor(${2:private ${3:prop}: ${4:type}}) {}\n}",
            "fn": "function ${1:name}(${2:args}: ${3:type}): ${4:ReturnType} {\n  ${5}\n}",
            "afn": "async function ${1:name}(${2:args}: ${3:type}): Promise<${4:ReturnType}> {\n  ${5}\n}",
            "arrow": "const ${1:name} = (${2:args}: ${3:type}): ${4:ReturnType} => {\n  ${5}\n}",
            "generic": "function ${1:name}<${2:T}>(${3:arg}: ${2:T}): ${2:T} {\n  ${4}\n}",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŒ HTML
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "html": {
        "name": "HTML",
        "icon": "ğŸŒ",
        "extensions": [".html", ".htm", ".xhtml", ".shtml"],
        "run_command": "xdg-open {file} 2>/dev/null || open {file} 2>/dev/null || start {file}",
        "comment_single": None,
        "comment_multi": ("<!--", "-->"),
        "indent": 2,
        "keywords": [
            "html", "head", "body", "title", "meta", "link", "script", "style",
            "div", "span", "p", "a", "img", "ul", "ol", "li", "table", "tr", "td",
            "th", "thead", "tbody", "tfoot", "form", "input", "button", "select",
            "option", "textarea", "label", "header", "footer", "nav", "main",
            "section", "article", "aside", "h1", "h2", "h3", "h4", "h5", "h6",
            "br", "hr", "strong", "em", "b", "i", "u", "code", "pre", "blockquote",
            "iframe", "video", "audio", "canvas", "svg", "source", "picture",
            "figure", "figcaption", "details", "summary", "dialog", "template"
        ],
        "builtins": [
            "class", "id", "style", "href", "src", "alt", "title", "type", "name",
            "value", "placeholder", "disabled", "readonly", "required", "checked",
            "selected", "multiple", "action", "method", "target", "rel", "media",
            "width", "height", "data-", "aria-", "role", "tabindex", "lang", "dir"
        ],
        "auto_pairs": {"<": ">", '"': '"', "'": "'"},
        "snippets": {
            "html5": '<!DOCTYPE html>\n<html lang="${1:en}">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>${2:Document}</title>\n</head>\n<body>\n  ${3}\n</body>\n</html>',
            "div": '<div class="${1:class}">\n  ${2}\n</div>',
            "divc": '<div class="${1:container}">\n  ${2}\n</div>',
            "span": '<span class="${1:class}">${2}</span>',
            "a": '<a href="${1:#}">${2:Link}</a>',
            "img": '<img src="${1:src}" alt="${2:alt}">',
            "link": '<link rel="stylesheet" href="${1:style.css}">',
            "script": '<script src="${1:script.js}"></script>',
            "scripti": '<script>\n  ${1}\n</script>',
            "style": '<style>\n  ${1}\n</style>',
            "ul": '<ul>\n  <li>${1}</li>\n</ul>',
            "ol": '<ol>\n  <li>${1}</li>\n</ol>',
            "li": '<li>${1}</li>',
            "table": '<table>\n  <thead>\n    <tr>\n      <th>${1}</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>${2}</td>\n    </tr>\n  </tbody>\n</table>',
            "form": '<form action="${1:#}" method="${2:post}">\n  ${3}\n</form>',
            "input": '<input type="${1:text}" name="${2:name}" placeholder="${3:placeholder}">',
            "button": '<button type="${1:button}">${2:Click}</button>',
            "select": '<select name="${1:name}">\n  <option value="${2:value}">${3:Option}</option>\n</select>',
            "textarea": '<textarea name="${1:name}" rows="${2:4}" cols="${3:50}">${4}</textarea>',
            "label": '<label for="${1:id}">${2:Label}</label>',
            "meta": '<meta name="${1:name}" content="${2:content}">',
            "metav": '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¨ CSS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "css": {
        "name": "CSS",
        "icon": "ğŸ¨",
        "extensions": [".css", ".scss", ".sass", ".less", ".styl"],
        "comment_single": None,
        "comment_multi": ("/*", "*/"),
        "indent": 2,
        "keywords": [
            "@import", "@media", "@keyframes", "@font-face", "@supports", "@charset",
            "@namespace", "@page", "@viewport", "@layer", "@container", "@property",
            "!important", "from", "to"
        ],
        "builtins": [
            "color", "background", "background-color", "background-image", "background-size",
            "border", "border-radius", "border-color", "border-width", "border-style",
            "margin", "margin-top", "margin-right", "margin-bottom", "margin-left",
            "padding", "padding-top", "padding-right", "padding-bottom", "padding-left",
            "width", "height", "min-width", "max-width", "min-height", "max-height",
            "display", "flex", "grid", "position", "top", "right", "bottom", "left",
            "font-size", "font-family", "font-weight", "font-style", "text-align",
            "line-height", "letter-spacing", "text-decoration", "text-transform",
            "transform", "transition", "animation", "opacity", "visibility", "z-index",
            "overflow", "box-shadow", "cursor", "pointer-events", "user-select",
            "flex-direction", "justify-content", "align-items", "flex-wrap", "gap",
            "grid-template-columns", "grid-template-rows", "grid-gap", "grid-area"
        ],
        "auto_pairs": {"{": "}", "(": ")", "[": "]", '"': '"', "'": "'"},
        "snippets": {
            "flex": "display: flex;\njustify-content: ${1:center};\nalign-items: ${2:center};",
            "flexc": "display: flex;\nflex-direction: column;\njustify-content: ${1:center};\nalign-items: ${2:center};",
            "grid": "display: grid;\ngrid-template-columns: ${1:repeat(3, 1fr)};\ngap: ${2:1rem};",
            "center": "display: flex;\njustify-content: center;\nalign-items: center;",
            "abs": "position: absolute;\ntop: ${1:0};\nleft: ${2:0};",
            "fixed": "position: fixed;\ntop: ${1:0};\nleft: ${2:0};",
            "media": "@media (${1:max-width}: ${2:768px}) {\n  ${3}\n}",
            "keyframes": "@keyframes ${1:name} {\n  0% {\n    ${2}\n  }\n  100% {\n    ${3}\n  }\n}",
            "var": "var(--${1:name})",
            "calc": "calc(${1:100%} - ${2:20px})",
            "transition": "transition: ${1:all} ${2:0.3s} ${3:ease};",
            "shadow": "box-shadow: ${1:0} ${2:2px} ${3:4px} rgba(0, 0, 0, ${4:0.1});",
            "gradient": "background: linear-gradient(${1:to right}, ${2:#000}, ${3:#fff});",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ˜ PHP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "php": {
        "name": "PHP",
        "icon": "ğŸ˜",
        "extensions": [".php", ".phtml", ".php3", ".php4", ".php5", ".phps"],
        "run_command": "php {file}",
        "repl": "php -a",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "abstract", "and", "array", "as", "break", "callable", "case", "catch",
            "class", "clone", "const", "continue", "declare", "default", "die", "do",
            "echo", "else", "elseif", "empty", "enddeclare", "endfor", "endforeach",
            "endif", "endswitch", "endwhile", "eval", "exit", "extends", "final",
            "finally", "fn", "for", "foreach", "function", "global", "goto", "if",
            "implements", "include", "include_once", "instanceof", "insteadof",
            "interface", "isset", "list", "match", "namespace", "new", "or", "print",
            "private", "protected", "public", "readonly", "require", "require_once",
            "return", "static", "switch", "throw", "trait", "try", "unset", "use",
            "var", "while", "xor", "yield", "true", "false", "null"
        ],
        "builtins": [
            "echo", "print", "strlen", "strpos", "substr", "str_replace", "strtolower",
            "strtoupper", "trim", "explode", "implode", "array_push", "array_pop",
            "array_shift", "array_unshift", "array_merge", "array_map", "array_filter",
            "array_keys", "array_values", "count", "sizeof", "isset", "empty", "unset",
            "is_array", "is_string", "is_numeric", "is_null", "is_bool", "json_encode",
            "json_decode", "file_get_contents", "file_put_contents", "fopen", "fclose",
            "preg_match", "preg_replace", "sprintf", "printf", "date", "time", "strtotime"
        ],
        "types": ["int", "float", "string", "bool", "array", "object", "callable", "iterable", "mixed", "void", "null"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {
            "php": "<?php\n${1}\n?>",
            "fn": "function ${1:name}(${2:args}): ${3:void} {\n    ${4}\n}",
            "class": "class ${1:Name} {\n    public function __construct(${2:args}) {\n        ${3}\n    }\n}",
            "if": "if (${1:condition}) {\n    ${2}\n}",
            "foreach": "foreach (${1:array} as ${2:key} => ${3:value}) {\n    ${4}\n}",
            "echo": "echo ${1:\"message\"};",
            "var_dump": "var_dump(${1:variable});",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ’ RUBY
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "ruby": {
        "name": "Ruby",
        "icon": "ğŸ’",
        "extensions": [".rb", ".rake", ".gemspec", ".ru", ".erb"],
        "filenames": ["Rakefile", "Gemfile", "Guardfile", "Vagrantfile"],
        "run_command": "ruby {file}",
        "repl": "irb",
        "comment_single": "#",
        "comment_multi": ("=begin", "=end"),
        "indent": 2,
        "keywords": [
            "alias", "and", "begin", "break", "case", "class", "def", "defined?",
            "do", "else", "elsif", "end", "ensure", "false", "for", "if", "in",
            "module", "next", "nil", "not", "or", "redo", "rescue", "retry",
            "return", "self", "super", "then", "true", "undef", "unless", "until",
            "when", "while", "yield", "__FILE__", "__LINE__", "__ENCODING__",
            "BEGIN", "END", "attr_reader", "attr_writer", "attr_accessor",
            "private", "protected", "public", "require", "require_relative",
            "include", "extend", "prepend", "raise", "lambda", "proc"
        ],
        "builtins": [
            "puts", "print", "p", "pp", "gets", "chomp", "to_s", "to_i", "to_f",
            "to_a", "to_h", "length", "size", "count", "each", "map", "select",
            "reject", "find", "reduce", "inject", "sort", "reverse", "push", "pop",
            "shift", "unshift", "join", "split", "gsub", "sub", "match", "include?",
            "empty?", "nil?", "any?", "all?", "none?", "one?", "first", "last"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "|": "|"},
        "snippets": {
            "def": "def ${1:name}(${2:args})\n  ${3}\nend",
            "class": "class ${1:Name}\n  def initialize(${2:args})\n    ${3}\n  end\nend",
            "module": "module ${1:Name}\n  ${2}\nend",
            "if": "if ${1:condition}\n  ${2}\nend",
            "unless": "unless ${1:condition}\n  ${2}\nend",
            "each": "${1:collection}.each do |${2:item}|\n  ${3}\nend",
            "map": "${1:collection}.map { |${2:item}| ${3} }",
            "block": "do |${1:args}|\n  ${2}\nend",
            "lambda": "->(${1:args}) { ${2} }",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¹ GO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "go": {
        "name": "Go",
        "icon": "ğŸ¹",
        "extensions": [".go"],
        "run_command": "go run {file}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "break", "case", "chan", "const", "continue", "default", "defer",
            "else", "fallthrough", "for", "func", "go", "goto", "if", "import",
            "interface", "map", "package", "range", "return", "select", "struct",
            "switch", "type", "var", "true", "false", "nil", "iota"
        ],
        "builtins": [
            "append", "cap", "close", "complex", "copy", "delete", "imag", "len",
            "make", "new", "panic", "print", "println", "real", "recover",
            "error", "fmt", "os", "io", "strings", "strconv", "time", "log",
            "http", "json", "context", "sync", "errors"
        ],
        "types": [
            "bool", "string", "int", "int8", "int16", "int32", "int64",
            "uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
            "byte", "rune", "float32", "float64", "complex64", "complex128",
            "error", "any"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "`": "`"},
        "snippets": {
            "main": 'package main\n\nimport "fmt"\n\nfunc main() {\n\t${1}\n}',
            "func": "func ${1:name}(${2:args}) ${3:returnType} {\n\t${4}\n}",
            "method": "func (${1:r} *${2:Receiver}) ${3:name}(${4:args}) ${5:returnType} {\n\t${6}\n}",
            "struct": "type ${1:Name} struct {\n\t${2:Field} ${3:type}\n}",
            "interface": "type ${1:Name} interface {\n\t${2:Method}() ${3:returnType}\n}",
            "if": "if ${1:condition} {\n\t${2}\n}",
            "iferr": "if err != nil {\n\t${1:return err}\n}",
            "for": "for ${1:i} := 0; ${1:i} < ${2:n}; ${1:i}++ {\n\t${3}\n}",
            "forr": "for ${1:i}, ${2:v} := range ${3:slice} {\n\t${4}\n}",
            "switch": "switch ${1:expr} {\ncase ${2:value}:\n\t${3}\ndefault:\n\t${4}\n}",
            "select": "select {\ncase ${1:msg} := <-${2:ch}:\n\t${3}\ndefault:\n\t${4}\n}",
            "go": "go func() {\n\t${1}\n}()",
            "defer": "defer ${1:func}()",
            "make": "make(${1:type}, ${2:len})",
            "print": 'fmt.Println(${1:"message"})',
            "printf": 'fmt.Printf("${1:%v}\\n", ${2:args})',
            "err": 'if err != nil {\n\treturn ${1:nil, }fmt.Errorf("${2:error}: %w", err)\n}',
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¦€ RUST
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "rust": {
        "name": "Rust",
        "icon": "ğŸ¦€",
        "extensions": [".rs"],
        "run_command": "cargo run 2>/dev/null || rustc {file} -o /tmp/rust_out && /tmp/rust_out",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "as", "async", "await", "break", "const", "continue", "crate", "dyn",
            "else", "enum", "extern", "false", "fn", "for", "if", "impl", "in",
            "let", "loop", "match", "mod", "move", "mut", "pub", "ref", "return",
            "self", "Self", "static", "struct", "super", "trait", "true", "type",
            "unsafe", "use", "where", "while", "abstract", "become", "box", "do",
            "final", "macro", "override", "priv", "typeof", "unsized", "virtual", "yield"
        ],
        "builtins": [
            "println!", "print!", "format!", "panic!", "assert!", "assert_eq!",
            "assert_ne!", "debug_assert!", "vec!", "todo!", "unimplemented!",
            "unreachable!", "cfg!", "env!", "include!", "include_str!", "include_bytes!",
            "String", "Vec", "Box", "Rc", "Arc", "Cell", "RefCell", "Option", "Result",
            "Some", "None", "Ok", "Err", "Iterator", "IntoIterator", "Clone", "Copy",
            "Default", "Debug", "Display", "Drop", "Eq", "PartialEq", "Ord", "PartialOrd"
        ],
        "types": [
            "i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64",
            "u128", "usize", "f32", "f64", "bool", "char", "str", "&str", "String"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">", "|": "|"},
        "snippets": {
            "main": "fn main() {\n    ${1}\n}",
            "fn": "fn ${1:name}(${2:args}) -> ${3:ReturnType} {\n    ${4}\n}",
            "struct": "struct ${1:Name} {\n    ${2:field}: ${3:Type},\n}",
            "enum": "enum ${1:Name} {\n    ${2:Variant},\n}",
            "impl": "impl ${1:Type} {\n    ${2}\n}",
            "trait": "trait ${1:Name} {\n    fn ${2:method}(&self)${3};\n}",
            "if": "if ${1:condition} {\n    ${2}\n}",
            "iflet": "if let ${1:Some(x)} = ${2:option} {\n    ${3}\n}",
            "match": "match ${1:expr} {\n    ${2:pattern} => ${3},\n    _ => ${4},\n}",
            "for": "for ${1:item} in ${2:iter} {\n    ${3}\n}",
            "while": "while ${1:condition} {\n    ${2}\n}",
            "loop": "loop {\n    ${1}\n    break;\n}",
            "let": "let ${1:name}: ${2:Type} = ${3:value};",
            "letmut": "let mut ${1:name}: ${2:Type} = ${3:value};",
            "print": 'println!("${1}");',
            "printv": 'println!("{:?}", ${1});',
            "test": "#[test]\nfn ${1:test_name}() {\n    ${2}\n}",
            "derive": "#[derive(${1:Debug, Clone})]",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # â˜• JAVA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    "java": {
        "name": "Java",
        "icon": "â˜•",
        "extensions": [".java"],
        "run_command": "javac {file} && java {name}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "abstract", "assert", "boolean", "break", "byte", "case", "catch",
            "char", "class", "const", "continue", "default", "do", "double",
            "else", "enum", "extends", "final", "finally", "float", "for",
            "goto", "if", "implements", "import", "instanceof", "int", "interface",
            "long", "native", "new", "package", "private", "protected", "public",
            "return", "short", "static", "strictfp", "super", "switch",
            "synchronized", "this", "throw", "throws", "transient", "try",
            "var", "void", "volatile", "while", "true", "false", "null",
            "record", "sealed", "non-sealed", "permits", "yield"
        ],
        "builtins": [
            "System", "String", "Integer", "Double", "Float", "Boolean", "Character",
            "Object", "Class", "Thread", "Runnable", "Exception", "RuntimeException",
            "ArrayList", "HashMap", "HashSet", "LinkedList", "TreeMap", "TreeSet",
            "Collections", "Arrays", "Math", "Random", "Scanner", "StringBuilder",
            "StringBuffer", "Optional", "Stream", "Collectors", "Files", "Paths"
        ],
        "types": [
            "byte", "short", "int", "long", "float", "double", "boolean", "char", "void",
            "String", "Object", "Integer", "Long", "Double", "Float", "Boolean", "Character"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">"},
        "snippets": {
            "main": "public static void main(String[] args) {\n    ${1}\n}",
            "class": "public class ${1:Name} {\n    ${2}\n}",
            "interface": "public interface ${1:Name} {\n    ${2}\n}",
            "method": "public ${1:void} ${2:name}(${3:args}) {\n    ${4}\n}",
            "if": "if (${1:condition}) {\n    ${2}\n}",
            "for": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n    ${3}\n}",
            "foreach": "for (${1:Type} ${2:item} : ${3:collection}) {\n    ${4}\n}",
            "while": "while (${1:condition}) {\n    ${2}\n}",
            "try": "try {\n    ${1}\n} catch (${2:Exception} ${3:e}) {\n    ${4}\n}",
            "sout": "System.out.println(${1});",
            "soutv": 'System.out.println("${1}: " + ${1});',
            "psvm": "public static void main(String[] args) {\n    ${1}\n}",
        }
    },

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ ÑĞ·Ñ‹ĞºĞ¸ - ĞºÑ€Ğ°Ñ‚ĞºĞ¸Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    "c": {
        "name": "C",
        "icon": "âš™ï¸",
        "extensions": [".c", ".h"],
        "run_command": "gcc {file} -o /tmp/c_out && /tmp/c_out",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "auto", "break", "case", "char", "const", "continue", "default", "do",
            "double", "else", "enum", "extern", "float", "for", "goto", "if", "int",
            "long", "register", "return", "short", "signed", "sizeof", "static",
            "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"
        ],
        "builtins": ["printf", "scanf", "malloc", "free", "sizeof", "NULL", "stdin", "stdout", "stderr"],
        "types": ["int", "char", "float", "double", "void", "long", "short", "unsigned", "signed"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {
            "main": '#include <stdio.h>\n\nint main() {\n    ${1}\n    return 0;\n}',
            "printf": 'printf("${1}\\n"${2});',
            "for": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n    ${3}\n}",
        }
    },

    "cpp": {
        "name": "C++",
        "icon": "âš™ï¸",
        "extensions": [".cpp", ".cc", ".cxx", ".hpp", ".hxx", ".h++"],
        "run_command": "g++ {file} -o /tmp/cpp_out && /tmp/cpp_out",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor",
            "bool", "break", "case", "catch", "char", "char8_t", "char16_t", "char32_t",
            "class", "compl", "concept", "const", "consteval", "constexpr", "constinit",
            "const_cast", "continue", "co_await", "co_return", "co_yield", "decltype",
            "default", "delete", "do", "double", "dynamic_cast", "else", "enum",
            "explicit", "export", "extern", "false", "float", "for", "friend", "goto",
            "if", "inline", "int", "long", "mutable", "namespace", "new", "noexcept",
            "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private",
            "protected", "public", "register", "reinterpret_cast", "requires", "return",
            "short", "signed", "sizeof", "static", "static_assert", "static_cast",
            "struct", "switch", "template", "this", "thread_local", "throw", "true",
            "try", "typedef", "typeid", "typename", "union", "unsigned", "using",
            "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"
        ],
        "builtins": ["std", "cout", "cin", "endl", "string", "vector", "map", "set", "pair", "make_pair"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">"},
        "snippets": {
            "main": '#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ${1}\n    return 0;\n}',
            "cout": 'cout << ${1} << endl;',
            "class": "class ${1:Name} {\npublic:\n    ${1:Name}() {}\n    ~${1:Name}() {}\nprivate:\n    ${2}\n};",
        }
    },

    "csharp": {
        "name": "C#",
        "icon": "ğŸ”·",
        "extensions": [".cs", ".csx"],
        "run_command": "dotnet run",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
            "char", "checked", "class", "const", "continue", "decimal", "default",
            "delegate", "do", "double", "else", "enum", "event", "explicit", "extern",
            "false", "finally", "fixed", "float", "for", "foreach", "goto", "if",
            "implicit", "in", "int", "interface", "internal", "is", "lock", "long",
            "namespace", "new", "null", "object", "operator", "out", "override",
            "params", "private", "protected", "public", "readonly", "ref", "return",
            "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
            "struct", "switch", "this", "throw", "true", "try", "typeof", "uint",
            "ulong", "unchecked", "unsafe", "ushort", "using", "var", "virtual",
            "void", "volatile", "while", "async", "await", "record", "init"
        ],
        "builtins": ["Console", "String", "Math", "List", "Dictionary", "Task", "File", "Path"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">"},
        "snippets": {
            "main": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        ${1}\n    }\n}",
            "cw": "Console.WriteLine(${1});",
            "class": "public class ${1:Name} {\n    ${2}\n}",
        }
    },

    "kotlin": {
        "name": "Kotlin",
        "icon": "ğŸ¯",
        "extensions": [".kt", ".kts"],
        "run_command": "kotlin {file}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "as", "break", "class", "continue", "do", "else", "false", "for", "fun",
            "if", "in", "interface", "is", "null", "object", "package", "return",
            "super", "this", "throw", "true", "try", "typealias", "typeof", "val",
            "var", "when", "while", "by", "catch", "constructor", "delegate", "dynamic",
            "field", "file", "finally", "get", "import", "init", "param", "property",
            "receiver", "set", "setparam", "where", "actual", "abstract", "annotation",
            "companion", "const", "crossinline", "data", "enum", "expect", "external",
            "final", "infix", "inline", "inner", "internal", "lateinit", "noinline",
            "open", "operator", "out", "override", "private", "protected", "public",
            "reified", "sealed", "suspend", "tailrec", "vararg"
        ],
        "builtins": ["println", "print", "listOf", "mapOf", "setOf", "arrayOf", "mutableListOf"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">"},
        "snippets": {
            "main": "fun main() {\n    ${1}\n}",
            "fun": "fun ${1:name}(${2:args}): ${3:Unit} {\n    ${4}\n}",
            "class": "class ${1:Name}(${2:args}) {\n    ${3}\n}",
            "data": "data class ${1:Name}(val ${2:field}: ${3:Type})",
        }
    },

    "swift": {
        "name": "Swift",
        "icon": "ğŸ",
        "extensions": [".swift"],
        "run_command": "swift {file}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "associatedtype", "class", "deinit", "enum", "extension", "fileprivate",
            "func", "import", "init", "inout", "internal", "let", "open", "operator",
            "private", "protocol", "public", "rethrows", "static", "struct", "subscript",
            "typealias", "var", "break", "case", "continue", "default", "defer", "do",
            "else", "fallthrough", "for", "guard", "if", "in", "repeat", "return",
            "switch", "where", "while", "as", "catch", "false", "is", "nil", "super",
            "self", "Self", "throw", "throws", "true", "try", "async", "await"
        ],
        "builtins": ["print", "String", "Int", "Double", "Float", "Bool", "Array", "Dictionary", "Set", "Optional"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "<": ">"},
        "snippets": {
            "func": "func ${1:name}(${2:args}) -> ${3:Void} {\n    ${4}\n}",
            "class": "class ${1:Name} {\n    init(${2:args}) {\n        ${3}\n    }\n}",
            "struct": "struct ${1:Name} {\n    ${2}\n}",
            "guard": "guard ${1:condition} else {\n    ${2:return}\n}",
            "iflet": "if let ${1:value} = ${2:optional} {\n    ${3}\n}",
        }
    },

    "bash": {
        "name": "Bash",
        "icon": "ğŸ’»",
        "extensions": [".sh", ".bash", ".zsh", ".fish"],
        "filenames": [".bashrc", ".zshrc", ".profile", ".bash_profile"],
        "shebangs": ["bash", "sh", "zsh"],
        "run_command": "bash {file}",
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "if", "then", "else", "elif", "fi", "case", "esac", "for", "while",
            "until", "do", "done", "in", "function", "select", "time", "coproc",
            "local", "return", "exit", "break", "continue", "declare", "typeset",
            "readonly", "export", "unset", "shift", "source", "alias", "unalias",
            "true", "false"
        ],
        "builtins": [
            "echo", "printf", "read", "cd", "pwd", "ls", "cp", "mv", "rm", "mkdir",
            "rmdir", "touch", "cat", "grep", "sed", "awk", "cut", "sort", "uniq",
            "wc", "head", "tail", "find", "xargs", "test", "expr", "let", "eval",
            "exec", "trap", "wait", "kill", "jobs", "fg", "bg", "set", "env"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "`": "`"},
        "snippets": {
            "shebang": "#!/bin/bash\n\n${1}",
            "if": "if [[ ${1:condition} ]]; then\n    ${2}\nfi",
            "ife": "if [[ ${1:condition} ]]; then\n    ${2}\nelse\n    ${3}\nfi",
            "for": "for ${1:i} in ${2:items}; do\n    ${3}\ndone",
            "while": "while ${1:condition}; do\n    ${2}\ndone",
            "func": "${1:name}() {\n    ${2}\n}",
            "case": "case ${1:var} in\n    ${2:pattern})\n        ${3}\n        ;;\nesac",
        }
    },

    "lua": {
        "name": "Lua",
        "icon": "ğŸŒ™",
        "extensions": [".lua"],
        "run_command": "lua {file}",
        "repl": "lua",
        "comment_single": "--",
        "comment_multi": ("--[[", "]]"),
        "indent": 2,
        "keywords": [
            "and", "break", "do", "else", "elseif", "end", "false", "for",
            "function", "goto", "if", "in", "local", "nil", "not", "or",
            "repeat", "return", "then", "true", "until", "while"
        ],
        "builtins": [
            "print", "type", "tostring", "tonumber", "pairs", "ipairs", "next",
            "select", "unpack", "rawget", "rawset", "setmetatable", "getmetatable",
            "assert", "error", "pcall", "xpcall", "require", "load", "loadfile",
            "dofile", "string", "table", "math", "io", "os", "coroutine", "debug"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {
            "func": "function ${1:name}(${2:args})\n  ${3}\nend",
            "lfunc": "local function ${1:name}(${2:args})\n  ${3}\nend",
            "if": "if ${1:condition} then\n  ${2}\nend",
            "for": "for ${1:i} = ${2:1}, ${3:10} do\n  ${4}\nend",
            "fori": "for ${1:i}, ${2:v} in ipairs(${3:t}) do\n  ${4}\nend",
            "forp": "for ${1:k}, ${2:v} in pairs(${3:t}) do\n  ${4}\nend",
        }
    },

    "perl": {
        "name": "Perl",
        "icon": "ğŸª",
        "extensions": [".pl", ".pm", ".t"],
        "run_command": "perl {file}",
        "comment_single": "#",
        "comment_multi": ("=pod", "=cut"),
        "indent": 4,
        "keywords": [
            "my", "our", "local", "sub", "use", "require", "package", "if", "elsif",
            "else", "unless", "given", "when", "default", "for", "foreach", "while",
            "until", "do", "last", "next", "redo", "return", "goto", "die", "warn",
            "BEGIN", "END", "CHECK", "INIT", "and", "or", "not", "xor", "eq", "ne",
            "lt", "gt", "le", "ge", "cmp", "print", "say", "open", "close"
        ],
        "builtins": ["print", "say", "chomp", "chop", "length", "substr", "split", "join", "push", "pop", "shift"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "r": {
        "name": "R",
        "icon": "ğŸ“Š",
        "extensions": [".r", ".R", ".rmd", ".Rmd"],
        "run_command": "Rscript {file}",
        "repl": "R",
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "if", "else", "repeat", "while", "function", "for", "in", "next",
            "break", "TRUE", "FALSE", "NULL", "Inf", "NaN", "NA", "NA_integer_",
            "NA_real_", "NA_complex_", "NA_character_", "library", "require"
        ],
        "builtins": [
            "print", "cat", "paste", "c", "list", "vector", "matrix", "data.frame",
            "factor", "length", "nrow", "ncol", "dim", "names", "head", "tail",
            "str", "summary", "mean", "median", "sd", "var", "sum", "prod", "min",
            "max", "range", "sort", "order", "unique", "table", "subset", "merge",
            "apply", "lapply", "sapply", "mapply", "tapply", "aggregate", "read.csv",
            "write.csv", "plot", "hist", "boxplot", "barplot", "ggplot"
        ],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "sql": {
        "name": "SQL",
        "icon": "ğŸ—ƒï¸",
        "extensions": [".sql"],
        "comment_single": "--",
        "comment_multi": ("/*", "*/"),
        "indent": 2,
        "keywords": [
            "SELECT", "FROM", "WHERE", "INSERT", "INTO", "VALUES", "UPDATE", "SET",
            "DELETE", "CREATE", "TABLE", "DROP", "ALTER", "ADD", "COLUMN", "INDEX",
            "PRIMARY", "KEY", "FOREIGN", "REFERENCES", "JOIN", "INNER", "LEFT",
            "RIGHT", "OUTER", "FULL", "ON", "AND", "OR", "NOT", "IN", "BETWEEN",
            "LIKE", "IS", "NULL", "AS", "ORDER", "BY", "ASC", "DESC", "GROUP",
            "HAVING", "LIMIT", "OFFSET", "DISTINCT", "COUNT", "SUM", "AVG", "MIN",
            "MAX", "CASE", "WHEN", "THEN", "ELSE", "END", "UNION", "ALL", "EXISTS",
            "ANY", "SOME", "TRIGGER", "VIEW", "PROCEDURE", "FUNCTION", "BEGIN",
            "COMMIT", "ROLLBACK", "TRANSACTION", "GRANT", "REVOKE", "CASCADE",
            "CONSTRAINT", "UNIQUE", "CHECK", "DEFAULT", "AUTO_INCREMENT", "SERIAL",
            "select", "from", "where", "insert", "into", "values", "update", "set",
            "delete", "create", "table", "drop", "alter", "add", "column", "index"
        ],
        "builtins": [
            "COUNT", "SUM", "AVG", "MIN", "MAX", "UPPER", "LOWER", "LENGTH", "TRIM",
            "SUBSTRING", "CONCAT", "REPLACE", "COALESCE", "NULLIF", "CAST", "CONVERT",
            "DATE", "TIME", "DATETIME", "NOW", "CURRENT_DATE", "CURRENT_TIME"
        ],
        "types": [
            "INT", "INTEGER", "BIGINT", "SMALLINT", "FLOAT", "DOUBLE", "DECIMAL",
            "NUMERIC", "CHAR", "VARCHAR", "TEXT", "BOOLEAN", "DATE", "TIME",
            "DATETIME", "TIMESTAMP", "BLOB", "CLOB"
        ],
        "auto_pairs": {"(": ")", "[": "]", "'": "'", '"': '"'},
        "snippets": {
            "select": "SELECT ${1:*}\nFROM ${2:table}\nWHERE ${3:condition};",
            "insert": "INSERT INTO ${1:table} (${2:columns})\nVALUES (${3:values});",
            "update": "UPDATE ${1:table}\nSET ${2:column} = ${3:value}\nWHERE ${4:condition};",
            "delete": "DELETE FROM ${1:table}\nWHERE ${2:condition};",
            "create": "CREATE TABLE ${1:name} (\n    ${2:id} INT PRIMARY KEY,\n    ${3:column} ${4:TYPE}\n);",
            "join": "SELECT ${1:*}\nFROM ${2:table1} t1\nJOIN ${3:table2} t2 ON t1.${4:id} = t2.${5:id};",
        }
    },

    "json": {
        "name": "JSON",
        "icon": "ğŸ“¦",
        "extensions": [".json", ".jsonc", ".json5"],
        "filenames": ["package.json", "tsconfig.json", ".eslintrc", ".prettierrc"],
        "comment_single": None,
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false", "null"],
        "builtins": [],
        "auto_pairs": {"{": "}", "[": "]", '"': '"'},
        "snippets": {},
    },

    "yaml": {
        "name": "YAML",
        "icon": "ğŸ“‹",
        "extensions": [".yaml", ".yml"],
        "filenames": [".travis.yml", "docker-compose.yml", ".gitlab-ci.yml"],
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false", "null", "yes", "no", "on", "off"],
        "builtins": [],
        "auto_pairs": {"{": "}", "[": "]", '"': '"', "'": "'"},
        "snippets": {},
    },

    "toml": {
        "name": "TOML",
        "icon": "âš™ï¸",
        "extensions": [".toml"],
        "filenames": ["Cargo.toml", "pyproject.toml"],
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": ["true", "false"],
        "builtins": [],
        "auto_pairs": {"{": "}", "[": "]", '"': '"', "'": "'"},
        "snippets": {},
    },

    "markdown": {
        "name": "Markdown",
        "icon": "ğŸ“",
        "extensions": [".md", ".markdown", ".mdown", ".mkd"],
        "comment_single": None,
        "comment_multi": ("<!--", "-->"),
        "indent": 2,
        "keywords": [],
        "builtins": [],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "`": "`", "*": "*", "_": "_"},
        "snippets": {
            "link": "[${1:text}](${2:url})",
            "img": "![${1:alt}](${2:url})",
            "code": "```${1:language}\n${2}\n```",
            "table": "| ${1:Header} | ${2:Header} |\n|---------|----------|\n| ${3:Cell} | ${4:Cell} |",
            "h1": "# ${1:Title}",
            "h2": "## ${1:Title}",
            "h3": "### ${1:Title}",
            "bold": "**${1:text}**",
            "italic": "*${1:text}*",
            "task": "- [ ] ${1:task}",
        }
    },

    "dockerfile": {
        "name": "Dockerfile",
        "icon": "ğŸ³",
        "extensions": [],
        "filenames": ["Dockerfile", "dockerfile", "Containerfile"],
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "FROM", "RUN", "CMD", "LABEL", "MAINTAINER", "EXPOSE", "ENV", "ADD",
            "COPY", "ENTRYPOINT", "VOLUME", "USER", "WORKDIR", "ARG", "ONBUILD",
            "STOPSIGNAL", "HEALTHCHECK", "SHELL", "AS"
        ],
        "builtins": [],
        "auto_pairs": {'"': '"', "'": "'", "[": "]", "{": "}"},
        "snippets": {
            "from": "FROM ${1:image}:${2:tag}",
            "run": "RUN ${1:command}",
            "copy": "COPY ${1:src} ${2:dest}",
            "env": "ENV ${1:key}=${2:value}",
            "expose": "EXPOSE ${1:port}",
            "cmd": 'CMD ["${1:executable}", "${2:param}"]',
            "entry": 'ENTRYPOINT ["${1:executable}"]',
            "work": "WORKDIR ${1:/app}",
        }
    },

    "zig": {
        "name": "Zig",
        "icon": "âš¡",
        "extensions": [".zig"],
        "run_command": "zig run {file}",
        "comment_single": "//",
        "comment_multi": None,
        "indent": 4,
        "keywords": [
            "align", "allowzero", "and", "anyframe", "anytype", "asm", "async",
            "await", "break", "catch", "comptime", "const", "continue", "defer",
            "else", "enum", "errdefer", "error", "export", "extern", "false", "fn",
            "for", "if", "inline", "noalias", "nosuspend", "null", "opaque", "or",
            "orelse", "packed", "pub", "resume", "return", "linksection", "struct",
            "suspend", "switch", "test", "threadlocal", "true", "try", "undefined",
            "union", "unreachable", "usingnamespace", "var", "volatile", "while"
        ],
        "builtins": ["@import", "@This", "@typeInfo", "@typeName", "@TypeOf", "@panic", "@compileError"],
        "types": ["i8", "i16", "i32", "i64", "i128", "u8", "u16", "u32", "u64", "u128", "f16", "f32", "f64", "bool", "void", "noreturn", "type", "anyerror", "comptime_int", "comptime_float"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "v": {
        "name": "V",
        "icon": "ğŸ”·",
        "extensions": [".v", ".vv"],
        "run_command": "v run {file}",
        "comment_single": "//",
        "comment_multi": ("/*", "*/"),
        "indent": 4,
        "keywords": [
            "as", "asm", "assert", "atomic", "break", "const", "continue", "defer",
            "else", "enum", "false", "fn", "for", "go", "goto", "if", "import", "in",
            "interface", "is", "lock", "match", "module", "mut", "none", "or", "pub",
            "return", "rlock", "select", "shared", "spawn", "static", "struct",
            "true", "type", "typeof", "union", "unsafe", "volatile"
        ],
        "builtins": ["println", "print", "eprintln", "eprint"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "nim": {
        "name": "Nim",
        "icon": "ğŸ‘‘",
        "extensions": [".nim", ".nims"],
        "run_command": "nim c -r {file}",
        "comment_single": "#",
        "comment_multi": ("#[", "]#"),
        "indent": 2,
        "keywords": [
            "addr", "and", "as", "asm", "bind", "block", "break", "case", "cast",
            "concept", "const", "continue", "converter", "defer", "discard", "distinct",
            "div", "do", "elif", "else", "end", "enum", "except", "export", "finally",
            "for", "from", "func", "if", "import", "in", "include", "interface", "is",
            "isnot", "iterator", "let", "macro", "method", "mixin", "mod", "nil", "not",
            "notin", "object", "of", "or", "out", "proc", "ptr", "raise", "ref", "return",
            "shl", "shr", "static", "template", "try", "tuple", "type", "using", "var",
            "when", "while", "xor", "yield", "true", "false"
        ],
        "builtins": ["echo", "debugEcho", "quit", "len", "high", "low", "sizeof"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "haskell": {
        "name": "Haskell",
        "icon": "Î»",
        "extensions": [".hs", ".lhs"],
        "run_command": "runhaskell {file}",
        "repl": "ghci",
        "comment_single": "--",
        "comment_multi": ("{-", "-}"),
        "indent": 2,
        "keywords": [
            "as", "case", "class", "data", "default", "deriving", "do", "else",
            "family", "forall", "foreign", "hiding", "if", "import", "in", "infix",
            "infixl", "infixr", "instance", "let", "mdo", "module", "newtype", "of",
            "pattern", "proc", "qualified", "rec", "then", "type", "where"
        ],
        "builtins": ["Prelude", "IO", "Maybe", "Either", "Bool", "Int", "Integer", "Float", "Double", "Char", "String", "True", "False", "Nothing", "Just", "Left", "Right"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'"},
        "snippets": {},
    },

    "elixir": {
        "name": "Elixir",
        "icon": "ğŸ’§",
        "extensions": [".ex", ".exs"],
        "run_command": "elixir {file}",
        "repl": "iex",
        "comment_single": "#",
        "comment_multi": None,
        "indent": 2,
        "keywords": [
            "after", "alias", "and", "case", "catch", "cond", "def", "defcallback",
            "defdelegate", "defexception", "defguard", "defguardp", "defimpl",
            "defmacro", "defmacrop", "defmodule", "defoverridable", "defp",
            "defprotocol", "defstruct", "do", "else", "end", "false", "fn", "for",
            "if", "import", "in", "nil", "not", "or", "quote", "raise", "receive",
            "require", "rescue", "super", "true", "try", "unless", "unquote",
            "unquote_splicing", "use", "when", "with"
        ],
        "builtins": ["IO", "Enum", "Map", "List", "String", "Kernel", "Agent", "Task", "GenServer"],
        "auto_pairs": {"(": ")", "[": "]", "{": "}", '"': '"', "'": "'", "|": "|"},
        "snippets": {},
    },

    "plaintext": {
        "name": "Plain Text",
        "icon": "ğŸ“„",
        "extensions": [".txt", ".text", ".log"],
        "comment_single": None,
        "comment_multi": None,
        "indent": 4,
        "keywords": [],
        "builtins": [],
        "auto_pairs": {},
        "snippets": {},
    },
}


# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ ÑĞ·Ñ‹ĞºĞ° Ğ¿Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ñƒ
def detect_language(filepath: str) -> str:
    """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ğ¿Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ñƒ"""
    if not filepath:
        return "plaintext"
    
    path = Path(filepath)
    filename = path.name
    ext = path.suffix.lower()
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°
    for lang, config in LANGUAGES.items():
        if filename in config.get("filenames", []):
            return lang
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
    for lang, config in LANGUAGES.items():
        if ext in config.get("extensions", []):
            return lang
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° shebang Ğ´Ğ»Ñ ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²
    if path.exists():
        try:
            with open(path, 'r', errors='ignore') as f:
                first_line = f.readline().strip()
                if first_line.startswith('#!'):
                    for lang, config in LANGUAGES.items():
                        for shebang in config.get("shebangs", []):
                            if shebang in first_line:
                                return lang
        except:
            pass
    
    return "plaintext"


# ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ§Ğ°ÑÑ‚Ğ¸ 3...
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ ĞŸĞĞ”Ğ¡Ğ’Ğ•Ğ¢ĞšĞ Ğ¡Ğ˜ĞĞ¢ĞĞšĞ¡Ğ˜Ğ¡Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Token:
    """Ğ¢Ğ¾ĞºĞµĞ½ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ¸"""
    __slots__ = ['text', 'type', 'start', 'end']
    
    def __init__(self, text: str, token_type: str, start: int, end: int):
        self.text = text
        self.type = token_type
        self.start = start
        self.end = end


class SyntaxHighlighter:
    """Ğ”Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ¸ ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸ÑĞ° Ñ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼"""
    
    def __init__(self, language: str = "plaintext"):
        self.language = language
        self.lang_config = LANGUAGES.get(language, LANGUAGES["plaintext"])
        self.theme = THEMES.get(Config().get("theme", "cosmos"))
        self._cache: Dict[str, List[Token]] = {}
        self._compile_patterns()
    
    def set_language(self, language: str):
        """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº"""
        if language != self.language:
            self.language = language
            self.lang_config = LANGUAGES.get(language, LANGUAGES["plaintext"])
            self._cache.clear()
            self._compile_patterns()
    
    def set_theme(self, theme_name: str):
        """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞ¼Ñƒ"""
        if theme_name in THEMES:
            self.theme = THEMES[theme_name]
    
    def _compile_patterns(self):
        """ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ regex Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ´Ğ»Ñ ÑĞ·Ñ‹ĞºĞ°"""
        self._patterns = []
        
        # ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¸
        if self.lang_config.get("comment_single"):
            comment = re.escape(self.lang_config["comment_single"])
            self._patterns.append((re.compile(f'{comment}.*$'), 'comment'))
        
        if self.lang_config.get("comment_multi"):
            start, end = self.lang_config["comment_multi"]
            start_esc, end_esc = re.escape(start), re.escape(end)
            self._patterns.append((re.compile(f'{start_esc}.*?{end_esc}', re.DOTALL), 'comment'))
        
        # Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ¸
        string_delims = self.lang_config.get("string_delimiters", ['"', "'"])
        for delim in string_delims:
            if len(delim) == 3:  # ĞœĞ½Ğ¾Ğ³Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ñ‚Ğ¸Ğ¿Ğ° """ Ğ¸Ğ»Ğ¸ '''
                esc_delim = re.escape(delim)
                self._patterns.append((re.compile(f'{esc_delim}.*?{esc_delim}', re.DOTALL), 'string'))
            else:
                esc_delim = re.escape(delim)
                self._patterns.append((re.compile(f'{esc_delim}(?:[^{esc_delim}\\\\]|\\\\.)*{esc_delim}'), 'string'))
        
        # Ğ§Ğ¸ÑĞ»Ğ°
        self._patterns.append((
            re.compile(r'\b(?:0[xX][0-9a-fA-F]+|0[oO][0-7]+|0[bB][01]+|\d+\.?\d*(?:[eE][+-]?\d+)?)\b'),
            'number'
        ))
        
        # Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ (Ğ´Ğ»Ñ Python, Java Ğ¸ Ñ‚.Ğ´.)
        if self.language in ['python', 'java', 'kotlin', 'typescript']:
            self._patterns.append((re.compile(r'@\w+'), 'decorator'))
        
        # ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ÑĞ»Ğ¾Ğ²Ğ°
        keywords = self.lang_config.get("keywords", [])
        if keywords:
            kw_pattern = r'\b(' + '|'.join(re.escape(kw) for kw in keywords) + r')\b'
            self._patterns.append((re.compile(kw_pattern), 'keyword'))
        
        # Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
        builtins = self.lang_config.get("builtins", [])
        if builtins:
            # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ builtin'Ñ‹ Ñ Ğ²Ğ¾ÑĞºĞ»Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ·Ğ½Ğ°ĞºĞ°Ğ¼Ğ¸ (Rust Ğ¼Ğ°ĞºÑ€Ğ¾ÑÑ‹)
            regular_builtins = [b for b in builtins if not b.endswith('!')]
            macro_builtins = [b for b in builtins if b.endswith('!')]
            
            if regular_builtins:
                bi_pattern = r'\b(' + '|'.join(re.escape(bi) for bi in regular_builtins) + r')\b'
                self._patterns.append((re.compile(bi_pattern), 'builtin'))
            
            if macro_builtins:
                macro_pattern = r'\b(' + '|'.join(re.escape(m) for m in macro_builtins) + r')'
                self._patterns.append((re.compile(macro_pattern), 'builtin'))
        
        # Ğ¢Ğ¸Ğ¿Ñ‹
        types = self.lang_config.get("types", [])
        if types:
            type_pattern = r'\b(' + '|'.join(re.escape(t) for t in types) + r')\b'
            self._patterns.append((re.compile(type_pattern), 'type'))
        
        # ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹
        constants = self.lang_config.get("constants", [])
        if constants:
            const_pattern = r'\b(' + '|'.join(re.escape(c) for c in constants) + r')\b'
            self._patterns.append((re.compile(const_pattern), 'constant'))
        
        # Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ (Ğ²Ñ‹Ğ·Ğ¾Ğ²)
        self._patterns.append((re.compile(r'\b([a-zA-Z_]\w*)\s*(?=\()'), 'function'))
        
        # ĞšĞ»Ğ°ÑÑÑ‹ (PascalCase)
        self._patterns.append((re.compile(r'\b([A-Z][a-zA-Z0-9]*)\b'), 'class'))
    
    def tokenize_line(self, line: str, line_num: int = 0) -> List[Token]:
        """Ğ Ğ°Ğ·Ğ±Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ½Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ñ‹"""
        cache_key = f"{line_num}:{line}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        tokens = []
        used_positions = set()
        
        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹
        for pattern, token_type in self._patterns:
            for match in pattern.finditer(line):
                start, end = match.start(), match.end()
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ·Ğ°Ğ½ÑÑ‚Ğ° Ğ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
                if any(pos in used_positions for pos in range(start, end)):
                    continue
                
                # Ğ”Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ¸ ĞºĞ»Ğ°ÑÑĞ¾Ğ² Ğ±ĞµÑ€Ñ‘Ğ¼ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ, ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
                if match.lastindex:
                    text = match.group(1)
                    # ĞšĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹
                    group_start = match.start(1)
                    group_end = match.end(1)
                    tokens.append(Token(text, token_type, group_start, group_end))
                    used_positions.update(range(group_start, group_end))
                else:
                    tokens.append(Token(match.group(), token_type, start, end))
                    used_positions.update(range(start, end))
        
        # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        tokens.sort(key=lambda t: t.start)
        
        # ĞšÑÑˆĞ¸Ñ€ÑƒĞµĞ¼ (Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ ĞºÑÑˆĞ°)
        if len(self._cache) > 5000:
            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ñƒ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹
            keys = list(self._cache.keys())[:2500]
            for k in keys:
                del self._cache[k]
        
        self._cache[cache_key] = tokens
        return tokens
    
    def get_token_attr(self, token_type: str) -> int:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚ curses Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
        syntax_theme = self.theme.get("syntax", {})
        
        if token_type in syntax_theme:
            style = syntax_theme[token_type]
            if isinstance(style, dict):
                return ColorManager.get_pair(
                    style.get("fg", "white"),
                    style.get("bg", "default"),
                    style.get("bold", False),
                    style.get("dim", False),
                    style.get("underline", False)
                )
            elif isinstance(style, tuple):
                fg, bold = style if len(style) == 2 else (style[0], False)
                return ColorManager.get_pair(fg, "default", bold)
        
        return ColorManager.get_pair("white", "default")
    
    def clear_cache(self):
        """ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ ĞºÑÑˆ"""
        self._cache.clear()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“„ Ğ¢Ğ•ĞšĞ¡Ğ¢ĞĞ’Ğ«Ğ™ Ğ‘Ğ£Ğ¤Ğ•Ğ  Ğ¡ ĞœĞĞĞ–Ğ•Ğ¡Ğ¢Ğ’Ğ•ĞĞĞ«ĞœĞ˜ ĞšĞ£Ğ Ğ¡ĞĞ ĞĞœĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TextBuffer:
    """
    Ğ‘ÑƒÑ„ĞµÑ€ Ñ‚ĞµĞºÑÑ‚Ğ° Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹:
    - ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ñ… ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ²
    - Undo/Redo Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹
    - Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ñ‚ĞµĞºÑÑ‚Ğ°
    - Ğ—Ğ°ĞºĞ»Ğ°Ğ´Ğ¾Ğº
    - Ğ¡Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ°
    """
    
    def __init__(self):
        self.lines: List[str] = [""]
        self.cursors: List[Cursor] = [Cursor(0, 0)]
        self.primary_cursor_index: int = 0
        
        self.filepath: Optional[str] = None
        self.encoding: str = "utf-8"
        self.line_ending: str = "\n"  # "\n" Ğ¸Ğ»Ğ¸ "\r\n"
        self.modified: bool = False
        self.readonly: bool = False
        
        self.undo_manager = UndoManager()
        
        # ĞŸÑ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ°
        self.scroll_y: int = 0
        self.scroll_x: int = 0
        
        # Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ¸: set of line numbers
        self.bookmarks: Set[int] = set()
        
        # Ğ¡Ğ²Ñ‘Ñ€Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸: {start_line: end_line}
        self.folded_regions: Dict[int, int] = {}
        
        # ĞŸĞ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ°
        self.highlighter = SyntaxHighlighter()
        
        # ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        self.language: str = "plaintext"
        self.file_size: int = 0
        self.last_modified: float = 0
        
        # ĞŸĞ¾Ğ¸ÑĞº
        self.search_query: str = ""
        self.search_matches: List[Tuple[int, int, int]] = []  # (line, start, end)
        self.current_match_index: int = -1
    
    @property
    def cursor(self) -> Cursor:
        """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºÑƒÑ€ÑĞ¾Ñ€"""
        return self.cursors[self.primary_cursor_index]
    
    @property
    def cursor_line(self) -> int:
        return self.cursor.line
    
    @cursor_line.setter
    def cursor_line(self, value: int):
        self.cursor.line = max(0, min(value, len(self.lines) - 1))
    
    @property
    def cursor_col(self) -> int:
        return self.cursor.col
    
    @cursor_col.setter
    def cursor_col(self, value: int):
        max_col = len(self.lines[self.cursor.line])
        self.cursor.col = max(0, min(value, max_col))
    
    @property
    def total_lines(self) -> int:
        return len(self.lines)
    
    @property
    def total_chars(self) -> int:
        return sum(len(line) for line in self.lines) + len(self.lines) - 1
    
    @property
    def total_words(self) -> int:
        return sum(len(line.split()) for line in self.lines)
    
    @property
    def current_line(self) -> str:
        return self.lines[self.cursor.line]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ¤Ğ°Ğ¹Ğ»Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def load_file(self, filepath: str) -> Tuple[bool, str]:
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
        try:
            path = Path(filepath)
            
            if not path.exists():
                # ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
                self.filepath = str(path)
                self.lines = [""]
                self.modified = False
                self.language = detect_language(filepath)
                self.highlighter.set_language(self.language)
                return True, "ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»"
            
            # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºÑƒ
            encodings = ['utf-8', 'utf-8-sig', 'cp1251', 'cp866', 'iso-8859-1', 'utf-16']
            content = None
            
            for enc in encodings:
                try:
                    with open(path, 'r', encoding=enc) as f:
                        content = f.read()
                    self.encoding = enc
                    break
                except (UnicodeDecodeError, UnicodeError):
                    continue
            
            if content is None:
                # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ ĞºĞ°Ğº Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹
                try:
                    with open(path, 'rb') as f:
                        raw = f.read()
                    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ğ»Ğ¸ Ñ„Ğ°Ğ¹Ğ»
                    if b'\x00' in raw[:8000]:
                        return False, "Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ"
                    content = raw.decode('utf-8', errors='replace')
                    self.encoding = 'utf-8'
                except Exception as e:
                    return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ: {e}"
            
            # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ ÑÑ‚Ñ€Ğ¾Ğº
            if '\r\n' in content:
                self.line_ending = '\r\n'
                content = content.replace('\r\n', '\n')
            elif '\r' in content:
                content = content.replace('\r', '\n')
            
            self.lines = content.split('\n')
            if not self.lines:
                self.lines = [""]
            
            self.filepath = str(path)
            self.modified = False
            self.file_size = path.stat().st_size
            self.last_modified = path.stat().st_mtime
            
            # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ÑĞ·Ñ‹Ğº
            self.language = detect_language(filepath)
            self.highlighter.set_language(self.language)
            self.highlighter.clear_cache()
            
            # Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
            self.cursors = [Cursor(0, 0)]
            self.primary_cursor_index = 0
            self.scroll_x = 0
            self.scroll_y = 0
            self.undo_manager.clear()
            self.bookmarks.clear()
            self.folded_regions.clear()
            self.search_matches.clear()
            
            return True, f"Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½: {path.name}"
            
        except PermissionError:
            return False, "ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ½Ğ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ"
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}"
    
    def save_file(self, filepath: Optional[str] = None) -> Tuple[bool, str]:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
        save_path = filepath or self.filepath
        
        if not save_path:
            return False, "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾ Ğ¸Ğ¼Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°"
        
        try:
            path = Path(save_path)
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
            path.parent.mkdir(parents=True, exist_ok=True)
            
            # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ
            content = self.line_ending.join(self.lines)
            
            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ ĞµÑĞ»Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¾
            if Config().get("insert_final_newline", True):
                if not content.endswith('\n'):
                    content += self.line_ending
            
            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ trailing whitespace ĞµÑĞ»Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¾
            if Config().get("trim_trailing_whitespace", True):
                lines = content.split(self.line_ending)
                lines = [line.rstrip() for line in lines]
                content = self.line_ending.join(lines)
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ backup
            if path.exists():
                backup_dir = Config.BACKUPS_DIR
                backup_name = f"{path.name}.{int(time.time())}.bak"
                backup_path = backup_dir / backup_name
                try:
                    shutil.copy2(path, backup_path)
                    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ backup'Ñ‹ (Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 10)
                    backups = sorted(backup_dir.glob(f"{path.name}.*.bak"))
                    for old_backup in backups[:-10]:
                        old_backup.unlink()
                except:
                    pass
            
            # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»
            with open(path, 'w', encoding=self.encoding, newline='') as f:
                f.write(content)
            
            self.filepath = str(path)
            self.modified = False
            self.file_size = path.stat().st_size
            self.last_modified = path.stat().st_mtime
            
            # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑĞ·Ñ‹Ğº ĞµÑĞ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ
            new_lang = detect_language(str(path))
            if new_lang != self.language:
                self.language = new_lang
                self.highlighter.set_language(self.language)
            
            return True, f"Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½: {path.name}"
            
        except PermissionError:
            return False, "ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ"
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ: {e}"
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµĞºÑÑ‚Ğ°
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _save_undo(self, action_type: str, data: dict):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹"""
        action = UndoAction(action_type, data, self.cursor)
        self.undo_manager.push(action)
    
    def insert_char(self, char: str, record_undo: bool = True):
        """Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ğ²Ğ¾ Ğ²ÑĞµÑ… ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°Ñ…"""
        if self.readonly:
            return
        
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
        if self.cursor.has_selection:
            self.delete_selection()
        
        if record_undo:
            self._save_undo("insert", {
                "char": char,
                "positions": [(c.line, c.col) for c in self.cursors]
            })
        
        # Ğ’ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ° (Ğ¾Ñ‚ ĞºĞ¾Ğ½Ñ†Ğ° Ğº Ğ½Ğ°Ñ‡Ğ°Ğ»Ñƒ Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ ÑĞ±Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸)
        for cursor in sorted(self.cursors, key=lambda c: (c.line, c.col), reverse=True):
            line = self.lines[cursor.line]
            self.lines[cursor.line] = line[:cursor.col] + char + line[cursor.col:]
            cursor.col += len(char)
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def insert_text(self, text: str, record_undo: bool = True):
        """Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚"""
        if self.readonly:
            return
        
        if self.cursor.has_selection:
            self.delete_selection()
        
        if record_undo:
            self._save_undo("insert_text", {
                "text": text,
                "position": (self.cursor.line, self.cursor.col)
            })
        
        lines = text.split('\n')
        
        if len(lines) == 1:
            # ĞĞ´Ğ½Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚
            self.insert_char(text, record_undo=False)
        else:
            # ĞœĞ½Ğ¾Ğ³Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚
            current_line = self.lines[self.cursor.line]
            before = current_line[:self.cursor.col]
            after = current_line[self.cursor.col:]
            
            # ĞŸĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°
            self.lines[self.cursor.line] = before + lines[0]
            
            # Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            for i, line in enumerate(lines[1:-1], 1):
                self.lines.insert(self.cursor.line + i, line)
            
            # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ ÑÑ‚Ñ€Ğ¾ĞºĞ°
            self.lines.insert(self.cursor.line + len(lines) - 1, lines[-1] + after)
            
            # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ĞºÑƒÑ€ÑĞ¾Ñ€
            self.cursor.line += len(lines) - 1
            self.cursor.col = len(lines[-1])
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def insert_newline(self, record_undo: bool = True):
        """Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ¾Ğ¼"""
        if self.readonly:
            return
        
        if self.cursor.has_selection:
            self.delete_selection()
        
        current_line = self.lines[self.cursor.line]
        
        # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿
        indent = ""
        for c in current_line:
            if c in ' \t':
                indent += c
            else:
                break
        
        # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿ Ğ¿Ğ¾ÑĞ»Ğµ : { ( [
        stripped = current_line[:self.cursor.col].rstrip()
        if stripped and stripped[-1] in ':({[':
            indent_size = self.lang_config.get("indent", 4) if hasattr(self, 'lang_config') else 4
            if Config().get("use_spaces", True):
                indent += " " * indent_size
            else:
                indent += "\t"
        
        if record_undo:
            self._save_undo("newline", {
                "line": self.cursor.line,
                "col": self.cursor.col,
                "indent": indent
            })
        
        # Ğ Ğ°Ğ·Ğ´ĞµĞ»ÑĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
        before = current_line[:self.cursor.col]
        after = current_line[self.cursor.col:]
        
        self.lines[self.cursor.line] = before
        self.lines.insert(self.cursor.line + 1, indent + after)
        
        self.cursor.line += 1
        self.cursor.col = len(indent)
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def delete_char_backward(self, record_undo: bool = True):
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ğ¿ĞµÑ€ĞµĞ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼ (Backspace)"""
        if self.readonly:
            return
        
        if self.cursor.has_selection:
            self.delete_selection()
            return
        
        if self.cursor.col > 0:
            if record_undo:
                self._save_undo("delete_backward", {
                    "char": self.lines[self.cursor.line][self.cursor.col - 1],
                    "line": self.cursor.line,
                    "col": self.cursor.col
                })
            
            line = self.lines[self.cursor.line]
            self.lines[self.cursor.line] = line[:self.cursor.col - 1] + line[self.cursor.col:]
            self.cursor.col -= 1
            
        elif self.cursor.line > 0:
            if record_undo:
                self._save_undo("delete_line_join", {
                    "line": self.cursor.line,
                    "prev_line_len": len(self.lines[self.cursor.line - 1])
                })
            
            prev_line = self.lines[self.cursor.line - 1]
            curr_line = self.lines[self.cursor.line]
            self.cursor.col = len(prev_line)
            self.lines[self.cursor.line - 1] = prev_line + curr_line
            del self.lines[self.cursor.line]
            self.cursor.line -= 1
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def delete_char_forward(self, record_undo: bool = True):
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ğ¿Ğ¾ÑĞ»Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ° (Delete)"""
        if self.readonly:
            return
        
        if self.cursor.has_selection:
            self.delete_selection()
            return
        
        line = self.lines[self.cursor.line]
        
        if self.cursor.col < len(line):
            if record_undo:
                self._save_undo("delete_forward", {
                    "char": line[self.cursor.col],
                    "line": self.cursor.line,
                    "col": self.cursor.col
                })
            
            self.lines[self.cursor.line] = line[:self.cursor.col] + line[self.cursor.col + 1:]
            
        elif self.cursor.line < len(self.lines) - 1:
            if record_undo:
                self._save_undo("delete_line_join_forward", {
                    "line": self.cursor.line
                })
            
            next_line = self.lines[self.cursor.line + 1]
            self.lines[self.cursor.line] = line + next_line
            del self.lines[self.cursor.line + 1]
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def delete_selection(self, record_undo: bool = True):
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚"""
        if not self.cursor.has_selection:
            return
        
        sel = self.cursor.selection
        
        if record_undo:
            self._save_undo("delete_selection", {
                "text": self.get_selection_text(),
                "start": (sel.start.line, sel.start.col),
                "end": (sel.end.line, sel.end.col)
            })
        
        if sel.start.line == sel.end.line:
            # Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ
            line = self.lines[sel.start.line]
            self.lines[sel.start.line] = line[:sel.start.col] + line[sel.end.col:]
        else:
            # ĞœĞ½Ğ¾Ğ³Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ
            start_line = self.lines[sel.start.line][:sel.start.col]
            end_line = self.lines[sel.end.line][sel.end.col:]
            
            self.lines[sel.start.line] = start_line + end_line
            
            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            del self.lines[sel.start.line + 1:sel.end.line + 1]
        
        self.cursor.line = sel.start.line
        self.cursor.col = sel.start.col
        self.cursor.clear_selection()
        
        self.modified = True
        self.highlighter.clear_cache()
    
    def delete_line(self, record_undo: bool = True):
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ"""
        if self.readonly:
            return
        
        if record_undo:
            self._save_undo("delete_line", {
                "line_num": self.cursor.line,
                "content": self.lines[self.cursor.line]
            })
        
        if len(self.lines) > 1:
            del self.lines[self.cursor.line]
            if self.cursor.line >= len(self.lines):
                self.cursor.line = len(self.lines) - 1
        else:
            self.lines[0] = ""
        
        self.cursor.col = min(self.cursor.col, len(self.lines[self.cursor.line]))
        self.modified = True
        self.highlighter.clear_cache()
    
    def duplicate_line(self, record_undo: bool = True):
        """Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ"""
        if self.readonly:
            return
        
        if record_undo:
            self._save_undo("duplicate_line", {
                "line_num": self.cursor.line
            })
        
        line = self.lines[self.cursor.line]
        self.lines.insert(self.cursor.line + 1, line)
        self.cursor.line += 1
        self.modified = True
        self.highlighter.clear_cache()
    
    def move_line_up(self, record_undo: bool = True):
        """ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ²Ğ²ĞµÑ€Ñ…"""
        if self.readonly or self.cursor.line == 0:
            return
        
        if record_undo:
            self._save_undo("move_line_up", {"line_num": self.cursor.line})
        
        self.lines[self.cursor.line], self.lines[self.cursor.line - 1] = \
            self.lines[self.cursor.line - 1], self.lines[self.cursor.line]
        self.cursor.line -= 1
        self.modified = True
        self.highlighter.clear_cache()
    
    def move_line_down(self, record_undo: bool = True):
        """ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ²Ğ½Ğ¸Ğ·"""
        if self.readonly or self.cursor.line >= len(self.lines) - 1:
            return
        
        if record_undo:
            self._save_undo("move_line_down", {"line_num": self.cursor.line})
        
        self.lines[self.cursor.line], self.lines[self.cursor.line + 1] = \
            self.lines[self.cursor.line + 1], self.lines[self.cursor.line]
        self.cursor.line += 1
        self.modified = True
        self.highlighter.clear_cache()
    
    def indent_line(self, record_undo: bool = True):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿"""
        if self.readonly:
            return
        
        if record_undo:
            self._save_undo("indent", {"line_num": self.cursor.line})
        
        indent = " " * Config().get("tab_size", 4) if Config().get("use_spaces", True) else "\t"
        self.lines[self.cursor.line] = indent + self.lines[self.cursor.line]
        self.cursor.col += len(indent)
        self.modified = True
    
    def unindent_line(self, record_undo: bool = True):
        """Ğ£Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿"""
        if self.readonly:
            return
        
        line = self.lines[self.cursor.line]
        tab_size = Config().get("tab_size", 4)
        
        removed = 0
        if line.startswith('\t'):
            self.lines[self.cursor.line] = line[1:]
            removed = 1
        elif line.startswith(' ' * tab_size):
            self.lines[self.cursor.line] = line[tab_size:]
            removed = tab_size
        elif line.startswith(' '):
            # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ĞµÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ² (Ğ´Ğ¾ tab_size)
            spaces = 0
            for c in line:
                if c == ' ' and spaces < tab_size:
                    spaces += 1
                else:
                    break
            self.lines[self.cursor.line] = line[spaces:]
            removed = spaces
        
        if removed > 0:
            if record_undo:
                self._save_undo("unindent", {"line_num": self.cursor.line, "removed": removed})
            self.cursor.col = max(0, self.cursor.col - removed)
            self.modified = True
    
    def toggle_comment(self, record_undo: bool = True):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹"""
        if self.readonly:
            return
        
        lang_config = LANGUAGES.get(self.language, {})
        comment_str = lang_config.get("comment_single")
        
        if not comment_str:
            return
        
        line = self.lines[self.cursor.line]
        stripped = line.lstrip()
        indent = line[:len(line) - len(stripped)]
        
        if record_undo:
            self._save_undo("toggle_comment", {
                "line_num": self.cursor.line,
                "original": line
            })
        
        if stripped.startswith(comment_str):
            # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹
            if stripped.startswith(comment_str + ' '):
                new_line = indent + stripped[len(comment_str) + 1:]
            else:
                new_line = indent + stripped[len(comment_str):]
            self.lines[self.cursor.line] = new_line
        else:
            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹
            self.lines[self.cursor.line] = indent + comment_str + ' ' + stripped
        
        self.modified = True
        self.highlighter.clear_cache()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def get_selection_text(self) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚"""
        if not self.cursor.has_selection:
            return ""
        
        sel = self.cursor.selection
        
        if sel.start.line == sel.end.line:
            return self.lines[sel.start.line][sel.start.col:sel.end.col]
        
        result = []
        result.append(self.lines[sel.start.line][sel.start.col:])
        
        for line_num in range(sel.start.line + 1, sel.end.line):
            result.append(self.lines[line_num])
        
        result.append(self.lines[sel.end.line][:sel.end.col])
        
        return '\n'.join(result)
    
    def select_all(self):
        """Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘"""
        self.cursor.line = 0
        self.cursor.col = 0
        self.cursor.start_selection()
        self.cursor.line = len(self.lines) - 1
        self.cursor.col = len(self.lines[-1])
    
    def select_word(self):
        """Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ğ²Ğ¾ Ğ¿Ğ¾Ğ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼"""
        line = self.lines[self.cursor.line]
        if not line:
            return
        
        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°
        start = self.cursor.col
        while start > 0 and (line[start - 1].isalnum() or line[start - 1] == '_'):
            start -= 1
        
        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ ĞºĞ¾Ğ½ĞµÑ† ÑĞ»Ğ¾Ğ²Ğ°
        end = self.cursor.col
        while end < len(line) and (line[end].isalnum() or line[end] == '_'):
            end += 1
        
        if start != end:
            self.cursor.col = start
            self.cursor.start_selection()
            self.cursor.col = end
    
    def select_line(self):
        """Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ"""
        self.cursor.col = 0
        self.cursor.start_selection()
        if self.cursor.line < len(self.lines) - 1:
            self.cursor.line += 1
            self.cursor.col = 0
        else:
            self.cursor.col = len(self.lines[self.cursor.line])
    
    def get_word_at_cursor(self) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ğ²Ğ¾ Ğ¿Ğ¾Ğ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼"""
        line = self.lines[self.cursor.line]
        if not line:
            return ""
        
        start = self.cursor.col
        while start > 0 and (line[start - 1].isalnum() or line[start - 1] == '_'):
            start -= 1
        
        end = self.cursor.col
        while end < len(line) and (line[end].isalnum() or line[end] == '_'):
            end += 1
        
        return line[start:end]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ñ‹
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def add_cursor(self, line: int, col: int):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€"""
        new_cursor = Cursor(line, col)
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½ĞµÑ‚ Ğ»Ğ¸ ÑƒĞ¶Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ° Ğ² ÑÑ‚Ğ¾Ğ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        for c in self.cursors:
            if c.line == line and c.col == col:
                return
        self.cursors.append(new_cursor)
    
    def add_cursor_above(self):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ²Ñ‹ÑˆĞµ"""
        if self.cursor.line > 0:
            new_line = self.cursor.line - 1
            new_col = min(self.cursor.col, len(self.lines[new_line]))
            self.add_cursor(new_line, new_col)
    
    def add_cursor_below(self):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ½Ğ¸Ğ¶Ğµ"""
        if self.cursor.line < len(self.lines) - 1:
            new_line = self.cursor.line + 1
            new_col = min(self.cursor.col, len(self.lines[new_line]))
            self.add_cursor(new_line, new_col)
    
    def add_cursor_at_next_occurrence(self):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ½Ğ° ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ Ğ²Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¾Ğ²Ğ°"""
        word = self.get_word_at_cursor()
        if not word:
            return
        
        # Ğ˜Ñ‰ĞµĞ¼ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ Ğ²Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
        last_cursor = max(self.cursors, key=lambda c: (c.line, c.col))
        
        for line_num in range(last_cursor.line, len(self.lines)):
            line = self.lines[line_num]
            start_col = last_cursor.col + 1 if line_num == last_cursor.line else 0
            
            pos = line.find(word, start_col)
            if pos != -1:
                self.add_cursor(line_num, pos)
                return
        
        # Ğ•ÑĞ»Ğ¸ Ğ½Ğµ Ğ½Ğ°ÑˆĞ»Ğ¸, Ğ¸Ñ‰ĞµĞ¼ Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°
        for line_num in range(0, last_cursor.line + 1):
            line = self.lines[line_num]
            pos = line.find(word)
            if pos != -1:
                self.add_cursor(line_num, pos)
                return
    
    def clear_extra_cursors(self):
        """ĞÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºÑƒÑ€ÑĞ¾Ñ€"""
        primary = self.cursor.copy()
        self.cursors = [primary]
        self.primary_cursor_index = 0
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Undo/Redo
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def undo(self) -> bool:
        """ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ"""
        actions = self.undo_manager.undo()
        if not actions:
            return False
        
        for action in reversed(actions):
            self._apply_undo(action)
        
        self.modified = True
        self.highlighter.clear_cache()
        return True
    
    def redo(self) -> bool:
        """ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ"""
        actions = self.undo_manager.redo()
        if not actions:
            return False
        
        for action in actions:
            self._apply_redo(action)
        
        self.modified = True
        self.highlighter.clear_cache()
        return True
    
    def _apply_undo(self, action: UndoAction):
        """ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñƒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
        data = action.data
        
        if action.action_type == "insert":
            # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ²ÑÑ‚Ğ°Ğ²ĞºÑƒ - ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
            for line, col in reversed(data["positions"]):
                char_len = len(data["char"])
                self.lines[line] = self.lines[line][:col] + self.lines[line][col + char_len:]
        
        elif action.action_type == "delete_backward":
            # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
            line, col = data["line"], data["col"]
            self.lines[line] = self.lines[line][:col - 1] + data["char"] + self.lines[line][col - 1:]
        
        elif action.action_type == "newline":
            # ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            line_num = data["line"]
            self.lines[line_num] = self.lines[line_num] + self.lines[line_num + 1][len(data["indent"]):]
            del self.lines[line_num + 1]
        
        elif action.action_type == "delete_line":
            # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
            self.lines.insert(data["line_num"], data["content"])
        
        # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
        self.cursor.line = action.cursor_before.line
        self.cursor.col = action.cursor_before.col
    
    def _apply_redo(self, action: UndoAction):
        """ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"""
        data = action.data
        
        if action.action_type == "insert":
            for line, col in data["positions"]:
                self.lines[line] = self.lines[line][:col] + data["char"] + self.lines[line][col:]
        
        elif action.action_type == "delete_backward":
            line, col = data["line"], data["col"]
            self.lines[line] = self.lines[line][:col - 1] + self.lines[line][col:]
        
        elif action.action_type == "newline":
            line_num = data["line"]
            indent = data["indent"]
            current = self.lines[line_num]
            col = data["col"]
            self.lines[line_num] = current[:col]
            self.lines.insert(line_num + 1, indent + current[col:])
        
        elif action.action_type == "delete_line":
            del self.lines[data["line_num"]]
            if not self.lines:
                self.lines = [""]
        
        # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
        self.cursor.line = action.cursor_after.line
        self.cursor.col = action.cursor_after.col
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ¸
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def toggle_bookmark(self):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ»Ğ°Ğ´ĞºÑƒ Ğ½Ğ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ"""
        if self.cursor.line in self.bookmarks:
            self.bookmarks.remove(self.cursor.line)
            return False
        else:
            self.bookmarks.add(self.cursor.line)
            return True
    
    def goto_next_bookmark(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ Ğ·Ğ°ĞºĞ»Ğ°Ğ´ĞºĞµ"""
        if not self.bookmarks:
            return False
        
        sorted_marks = sorted(self.bookmarks)
        for mark in sorted_marks:
            if mark > self.cursor.line:
                self.cursor.line = mark
                self.cursor.col = 0
                return True
        
        # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ·Ğ°ĞºĞ»Ğ°Ğ´ĞºĞµ
        self.cursor.line = sorted_marks[0]
        self.cursor.col = 0
        return True
    
    def goto_prev_bookmark(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¹ Ğ·Ğ°ĞºĞ»Ğ°Ğ´ĞºĞµ"""
        if not self.bookmarks:
            return False
        
        sorted_marks = sorted(self.bookmarks, reverse=True)
        for mark in sorted_marks:
            if mark < self.cursor.line:
                self.cursor.line = mark
                self.cursor.col = 0
                return True
        
        # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ğ·Ğ°ĞºĞ»Ğ°Ğ´ĞºĞµ
        self.cursor.line = sorted_marks[0]
        self.cursor.col = 0
        return True
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ĞŸĞ¾Ğ¸ÑĞº
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def find(self, query: str, case_sensitive: bool = False, 
             whole_word: bool = False, regex: bool = False):
        """ĞĞ°Ğ¹Ñ‚Ğ¸ Ñ‚ĞµĞºÑÑ‚"""
        self.search_query = query
        self.search_matches.clear()
        self.current_match_index = -1
        
        if not query:
            return
        
        flags = 0 if case_sensitive else re.IGNORECASE
        
        if regex:
            try:
                pattern = re.compile(query, flags)
            except re.error:
                return
        else:
            escaped = re.escape(query)
            if whole_word:
                escaped = r'\b' + escaped + r'\b'
            pattern = re.compile(escaped, flags)
        
        for line_num, line in enumerate(self.lines):
            for match in pattern.finditer(line):
                self.search_matches.append((line_num, match.start(), match.end()))
        
        # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¼Ñƒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ÑĞ»Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
        if self.search_matches:
            for i, (line, start, end) in enumerate(self.search_matches):
                if line > self.cursor.line or (line == self.cursor.line and start >= self.cursor.col):
                    self.current_match_index = i
                    break
            else:
                self.current_match_index = 0
    
    def find_next(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ"""
        if not self.search_matches:
            return False
        
        self.current_match_index = (self.current_match_index + 1) % len(self.search_matches)
        line, start, end = self.search_matches[self.current_match_index]
        self.cursor.line = line
        self.cursor.col = start
        return True
    
    def find_prev(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¼Ñƒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ"""
        if not self.search_matches:
            return False
        
        self.current_match_index = (self.current_match_index - 1) % len(self.search_matches)
        line, start, end = self.search_matches[self.current_match_index]
        self.cursor.line = line
        self.cursor.col = start
        return True
    
    def replace(self, replacement: str) -> bool:
        """Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ"""
        if not self.search_matches or self.current_match_index < 0:
            return False
        
        line, start, end = self.search_matches[self.current_match_index]
        
        self._save_undo("replace", {
            "line": line,
            "start": start,
            "end": end,
            "old": self.lines[line][start:end],
            "new": replacement
        })
        
        self.lines[line] = self.lines[line][:start] + replacement + self.lines[line][end:]
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ¸ÑĞº
        self.find(self.search_query)
        self.modified = True
        return True
    
    def replace_all(self, replacement: str) -> int:
        """Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ"""
        if not self.search_matches:
            return 0
        
        count = len(self.search_matches)
        
        # Ğ—Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ ĞºĞ¾Ğ½Ñ†Ğ° Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ ÑĞ±Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        for line, start, end in reversed(self.search_matches):
            self.lines[line] = self.lines[line][:start] + replacement + self.lines[line][end:]
        
        self.search_matches.clear()
        self.current_match_index = -1
        self.modified = True
        self.highlighter.clear_cache()
        
        return count


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¡ ĞĞ’Ğ¢ĞĞ”ĞĞŸĞĞ›ĞĞ•ĞĞ˜Ğ•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CompletionItem:
    """Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ"""
    
    def __init__(self, text: str, kind: str, detail: str = "", 
                 insert_text: str = None, documentation: str = ""):
        self.text = text  # ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚
        self.kind = kind  # keyword, function, variable, snippet, etc.
        self.detail = detail  # ĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
        self.insert_text = insert_text or text  # Ğ§Ñ‚Ğ¾ Ğ²ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ
        self.documentation = documentation  # ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ
    
    @property
    def icon(self) -> str:
        """Ğ˜ĞºĞ¾Ğ½ĞºĞ° Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ñƒ"""
        icons = {
            "keyword": "ğŸ”‘",
            "function": "ğŸ”§",
            "method": "ğŸ”§",
            "variable": "ğŸ“",
            "class": "ğŸ“¦",
            "module": "ğŸ“",
            "snippet": "ğŸ“",
            "property": "ğŸ·ï¸",
            "constant": "ğŸ”’",
            "type": "ğŸ“",
            "interface": "ğŸ”Œ",
            "enum": "ğŸ“Š",
            "text": "ğŸ“„",
        }
        return icons.get(self.kind, "â€¢")


class AutoCompleteEngine:
    """Ğ”Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ"""
    
    def __init__(self):
        self.enabled = True
        self.min_chars = 2
        self.max_items = 15
        self._word_cache: Dict[str, Set[str]] = {}  # Ğ¡Ğ»Ğ¾Ğ²Ğ° Ğ¸Ğ· Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
    
    def get_completions(self, buffer: TextBuffer, trigger_char: str = None) -> List[CompletionItem]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ"""
        if not self.enabled:
            return []
        
        line = buffer.lines[buffer.cursor.line]
        col = buffer.cursor.col
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ»Ğ¾Ğ²Ğ¾
        prefix = ""
        start = col
        while start > 0 and (line[start - 1].isalnum() or line[start - 1] == '_'):
            start -= 1
        prefix = line[start:col]
        
        if len(prefix) < self.min_chars and not trigger_char:
            return []
        
        completions = []
        seen = set()
        
        lang = buffer.language
        lang_config = LANGUAGES.get(lang, {})
        
        # ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ÑĞ»Ğ¾Ğ²Ğ°
        for kw in lang_config.get("keywords", []):
            if self._matches(kw, prefix) and kw not in seen:
                completions.append(CompletionItem(kw, "keyword"))
                seen.add(kw)
        
        # Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
        for builtin in lang_config.get("builtins", []):
            if self._matches(builtin, prefix) and builtin not in seen:
                is_func = not builtin[0].isupper() if builtin else False
                completions.append(CompletionItem(
                    builtin, 
                    "function" if is_func else "class",
                    f"Built-in {builtin}"
                ))
                seen.add(builtin)
        
        # Ğ¢Ğ¸Ğ¿Ñ‹
        for typ in lang_config.get("types", []):
            if self._matches(typ, prefix) and typ not in seen:
                completions.append(CompletionItem(typ, "type"))
                seen.add(typ)
        
        # Ğ¡Ğ½Ğ¸Ğ¿Ğ¿ĞµÑ‚Ñ‹
        for snippet_name, snippet_body in lang_config.get("snippets", {}).items():
            if self._matches(snippet_name, prefix) and snippet_name not in seen:
                # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ»ĞµĞ¹ÑÑ…Ğ¾Ğ»Ğ´ĞµÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ²ÑŒÑ
                preview = re.sub(r'\$\{\d+:([^}]*)\}', r'\1', snippet_body)
                preview = re.sub(r'\$\d+', '', preview)
                completions.append(CompletionItem(
                    snippet_name, 
                    "snippet",
                    preview[:50] + "..." if len(preview) > 50 else preview,
                    snippet_body
                ))
                seen.add(snippet_name)
        
        # Ğ¡Ğ»Ğ¾Ğ²Ğ° Ğ¸Ğ· Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
        doc_words = self._extract_words(buffer)
        for word in doc_words:
            if self._matches(word, prefix) and word not in seen and word != prefix:
                completions.append(CompletionItem(word, "text"))
                seen.add(word)
        
        # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°: Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼Ğ¸, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ñƒ
        def sort_key(item: CompletionItem):
            exact = 0 if item.text.lower().startswith(prefix.lower()) else 1
            type_order = {
                "keyword": 0, "snippet": 1, "function": 2, "method": 2,
                "class": 3, "type": 4, "variable": 5, "text": 6
            }
            return (exact, type_order.get(item.kind, 10), item.text.lower())
        
        completions.sort(key=sort_key)
        
        return completions[:self.max_items]
    
    def _matches(self, text: str, prefix: str) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ Ñ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑĞ¾Ğ¼"""
        if not prefix:
            return True
        return text.lower().startswith(prefix.lower())
    
    def _extract_words(self, buffer: TextBuffer) -> Set[str]:
        """Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ ÑĞ»Ğ¾Ğ²Ğ° Ğ¸Ğ· Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°"""
        words = set()
        pattern = re.compile(r'\b[a-zA-Z_]\w{2,}\b')
        
        for line in buffer.lines:
            for match in pattern.finditer(line):
                words.add(match.group())
        
        return words
    
    def expand_snippet(self, snippet: str, buffer: TextBuffer) -> str:
        """Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚"""
        # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ»ĞµĞ¹ÑÑ…Ğ¾Ğ»Ğ´ĞµÑ€Ñ‹
        result = re.sub(r'\$\{\d+:([^}]*)\}', r'\1', snippet)
        result = re.sub(r'\$\d+', '', result)
        return result


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” Ğ›Ğ˜ĞĞ¢Ğ•Ğ  (ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ ĞšĞĞ”Ğ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LintMessage:
    """Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ»Ğ¸Ğ½Ñ‚ĞµÑ€Ğ°"""
    
    def __init__(self, line: int, col: int, message: str, 
                 severity: str = "error", code: str = ""):
        self.line = line
        self.col = col
        self.message = message
        self.severity = severity  # error, warning, info, hint
        self.code = code
    
    @property
    def icon(self) -> str:
        icons = {
            "error": "âŒ",
            "warning": "âš ï¸",
            "info": "â„¹ï¸",
            "hint": "ğŸ’¡"
        }
        return icons.get(self.severity, "â€¢")


class Linter:
    """Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ»Ğ¸Ğ½Ñ‚ĞµÑ€ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… ÑĞ·Ñ‹ĞºĞ¾Ğ²"""
    
    def __init__(self):
        self.enabled = True
        self.messages: List[LintMessage] = []
    
    def lint(self, buffer: TextBuffer) -> List[LintMessage]:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        self.messages.clear()
        
        if not self.enabled:
            return []
        
        lang = buffer.language
        
        if lang == "python":
            self._lint_python(buffer)
        elif lang in ("javascript", "typescript"):
            self._lint_javascript(buffer)
        elif lang == "json":
            self._lint_json(buffer)
        
        # ĞĞ±Ñ‰Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
        self._lint_common(buffer)
        
        return self.messages
    
    def _add_message(self, line: int, col: int, message: str, 
                     severity: str = "error", code: str = ""):
        self.messages.append(LintMessage(line, col, message, severity, code))
    
    def _lint_python(self, buffer: TextBuffer):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Python ĞºĞ¾Ğ´Ğ°"""
        for i, line in enumerate(buffer.lines):
            stripped = line.strip()
            
            # ĞŸÑƒÑÑ‚Ñ‹Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ¸ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼
            if not stripped or stripped.startswith('#'):
                continue
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ¾Ğ² ÑĞ¼ĞµÑˆĞ°Ğ½Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ¾Ğ² Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ²
            if '\t' in line and '    ' in line:
                leading = line[:len(line) - len(line.lstrip())]
                if '\t' in leading and ' ' in leading:
                    self._add_message(i, 0, "Ğ¡Ğ¼ĞµÑˆĞ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ğ°Ğ±Ñ‹ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹ Ğ² Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ°Ñ…", "warning", "W191")
            
            # Ğ¡Ğ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
            for keyword in ['if', 'elif', 'else', 'for', 'while', 'def', 'class', 'try', 'except', 'finally', 'with']:
                if re.match(rf'^\s*{keyword}\s+[^:]*$', line) and not stripped.endswith('\\'):
                    if keyword in ['else', 'try', 'finally']:
                        if not stripped.endswith(':'):
                            self._add_message(i, len(line), f"ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ ':' Ğ¿Ğ¾ÑĞ»Ğµ {keyword}", "error", "E999")
                    elif not stripped.endswith(':') and not stripped.endswith('\\'):
                        self._add_message(i, len(line), f"Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ ':' Ğ¿Ğ¾ÑĞ»Ğµ {keyword}", "warning", "E999")
            
            # print ĞºĞ°Ğº statement (Python 2 ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ)
            if re.match(r'^\s*print\s+["\']', line):
                self._add_message(i, 0, "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ print() ĞºĞ°Ğº Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ", "warning", "E999")
            
            # Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ñ None
            if ' == None' in line or ' != None' in line:
                self._add_message(i, 0, "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ 'is None' Ğ¸Ğ»Ğ¸ 'is not None'", "warning", "E711")
            
            # ĞŸÑƒÑÑ‚Ğ¾Ğ¹ except
            if stripped == 'except:':
                self._add_message(i, 0, "Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ Ğ³Ğ¾Ğ»Ğ¾Ğ³Ğ¾ except:, ÑƒĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ", "warning", "E722")
            
            # Ğ”Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            if len(line) > 120:
                self._add_message(i, 120, f"Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ ({len(line)} > 120)", "info", "E501")
    
    def _lint_javascript(self, buffer: TextBuffer):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° JavaScript ĞºĞ¾Ğ´Ğ°"""
        for i, line in enumerate(buffer.lines):
            stripped = line.strip()
            
            if not stripped or stripped.startswith('//'):
                continue
            
            # var Ğ²Ğ¼ĞµÑÑ‚Ğ¾ let/const
            if re.match(r'^\s*var\s+', line):
                self._add_message(i, 0, "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ let Ğ¸Ğ»Ğ¸ const Ğ²Ğ¼ĞµÑÑ‚Ğ¾ var", "warning", "no-var")
            
            # == Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ===
            if ' == ' in line and ' === ' not in line:
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
                if not re.search(r'["\'][^"\']*==[^"\']*["\']', line):
                    self._add_message(i, line.find(' == '), "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ === Ğ´Ğ»Ñ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğ³Ğ¾ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ", "warning", "eqeqeq")
            
            # != Ğ²Ğ¼ĞµÑÑ‚Ğ¾ !==
            if ' != ' in line and ' !== ' not in line:
                if not re.search(r'["\'][^"\']*!=[^"\']*["\']', line):
                    self._add_message(i, line.find(' != '), "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ !== Ğ´Ğ»Ñ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğ³Ğ¾ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ", "warning", "eqeqeq")
            
            # console.log Ğ² Ğ¿Ñ€Ğ¾Ğ´Ğ°ĞºÑˆĞµĞ½Ğµ
            if 'console.log' in line:
                self._add_message(i, line.find('console.log'), "console.log - ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ´ Ñ€ĞµĞ»Ğ¸Ğ·Ğ¾Ğ¼", "info", "no-console")
    
    def _lint_json(self, buffer: TextBuffer):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° JSON"""
        content = '\n'.join(buffer.lines)
        try:
            json.loads(content)
        except json.JSONDecodeError as e:
            self._add_message(e.lineno - 1, e.colno - 1, f"JSON Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e.msg}", "error", "json")
    
    def _lint_common(self, buffer: TextBuffer):
        """ĞĞ±Ñ‰Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… ÑĞ·Ñ‹ĞºĞ¾Ğ²"""
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ñ€Ğ½Ñ‹Ñ… ÑĞºĞ¾Ğ±Ğ¾Ğº
        brackets = {'(': ')', '[': ']', '{': '}'}
        stack = []
        
        for i, line in enumerate(buffer.lines):
            in_string = False
            string_char = None
            j = 0
            
            while j < len(line):
                char = line[j]
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° escape-Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ĞµĞ¹
                if j > 0 and line[j-1] == '\\':
                    j += 1
                    continue
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑÑ‚Ñ€Ğ¾Ğº
                if char in '"\'`':
                    if not in_string:
                        in_string = True
                        string_char = char
                    elif char == string_char:
                        in_string = False
                    j += 1
                    continue
                
                if in_string:
                    j += 1
                    continue
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞºĞ¾Ğ±Ğ¾Ğº
                if char in brackets:
                    stack.append((char, i, j))
                elif char in brackets.values():
                    if stack:
                        open_bracket, _, _ = stack[-1]
                        if brackets.get(open_bracket) == char:
                            stack.pop()
                        else:
                            self._add_message(i, j, f"ĞĞµÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ ÑĞºĞ¾Ğ±Ğ¾Ğº: Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ÑÑ '{brackets[open_bracket]}'", "error")
                    else:
                        self._add_message(i, j, f"Ğ›Ğ¸ÑˆĞ½ÑÑ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ°Ñ ÑĞºĞ¾Ğ±ĞºĞ° '{char}'", "error")
                
                j += 1
        
        # ĞĞµĞ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞºĞ¾Ğ±ĞºĞ¸
        for bracket, line_num, col in stack:
            self._add_message(line_num, col, f"ĞĞµĞ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°Ñ ÑĞºĞ¾Ğ±ĞºĞ° '{bracket}'", "error")
        
        # Trailing whitespace
        for i, line in enumerate(buffer.lines):
            if line != line.rstrip():
                trailing = len(line) - len(line.rstrip())
                self._add_message(i, len(line.rstrip()), f"ĞŸÑ€Ğ¾Ğ±ĞµĞ»Ñ‹ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ ({trailing})", "hint", "trailing-whitespace")


# ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ§Ğ°ÑÑ‚Ğ¸ 4...
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¤– AI Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AIProvider(ABC):
    """Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ´Ğ»Ñ AI Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ¾Ğ²"""
    
    name: str = "Base"
    icon: str = "ğŸ¤–"
    
    @abstractmethod
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº AI"""
        pass
    
    @abstractmethod
    def test_connection(self) -> Tuple[bool, str]:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ"""
        pass


class OpenAIProvider(AIProvider):
    """OpenAI GPT Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€"""
    
    name = "OpenAI"
    icon = "ğŸŸ¢"
    
    def __init__(self, api_key: str, model: str = "gpt-3.5-turbo", base_url: str = None):
        self.api_key = api_key
        self.model = model
        self.base_url = base_url or "https://api.openai.com/v1/chat/completions"
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        try:
            if system_prompt is None:
                system_prompt = """Ğ¢Ñ‹ - Ğ¾Ğ¿Ñ‹Ñ‚Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸ÑÑ‚-Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº Ğ² Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğµ ĞºĞ¾Ğ´Ğ° Dipo Studio.
ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾ Ğ¸ Ğ¿Ğ¾ Ğ´ĞµĞ»Ñƒ. ĞšĞ¾Ğ´ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞ¹ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾.
Ğ•ÑĞ»Ğ¸ Ğ¿Ñ€Ğ¾ÑÑÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´ - Ğ²Ñ‹Ğ´Ğ°Ğ²Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ±ĞµĞ· Ğ»Ğ¸ÑˆĞ½Ğ¸Ñ… Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğ¹.
Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğ¹."""
            
            messages = [{"role": "system", "content": system_prompt}]
            
            if context:
                messages.append({
                    "role": "user", 
                    "content": f"ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ ĞºĞ¾Ğ´Ğ°:\n```\n{context}\n```"
                })
            
            messages.append({"role": "user", "content": prompt})
            
            data = json.dumps({
                "model": self.model,
                "messages": messages,
                "max_tokens": 4000,
                "temperature": 0.7
            }).encode('utf-8')
            
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["choices"][0]["message"]["content"]
                
        except urllib.error.HTTPError as e:
            error_body = e.read().decode('utf-8') if e.fp else ""
            try:
                error_json = json.loads(error_body)
                error_msg = error_json.get("error", {}).get("message", str(e))
            except:
                error_msg = str(e)
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° API ({e.code}): {error_msg}"
        except urllib.error.URLError as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ‚Ğ¸: {e.reason}"
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        return self.query("Ğ¡ĞºĞ°Ğ¶Ğ¸ 'OK' Ğ¾Ğ´Ğ½Ğ¸Ğ¼ ÑĞ»Ğ¾Ğ²Ğ¾Ğ¼", "")


class AnthropicProvider(AIProvider):
    """Anthropic Claude Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€"""
    
    name = "Anthropic Claude"
    icon = "ğŸŸ£"
    
    def __init__(self, api_key: str, model: str = "claude-3-haiku-20240307"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://api.anthropic.com/v1/messages"
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        try:
            if system_prompt is None:
                system_prompt = """Ğ¢Ñ‹ - Ğ¾Ğ¿Ñ‹Ñ‚Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸ÑÑ‚-Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾ Ğ¸ Ğ¿Ğ¾ Ğ´ĞµĞ»Ñƒ. 
ĞšĞ¾Ğ´ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞ¹ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº."""
            
            user_content = prompt
            if context:
                user_content = f"ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ ĞºĞ¾Ğ´Ğ°:\n```\n{context}\n```\n\n{prompt}"
            
            data = json.dumps({
                "model": self.model,
                "max_tokens": 4000,
                "system": system_prompt,
                "messages": [{"role": "user", "content": user_content}]
            }).encode('utf-8')
            
            headers = {
                "Content-Type": "application/json",
                "x-api-key": self.api_key,
                "anthropic-version": "2023-06-01"
            }
            
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["content"][0]["text"]
                
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Claude: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        return self.query("Ğ¡ĞºĞ°Ğ¶Ğ¸ 'OK' Ğ¾Ğ´Ğ½Ğ¸Ğ¼ ÑĞ»Ğ¾Ğ²Ğ¾Ğ¼", "")


class GoogleGeminiProvider(AIProvider):
    """Google Gemini Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€"""
    
    name = "Google Gemini"
    icon = "ğŸ”µ"
    
    def __init__(self, api_key: str, model: str = "gemini-pro"):
        self.api_key = api_key
        self.model = model
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        try:
            url = f"https://generativelanguage.googleapis.com/v1beta/models/{self.model}:generateContent?key={self.api_key}"
            
            full_prompt = prompt
            if context:
                full_prompt = f"ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ ĞºĞ¾Ğ´Ğ°:\n```\n{context}\n```\n\n{prompt}"
            if system_prompt:
                full_prompt = f"{system_prompt}\n\n{full_prompt}"
            
            data = json.dumps({
                "contents": [{"parts": [{"text": full_prompt}]}],
                "generationConfig": {
                    "temperature": 0.7,
                    "maxOutputTokens": 4000
                }
            }).encode('utf-8')
            
            headers = {"Content-Type": "application/json"}
            req = urllib.request.Request(url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["candidates"][0]["content"]["parts"][0]["text"]
                
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Gemini: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        return self.query("Ğ¡ĞºĞ°Ğ¶Ğ¸ 'OK' Ğ¾Ğ´Ğ½Ğ¸Ğ¼ ÑĞ»Ğ¾Ğ²Ğ¾Ğ¼", "")


class GroqProvider(AIProvider):
    """Groq Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€ (Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹)"""
    
    name = "Groq"
    icon = "ğŸŸ "
    
    def __init__(self, api_key: str, model: str = "llama3-8b-8192"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://api.groq.com/openai/v1/chat/completions"
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ OpenAI-ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¹ API
        try:
            if system_prompt is None:
                system_prompt = "Ğ¢Ñ‹ - Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸ÑÑ‚-Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹."
            
            messages = [{"role": "system", "content": system_prompt}]
            
            user_content = prompt
            if context:
                user_content = f"ĞšĞ¾Ğ´:\n```\n{context}\n```\n\n{prompt}"
            
            messages.append({"role": "user", "content": user_content})
            
            data = json.dumps({
                "model": self.model,
                "messages": messages,
                "max_tokens": 4000,
                "temperature": 0.7
            }).encode('utf-8')
            
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=30) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["choices"][0]["message"]["content"]
                
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Groq: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        return self.query("Say OK", "")


class DeepSeekProvider(AIProvider):
    """DeepSeek Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€"""
    
    name = "DeepSeek"
    icon = "ğŸ”·"
    
    def __init__(self, api_key: str, model: str = "deepseek-coder"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://api.deepseek.com/v1/chat/completions"
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        # OpenAI-ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¹ API
        try:
            if system_prompt is None:
                system_prompt = "Ğ¢Ñ‹ - Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸ÑÑ‚-Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾."
            
            messages = [{"role": "system", "content": system_prompt}]
            
            user_content = prompt
            if context:
                user_content = f"ĞšĞ¾Ğ´:\n```\n{context}\n```\n\n{prompt}"
            
            messages.append({"role": "user", "content": user_content})
            
            data = json.dumps({
                "model": self.model,
                "messages": messages,
                "max_tokens": 4000
            }).encode('utf-8')
            
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=60) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["choices"][0]["message"]["content"]
                
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° DeepSeek: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        return self.query("Say OK", "")


class OllamaProvider(AIProvider):
    """Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ollama Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€"""
    
    name = "Ollama (Local)"
    icon = "âš«"
    
    def __init__(self, model: str = "llama3", host: str = "localhost", port: int = 11434):
        self.model = model
        self.base_url = f"http://{host}:{port}/api/generate"
    
    def query(self, prompt: str, context: str = "", 
              system_prompt: str = None) -> Tuple[bool, str]:
        try:
            full_prompt = prompt
            if context:
                full_prompt = f"ĞšĞ¾Ğ´:\n```\n{context}\n```\n\n{prompt}"
            if system_prompt:
                full_prompt = f"{system_prompt}\n\n{full_prompt}"
            
            data = json.dumps({
                "model": self.model,
                "prompt": full_prompt,
                "stream": False
            }).encode('utf-8')
            
            headers = {"Content-Type": "application/json"}
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            
            with urllib.request.urlopen(req, timeout=120) as response:
                result = json.loads(response.read().decode('utf-8'))
                return True, result["response"]
                
        except urllib.error.URLError:
            return False, "Ollama Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ: ollama serve"
        except Exception as e:
            return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Ollama: {str(e)}"
    
    def test_connection(self) -> Tuple[bool, str]:
        try:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚ÑŒ
            url = self.base_url.replace("/generate", "/tags")
            req = urllib.request.Request(url.replace("/api/generate", "/api/tags"))
            with urllib.request.urlopen(req, timeout=5) as response:
                return True, "Ollama Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"
        except:
            return False, "Ollama Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"


class AIConfig:
    """ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ AI"""
    
    PROVIDERS = {
        "openai": {
            "class": OpenAIProvider,
            "name": "OpenAI (GPT-4, GPT-3.5)",
            "icon": "ğŸŸ¢",
            "models": ["gpt-4-turbo", "gpt-4", "gpt-3.5-turbo", "gpt-4o", "gpt-4o-mini"],
            "default_model": "gpt-3.5-turbo",
            "key_hint": "sk-..."
        },
        "anthropic": {
            "class": AnthropicProvider,
            "name": "Anthropic (Claude)",
            "icon": "ğŸŸ£",
            "models": ["claude-3-opus-20240229", "claude-3-sonnet-20240229", "claude-3-haiku-20240307"],
            "default_model": "claude-3-haiku-20240307",
            "key_hint": "sk-ant-..."
        },
        "google": {
            "class": GoogleGeminiProvider,
            "name": "Google (Gemini)",
            "icon": "ğŸ”µ",
            "models": ["gemini-pro", "gemini-1.5-pro", "gemini-1.5-flash"],
            "default_model": "gemini-pro",
            "key_hint": "AIza..."
        },
        "groq": {
            "class": GroqProvider,
            "name": "Groq (Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹)",
            "icon": "ğŸŸ ",
            "models": ["llama3-70b-8192", "llama3-8b-8192", "mixtral-8x7b-32768", "gemma-7b-it"],
            "default_model": "llama3-8b-8192",
            "key_hint": "gsk_..."
        },
        "deepseek": {
            "class": DeepSeekProvider,
            "name": "DeepSeek",
            "icon": "ğŸ”·",
            "models": ["deepseek-chat", "deepseek-coder"],
            "default_model": "deepseek-coder",
            "key_hint": "sk-..."
        },
        "ollama": {
            "class": OllamaProvider,
            "name": "Ollama (Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹)",
            "icon": "âš«",
            "models": ["llama3", "llama3:70b", "codellama", "mistral", "phi3", "qwen2"],
            "default_model": "llama3",
            "key_hint": "(ĞºĞ»ÑÑ‡ Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½)"
        }
    }
    
    def __init__(self):
        self.config_path = Config.AI_CONFIG_FILE
        self._config = self._load()
    
    def _load(self) -> dict:
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    return json.load(f)
        except:
            pass
        return {"provider": None, "api_key": None, "model": None}
    
    def save(self):
        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(self._config, f, indent=2)
        except:
            pass
    
    def set_provider(self, provider: str, api_key: str = None, model: str = None):
        """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ°"""
        if provider not in self.PROVIDERS:
            return False
        
        self._config = {
            "provider": provider,
            "api_key": api_key,
            "model": model or self.PROVIDERS[provider]["default_model"]
        }
        self.save()
        return True
    
    def get_provider(self) -> Optional[AIProvider]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ°"""
        provider_name = self._config.get("provider")
        if not provider_name or provider_name not in self.PROVIDERS:
            return None
        
        provider_info = self.PROVIDERS[provider_name]
        provider_class = provider_info["class"]
        
        if provider_name == "ollama":
            return provider_class(self._config.get("model", "llama3"))
        else:
            api_key = self._config.get("api_key")
            if not api_key:
                return None
            return provider_class(api_key, self._config.get("model"))
    
    def is_configured(self) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½ Ğ»Ğ¸ AI"""
        provider = self._config.get("provider")
        if not provider:
            return False
        if provider == "ollama":
            return True
        return bool(self._config.get("api_key"))
    
    def remove(self):
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸"""
        self._config = {"provider": None, "api_key": None, "model": None}
        if self.config_path.exists():
            self.config_path.unlink()
    
    @property
    def provider_name(self) -> str:
        return self._config.get("provider", "")
    
    @property
    def model(self) -> str:
        return self._config.get("model", "")


class AIManager:
    """ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ AI Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²"""
    
    def __init__(self):
        self.config = AIConfig()
        self._provider: Optional[AIProvider] = None
    
    @property
    def provider(self) -> Optional[AIProvider]:
        if self._provider is None:
            self._provider = self.config.get_provider()
        return self._provider
    
    def reload_provider(self):
        """ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ° Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº"""
        self._provider = self.config.get_provider()
    
    def query(self, prompt: str, context: str = "") -> Tuple[bool, str]:
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº AI"""
        if not self.config.is_configured():
            return False, "âŒ AI Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ F10 â†’ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ AI"
        
        provider = self.provider
        if not provider:
            return False, "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ AI Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ°"
        
        return provider.query(prompt, context)
    
    def explain_code(self, code: str) -> Tuple[bool, str]:
        """ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        return self.query("ĞĞ±ÑŠÑÑĞ½Ğ¸ Ñ‡Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´. Ğ‘ÑƒĞ´ÑŒ ĞºÑ€Ğ°Ñ‚ĞºĞ¸Ğ¼.", code)
    
    def find_bugs(self, code: str) -> Tuple[bool, str]:
        """ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ² ĞºĞ¾Ğ´Ğµ"""
        return self.query(
            "ĞĞ°Ğ¹Ğ´Ğ¸ Ğ²ÑĞµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ² ÑÑ‚Ğ¾Ğ¼ ĞºĞ¾Ğ´Ğµ. "
            "Ğ”Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ ÑƒĞºĞ°Ğ¶Ğ¸: ÑÑ‚Ñ€Ğ¾ĞºÑƒ, Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñƒ, Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ.",
            code
        )
    
    def optimize_code(self, code: str) -> Tuple[bool, str]:
        """ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        return self.query(
            "ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´. Ğ’Ñ‹Ğ´Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ±ĞµĞ· Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğ¹.",
            code
        )
    
    def generate_code(self, description: str, language: str, context: str = "") -> Tuple[bool, str]:
        """Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        prompt = f"ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ ĞºĞ¾Ğ´ Ğ½Ğ° {language}: {description}. Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ´ Ğ±ĞµĞ· Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğ¹."
        return self.query(prompt, context)
    
    def generate_tests(self, code: str, language: str) -> Tuple[bool, str]:
        """Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµÑÑ‚Ñ‹"""
        return self.query(
            f"ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ unit-Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ° Ğ½Ğ° {language}. Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ´ Ñ‚ĞµÑÑ‚Ğ¾Ğ².",
            code
        )
    
    def generate_docs(self, code: str) -> Tuple[bool, str]:
        """Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ"""
        return self.query(
            "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ (docstrings/JSDoc/ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¸) Ğº ÑÑ‚Ğ¾Ğ¼Ñƒ ĞºĞ¾Ğ´Ñƒ. "
            "Ğ’Ñ‹Ğ´Ğ°Ğ¹ ĞºĞ¾Ğ´ Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸ĞµĞ¹.",
            code
        )
    
    def refactor_code(self, code: str, instruction: str) -> Tuple[bool, str]:
        """Ğ ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¿Ğ¾ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸"""
        return self.query(
            f"Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´: {instruction}. Ğ’Ñ‹Ğ´Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´.",
            code
        )
    
    def fix_error(self, code: str, error_message: str) -> Tuple[bool, str]:
        """Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ"""
        return self.query(
            f"Ğ’ ĞºĞ¾Ğ´Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {error_message}\nĞ˜ÑĞ¿Ñ€Ğ°Ğ²ÑŒ ĞºĞ¾Ğ´. Ğ’Ñ‹Ğ´Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´.",
            code
        )
    
    def complete_code(self, code: str, cursor_position: str = "ĞºĞ¾Ğ½ĞµÑ†") -> Tuple[bool, str]:
        """Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        return self.query(
            f"Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´. ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°: {cursor_position}. "
            "Ğ’Ñ‹Ğ´Ğ°Ğ¹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ±ĞµĞ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ°.",
            code
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  Ğ£ĞœĞĞ«Ğ™ Ğ‘ĞĞ¢ (Ğ‘Ğ•Ğ¡ĞŸĞ›ĞĞ¢ĞĞ«Ğ™, Ğ‘Ğ•Ğ— API)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SmartBot:
    """Ğ£Ğ¼Ğ½Ñ‹Ğ¹ Ğ±Ğ¾Ñ‚ Ğ±ĞµĞ· Ğ¸Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ğ° - Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº"""
    
    # Ğ‘Ğ°Ğ·Ğ° Ñ‡Ğ°ÑÑ‚Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ‡Ğ°Ñ‚Ğ¾Ğº (500+)
    TYPOS = {
        # Python
        "pritn": "print", "pirnt": "print", "prnt": "print", "prnit": "print",
        "improt": "import", "imoprt": "import", "impor": "import", "ipmort": "import",
        "retrun": "return", "reutrn": "return", "retrn": "return", "retunr": "return",
        "defien": "define", "fucntion": "function", "funtion": "function", "fucntion": "function",
        "calss": "class", "clss": "class", "classs": "class", "clas": "class",
        "slef": "self", "sefl": "self", "slf": "self", "sself": "self",
        "Ture": "True", "Flase": "False", "flase": "false", "ture": "true",
        "fasle": "false", "treu": "true", "noen": "None", "NOne": "None",
        "exept": "except", "excpet": "except", "ecxept": "except", "expcet": "except",
        "finaly": "finally", "fianlly": "finally", "finlaly": "finally",
        "lamda": "lambda", "labmda": "lambda", "lambad": "lambda",
        "yeild": "yield", "yiled": "yield", "yeild": "yield",
        "glboal": "global", "gloabl": "global", "golbal": "global",
        "assret": "assert", "asert": "assert", "assrt": "assert",
        "raisee": "raise", "riase": "raise", "rasie": "raise",
        "whlie": "while", "wihle": "while", "whiel": "while",
        "brerak": "break", "brak": "break", "braek": "break",
        "contineu": "continue", "contniue": "continue", "contnue": "continue",
        "elseif": "elif", "elsif": "elif",
        
        # JavaScript
        "cosnt": "const", "conts": "const", "ocnst": "const", "cnost": "const",
        "fucntion": "function", "funcion": "function", "funciton": "function",
        "retunr": "return", "reutn": "return", "retur": "return",
        "undefiend": "undefined", "undifined": "undefined", "undefinde": "undefined",
        "consoel": "console", "consloe": "console", "conosle": "console",
        "dcoument": "document", "documnet": "document", "docuemnt": "document",
        "widnow": "window", "winodw": "window", "windwo": "window",
        "lenght": "length", "legnth": "length", "lentgh": "length",
        "stirng": "string", "strign": "string", "strnig": "string",
        "nubmer": "number", "numebr": "number", "nmuber": "number",
        "boolen": "boolean", "bolean": "boolean", "boolaen": "boolean",
        "arary": "array", "arrya": "array", "arrary": "array",
        "obejct": "object", "ojbect": "object", "objcet": "object",
        "funciton": "function", "fucniton": "function",
        "asynch": "async", "aysnc": "async",
        "awiat": "await", "awit": "await",
        
        # ĞĞ±Ñ‰Ğ¸Ğµ
        "hte": "the", "teh": "the", "taht": "that", "thta": "that",
        "form": "from", "formt": "format", "fomrat": "format",
        "wihle": "while", "whiel": "while", "hwile": "while",
        "esle": "else", "els": "else",
        "sturct": "struct", "strcut": "struct",
        "enumm": "enum", "enmu": "enum",
        "interfce": "interface", "intreface": "interface",
        "implment": "implement", "implmenet": "implement",
        "extedns": "extends", "extneds": "extends",
        "statci": "static", "sttaic": "static",
        "pubilc": "public", "publc": "public",
        "priavte": "private", "privte": "private",
        "protetced": "protected", "protecetd": "protected",
        "voild": "void", "viod": "void",
        "mian": "main", "mani": "main",
        "agrs": "args", "arsg": "args",
        "prarm": "param", "prama": "param",
        "vlaue": "value", "valeu": "value", "valu": "value",
        "reslut": "result", "resutl": "result", "rsult": "result",
        "daat": "data", "dtaa": "data",
        "itme": "item", "tiem": "item",
        "idnex": "index", "indxe": "index",
        "lenght": "length", "lnegth": "length",
    }
    
    # Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½Ñ‹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ¸ Ğ¸Ñ… Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ
    ERROR_PATTERNS = {
        "SyntaxError: invalid syntax": {
            "description": "Ğ¡Ğ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°",
            "causes": [
                "ĞĞµĞ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞºĞ¾Ğ±ĞºĞ¸ (), [], {}",
                "ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ : Ğ¿Ğ¾ÑĞ»Ğµ if/for/def/class",
                "ĞĞµĞ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ĞºĞ°Ğ²Ñ‹Ñ‡ĞºĞ¸ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞ°Ñ…",
                "Ğ¡Ğ¼ĞµÑˆĞ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ğ°Ğ±Ñ‹ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹",
                "ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğµ ÑĞ»Ğ¾Ğ²Ğ¾"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¿Ğ°Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ ÑĞºĞ¾Ğ±Ğ¾Ğº",
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ : Ğ² ĞºĞ¾Ğ½ĞµÑ† ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹ Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğ¹",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğµ ĞºĞ°Ğ²Ñ‹Ñ‡ĞºĞ¸",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹ (4 ÑˆÑ‚) Ğ´Ğ»Ñ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ¾Ğ²"
            ]
        },
        "IndentationError": {
            "description": "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ¾Ğ²",
            "causes": [
                "Ğ¡Ğ¼ĞµÑˆĞ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ğ°Ğ±Ñ‹ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹",
                "ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ²",
                "ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿ Ğ¿Ğ¾ÑĞ»Ğµ :"
            ],
            "fixes": [
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ 4 Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ° Ğ´Ğ»Ñ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ°",
                "ĞĞµ ÑĞ¼ĞµÑˆĞ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ‚Ğ°Ğ±Ñ‹ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹",
                "ĞŸĞ¾ÑĞ»Ğµ : Ğ²ÑĞµĞ³Ğ´Ğ° Ğ´ĞµĞ»Ğ°Ğ¹Ñ‚Ğµ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿"
            ]
        },
        "NameError": {
            "description": "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°",
            "causes": [
                "ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ğ² Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹",
                "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ½Ğµ Ğ¾Ğ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ°",
                "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸",
                "Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ import"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¸Ğ¼ĞµĞ½Ğ¸",
                "ĞĞ±ÑŠÑĞ²Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ´Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‹"
            ]
        },
        "TypeError": {
            "description": "ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…",
            "causes": [
                "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ°Ğ´ Ğ½ĞµÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¼Ğ¸ Ñ‚Ğ¸Ğ¿Ğ°Ğ¼Ğ¸",
                "Ğ’Ñ‹Ğ·Ğ¾Ğ² Ğ½Ğµ-Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ ĞºĞ°Ğº Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸",
                "ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²",
                "None Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¸Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿Ñ‹: str(), int(), float()",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²"
            ]
        },
        "AttributeError": {
            "description": "ĞÑ‚Ñ€Ğ¸Ğ±ÑƒÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½",
            "causes": [
                "ĞœĞµÑ‚Ğ¾Ğ´ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚",
                "ĞĞ±ÑŠĞµĞºÑ‚ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ñ‚Ğ¸Ğ¿",
                "None Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°",
                "ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ğ² Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°: type(obj)",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°",
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ğ½Ğ° None"
            ]
        },
        "KeyError": {
            "description": "ĞšĞ»ÑÑ‡ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ğµ",
            "causes": [
                "ĞšĞ»ÑÑ‡ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚",
                "ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ğ² ĞºĞ»ÑÑ‡Ğµ",
                "ĞšĞ»ÑÑ‡ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°"
            ],
            "fixes": [
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ dict.get('key', default)",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ: if 'key' in dict",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"
            ]
        },
        "IndexError": {
            "description": "Ğ˜Ğ½Ğ´ĞµĞºÑ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ğ¼Ğ¸ ÑĞ¿Ğ¸ÑĞºĞ°",
            "causes": [
                "Ğ˜Ğ½Ğ´ĞµĞºÑ >= len(list)",
                "ĞŸÑƒÑÑ‚Ğ¾Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº",
                "ĞÑ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ğ´ĞµĞºÑ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ´Ğ»Ğ¸Ğ½Ñƒ: if i < len(list)",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ, Ğ½Ğµ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ğ»Ğ¸ ÑĞ¿Ğ¸ÑĞ¾Ğº",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ list[-1] Ğ´Ğ»Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾"
            ]
        },
        "ValueError": {
            "description": "ĞĞµĞ²ĞµÑ€Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ",
            "causes": [
                "ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿",
                "Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ½Ğµ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ğ°",
                "ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
            ],
            "fixes": [
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ try/except ValueError",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ¿ĞµÑ€ĞµĞ´ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ int('123') Ğ²Ğ¼ĞµÑÑ‚Ğ¾ int('abc')"
            ]
        },
        "ImportError": {
            "description": "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ",
            "causes": [
                "ĞœĞ¾Ğ´ÑƒĞ»ÑŒ Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½",
                "ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ğ² Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ",
                "ĞœĞ¾Ğ´ÑƒĞ»ÑŒ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸"
            ],
            "fixes": [
                "Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ: pip install <module>",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿ÑƒÑ‚ÑŒ Ğ² sys.path"
            ]
        },
        "FileNotFoundError": {
            "description": "Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½",
            "causes": [
                "ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ",
                "Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚",
                "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¿ÑƒÑ‚ÑŒ: os.path.exists()",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ",
                "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ» ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾"
            ]
        },
        "ZeroDivisionError": {
            "description": "Ğ”ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ½Ğ¾Ğ»ÑŒ",
            "causes": ["Ğ”ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° 0 Ğ¸Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ñ€Ğ°Ğ²Ğ½ÑƒÑ 0"],
            "fixes": [
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ: if x != 0",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ: result = a / b if b else 0"
            ]
        },
        "RecursionError": {
            "description": "ĞŸÑ€ĞµĞ²Ñ‹ÑˆĞµĞ½Ğ° Ğ³Ğ»ÑƒĞ±Ğ¸Ğ½Ğ° Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸",
            "causes": [
                "ĞĞµÑ‚ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ° Ğ¸Ğ· Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸",
                "Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ğ½Ğ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ",
                "Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ°Ñ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ñ"
            ],
            "fixes": [
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ»ÑƒÑ‡Ğ°Ğ¹",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸",
                "Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ÑŒÑ‚Ğµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚: sys.setrecursionlimit()"
            ]
        },
        "MemoryError": {
            "description": "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸",
            "causes": [
                "Ğ¡Ğ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ",
                "Ğ‘ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ",
                "Ğ£Ñ‚ĞµÑ‡ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸"
            ],
            "fixes": [
                "ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ñ€Ñ†Ğ¸ÑĞ¼Ğ¸",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹",
                "ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ: del"
            ]
        },
        # JavaScript Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
        "ReferenceError": {
            "description": "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ°",
            "causes": [
                "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ½Ğµ Ğ¾Ğ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ°",
                "ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ğ² Ğ¸Ğ¼ĞµĞ½Ğ¸",
                "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¼ scope"
            ],
            "fixes": [
                "ĞĞ±ÑŠÑĞ²Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ: let/const",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸"
            ]
        },
        "Uncaught TypeError": {
            "description": "ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° Ğ² JS",
            "causes": [
                "Ğ’Ñ‹Ğ·Ğ¾Ğ² undefined ĞºĞ°Ğº Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸",
                "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ñƒ undefined",
                "ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ°"
            ],
            "fixes": [
                "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ: if (obj?.method)",
                "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ optional chaining: obj?.prop",
                "Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñ‚Ğ¸Ğ¿Ğ°"
            ]
        },
    }
    
    def __init__(self):
        pass
    
    def check_typos(self, code: str) -> List[Tuple[int, str, str]]:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¾Ğ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ¸. Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚: [(line_num, typo, fix), ...]"""
        results = []
        lines = code.split('\n')
        
        for line_num, line in enumerate(lines):
            # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ ÑĞ»Ğ¾Ğ²Ğ°
            words = re.findall(r'\b[a-zA-Z_]\w*\b', line)
            
            for word in words:
                lower = word.lower()
                if lower in self.TYPOS:
                    results.append((line_num, word, self.TYPOS[lower]))
                elif word in self.TYPOS:
                    results.append((line_num, word, self.TYPOS[word]))
        
        return results
    
    def analyze_error(self, error_message: str) -> dict:
        """ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ"""
        for pattern, info in self.ERROR_PATTERNS.items():
            if pattern.lower() in error_message.lower():
                return {
                    "pattern": pattern,
                    "description": info["description"],
                    "causes": info["causes"],
                    "fixes": info["fixes"]
                }
        
        return {
            "pattern": "Unknown",
            "description": "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°",
            "causes": ["ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ", "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ"],
            "fixes": ["Ğ’Ğ½Ğ¸Ğ¼Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ¹Ñ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ"]
        }
    
    def suggest_fixes(self, code: str, error: str) -> List[str]:
        """ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ÑŒ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ"""
        suggestions = []
        
        analysis = self.analyze_error(error)
        suggestions.extend(analysis["fixes"])
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ¸
        typos = self.check_typos(code)
        for line_num, typo, fix in typos[:5]:
            suggestions.append(f"Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° {line_num + 1}: '{typo}' â†’ '{fix}'")
        
        return suggestions
    
    def get_documentation(self, keyword: str, language: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ¼Ñƒ ÑĞ»Ğ¾Ğ²Ñƒ"""
        docs = {
            "python": {
                "print": """print(*objects, sep=' ', end='\\n', file=sys.stdout)
Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ Ğ² Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº.
  sep: Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°Ğ¼Ğ¸ (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»)
  end: Ñ‡Ñ‚Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ‚Ñ€Ğ¾ĞºĞ¸)
  
ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  print("Hello", "World")       # Hello World
  print("Hello", end="")        # Ğ±ĞµĞ· Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸
  print(1, 2, 3, sep=", ")      # 1, 2, 3""",
                "input": """input(prompt='')
Ğ§Ğ¸Ñ‚Ğ°ĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ¸Ğ· Ğ²Ğ²Ğ¾Ğ´Ğ°.
  prompt: Ñ‚ĞµĞºÑÑ‚ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ñ

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  name = input("Ğ˜Ğ¼Ñ: ")
  age = int(input("Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚: "))""",
                "range": """range(stop) Ğ¸Ğ»Ğ¸ range(start, stop, step)
Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ñ‡Ğ¸ÑĞµĞ».

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  range(5)         # 0, 1, 2, 3, 4
  range(2, 5)      # 2, 3, 4
  range(0, 10, 2)  # 0, 2, 4, 6, 8
  range(5, 0, -1)  # 5, 4, 3, 2, 1""",
                "len": """len(obj)
Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ»Ğ¸Ğ½Ñƒ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°.
Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ: str, list, tuple, dict, set Ğ¸ Ğ´Ñ€.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  len("hello")     # 5
  len([1, 2, 3])   # 3
  len({1: 'a'})    # 1""",
                "open": """open(file, mode='r', encoding=None)
ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ„Ğ°Ğ¹Ğ».
  mode: 'r'-Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ, 'w'-Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ, 'a'-Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ, 'b'-Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  with open('file.txt', 'r') as f:
      content = f.read()
  
  with open('file.txt', 'w', encoding='utf-8') as f:
      f.write('Hello')""",
                "def": """def name(parameters):
    '''docstring'''
    body
    return value

ĞĞ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  def greet(name):
      return f"Hello, {name}!"
  
  def add(a, b=0):
      return a + b""",
                "class": """class Name:
    '''docstring'''
    
    def __init__(self, ...):
        self.attr = value
    
    def method(self):
        pass

ĞĞ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ»Ğ°ÑÑĞ°.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  class Person:
      def __init__(self, name):
          self.name = name
      
      def greet(self):
          return f"Hi, I'm {self.name}" """,
                "lambda": """lambda arguments: expression

ĞĞ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  square = lambda x: x ** 2
  add = lambda a, b: a + b
  
  sorted(items, key=lambda x: x.name)""",
                "list": """list(iterable)
Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº.

ĞœĞµÑ‚Ğ¾Ğ´Ñ‹:
  append(x)    - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
  extend(lst)  - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
  insert(i, x) - Ğ²ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑÑƒ
  remove(x)    - ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ x
  pop([i])     - ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
  sort()       - Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
  reverse()    - Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ

List comprehension:
  [x*2 for x in range(5)]  # [0, 2, 4, 6, 8]""",
                "dict": """dict(**kwargs) Ğ¸Ğ»Ğ¸ dict(mapping)
Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ.

ĞœĞµÑ‚Ğ¾Ğ´Ñ‹:
  get(key, default)  - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
  keys()             - ĞºĞ»ÑÑ‡Ğ¸
  values()           - Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
  items()            - Ğ¿Ğ°Ñ€Ñ‹ (key, value)
  update(d)          - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ
  pop(key)           - ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ

Dict comprehension:
  {k: v*2 for k, v in d.items()}""",
            },
            "javascript": {
                "console.log": """console.log(...args)
Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  console.log("Hello");
  console.log("a =", a);
  console.log({name, age});   // Ğ¾Ğ±ÑŠĞµĞºÑ‚
  console.log(`Value: ${x}`); // template""",
                "const": """const name = value;

ĞĞ±ÑŠÑĞ²Ğ»ÑĞµÑ‚ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñƒ (Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¿ĞµÑ€ĞµĞ¿Ñ€Ğ¸ÑĞ²Ğ¾Ğ¸Ñ‚ÑŒ).

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  const PI = 3.14159;
  const user = {name: "John"}; // Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ
  user.name = "Jane";          // OK
  user = {};                   // ĞÑˆĞ¸Ğ±ĞºĞ°!""",
                "let": """let name = value;

ĞĞ±ÑŠÑĞ²Ğ»ÑĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ñ Ğ±Ğ»Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒÑ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  let count = 0;
  count = 1;  // OK
  
  if (true) {
    let x = 1;
  }
  // x Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ·Ğ´ĞµÑÑŒ""",
                "function": """function name(params) {
    // body
    return value;
}

ĞĞ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  function greet(name) {
    return `Hello, ${name}!`;
  }
  
  // Arrow function
  const add = (a, b) => a + b;""",
                "async": """async function name() {
    const result = await promise;
}

ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  async function fetchData() {
    const res = await fetch(url);
    const data = await res.json();
    return data;
  }""",
            }
        }
        
        lang_docs = docs.get(language, {})
        return lang_docs.get(keyword.lower())
    
    def format_code(self, code: str, language: str) -> str:
        """Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ´Ğ°"""
        lines = code.split('\n')
        formatted = []
        indent_level = 0
        indent_char = "    " if language in ["python", "java", "c", "cpp", "csharp"] else "  "
        
        for line in lines:
            stripped = line.strip()
            
            # Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ°ĞµĞ¼ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ñ… ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
            if stripped and stripped[0] in ')]}':
                indent_level = max(0, indent_level - 1)
            if language == "python" and stripped in ['else:', 'elif', 'except:', 'finally:', 'except']:
                indent_level = max(0, indent_level - 1)
            if stripped.startswith(('end', 'fi', 'done', 'esac')):  # Shell/Ruby
                indent_level = max(0, indent_level - 1)
            
            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ñ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ¾Ğ¼
            if stripped:
                formatted.append(indent_char * indent_level + stripped)
            else:
                formatted.append("")
            
            # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ñ… ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
            if stripped.endswith((':', '{', '(', '[')):
                if not stripped.endswith((')', ']', '}')):
                    indent_level += 1
            if stripped.startswith(('if ', 'for ', 'while ', 'def ', 'class ', 'try:', 'else:', 'elif ', 'with ', 'except')):
                if stripped.endswith(':') and stripped not in formatted[-1]:
                    pass  # Ğ£Ğ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾ Ğ²Ñ‹ÑˆĞµ
            if stripped in ('then', 'do'):  # Shell
                indent_level += 1
        
        return '\n'.join(formatted)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ¿ GIT Ğ˜ĞĞ¢Ğ•Ğ“Ğ ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GitManager:
    """Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Git"""
    
    def __init__(self):
        self._git_available = None
    
    @property
    def available(self) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚ÑŒ Git"""
        if self._git_available is None:
            try:
                result = subprocess.run(
                    ["git", "--version"],
                    capture_output=True,
                    timeout=5
                )
                self._git_available = result.returncode == 0
            except:
                self._git_available = False
        return self._git_available
    
    def is_repo(self, path: str) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ Ğ¿ÑƒÑ‚ÑŒ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸ĞµĞ¼"""
        try:
            result = subprocess.run(
                ["git", "rev-parse", "--git-dir"],
                cwd=path,
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def get_branch(self, path: str) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ²ĞµÑ‚ĞºÑƒ"""
        try:
            result = subprocess.run(
                ["git", "branch", "--show-current"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.stdout.strip() or "HEAD"
        except:
            return "?"
    
    def get_status(self, path: str) -> dict:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ"""
        if not self.available or not self.is_repo(path):
            return {"error": "ĞĞµ Git Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹"}
        
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain", "-b"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            lines = result.stdout.strip().split('\n')
            branch_line = lines[0] if lines else ""
            
            # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ğ²ĞµÑ‚ĞºÑƒ
            branch = "?"
            if branch_line.startswith("## "):
                branch_info = branch_line[3:]
                branch = branch_info.split("...")[0].split()[0]
            
            # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹
            files = []
            modified = added = deleted = untracked = 0
            
            for line in lines[1:]:
                if len(line) < 3:
                    continue
                
                status = line[:2]
                filename = line[3:]
                
                file_status = "?"
                if 'M' in status:
                    file_status = "modified"
                    modified += 1
                elif 'A' in status:
                    file_status = "added"
                    added += 1
                elif 'D' in status:
                    file_status = "deleted"
                    deleted += 1
                elif '?' in status:
                    file_status = "untracked"
                    untracked += 1
                elif 'R' in status:
                    file_status = "renamed"
                    modified += 1
                
                files.append({
                    "status": file_status,
                    "status_code": status.strip(),
                    "filename": filename
                })
            
            return {
                "branch": branch,
                "files": files,
                "modified": modified,
                "added": added,
                "deleted": deleted,
                "untracked": untracked,
                "clean": len(files) == 0
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    def get_file_status(self, filepath: str) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        try:
            path = Path(filepath)
            result = subprocess.run(
                ["git", "status", "--porcelain", str(path.name)],
                cwd=str(path.parent),
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.stdout.strip():
                status = result.stdout[:2]
                if 'M' in status:
                    return "modified"
                elif 'A' in status:
                    return "added"
                elif 'D' in status:
                    return "deleted"
                elif '?' in status:
                    return "untracked"
            return "unchanged"
        except:
            return "unknown"
    
    def diff(self, path: str, filename: str = None) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ diff"""
        try:
            cmd = ["git", "diff", "--color=never"]
            if filename:
                cmd.append(filename)
            
            result = subprocess.run(
                cmd,
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout or "ĞĞµÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹"
        except Exception as e:
            return f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}"
    
    def stage(self, path: str, files: List[str] = None) -> Tuple[bool, str]:
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² Ğ¸Ğ½Ğ´ĞµĞºÑ"""
        try:
            cmd = ["git", "add"]
            if files:
                cmd.extend(files)
            else:
                cmd.append("-A")
            
            result = subprocess.run(cmd, cwd=path, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                return True, "Ğ¤Ğ°Ğ¹Ğ»Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹"
            return False, result.stderr
        except Exception as e:
            return False, str(e)
    
    def commit(self, path: str, message: str) -> Tuple[bool, str]:
        """Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚"""
        try:
            result = subprocess.run(
                ["git", "commit", "-m", message],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ñ…ĞµÑˆ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ°
                hash_match = re.search(r'\[[\w/-]+ ([a-f0-9]+)\]', result.stdout)
                commit_hash = hash_match.group(1) if hash_match else ""
                return True, f"ĞšĞ¾Ğ¼Ğ¼Ğ¸Ñ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {commit_hash}"
            return False, result.stderr or result.stdout
        except Exception as e:
            return False, str(e)
    
    def push(self, path: str) -> Tuple[bool, str]:
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ"""
        try:
            result = subprocess.run(
                ["git", "push"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                return True, "Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹"
            return False, result.stderr
        except Exception as e:
            return False, str(e)
    
    def pull(self, path: str) -> Tuple[bool, str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ"""
        try:
            result = subprocess.run(
                ["git", "pull"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                return True, result.stdout or "ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾"
            return False, result.stderr
        except Exception as e:
            return False, str(e)
    
    def log(self, path: str, limit: int = 20) -> List[dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ¾Ğ²"""
        try:
            result = subprocess.run(
                ["git", "log", f"-{limit}", "--pretty=format:%h|%s|%an|%ar|%ad", "--date=short"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            commits = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split('|', 4)
                    if len(parts) >= 4:
                        commits.append({
                            "hash": parts[0],
                            "message": parts[1],
                            "author": parts[2],
                            "relative_date": parts[3],
                            "date": parts[4] if len(parts) > 4 else ""
                        })
            return commits
        except:
            return []
    
    def branches(self, path: str) -> List[dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ²ĞµÑ‚Ğ¾Ğº"""
        try:
            result = subprocess.run(
                ["git", "branch", "-a", "-v"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            branches = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    is_current = line.startswith('*')
                    line = line.lstrip('* ')
                    parts = line.split(None, 2)
                    if parts:
                        branches.append({
                            "name": parts[0],
                            "current": is_current,
                            "hash": parts[1] if len(parts) > 1 else "",
                            "message": parts[2] if len(parts) > 2 else ""
                        })
            return branches
        except:
            return []
    
    def checkout(self, path: str, branch: str) -> Tuple[bool, str]:
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ²ĞµÑ‚ĞºÑƒ"""
        try:
            result = subprocess.run(
                ["git", "checkout", branch],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                return True, f"ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ Ğ½Ğ° {branch}"
            return False, result.stderr
        except Exception as e:
            return False, str(e)
    
    def stash(self, path: str) -> Tuple[bool, str]:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ² stash"""
        try:
            result = subprocess.run(
                ["git", "stash"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                return True, "Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ² stash"
            return False, result.stderr
        except Exception as e:
            return False, str(e)
    
    def stash_pop(self, path: str) -> Tuple[bool, str]:
        """Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¸Ğ· stash"""
        try:
            result = subprocess.run(
                ["git", "stash", "pop"],
                cwd=path,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                return True, "Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹"
            return False, result.stderr
        except Exception as e:
            return False, str(e)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Ğ—ĞĞŸĞ£Ğ¡Ğš ĞšĞĞ”Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CodeRunner:
    """Ğ—Ğ°Ğ¿ÑƒÑĞº ĞºĞ¾Ğ´Ğ°"""
    
    def __init__(self):
        self.last_output = ""
        self.last_error = ""
        self.last_return_code = 0
        self.last_duration = 0.0
    
    def run(self, filepath: str, language: str = None) -> Tuple[int, str, str, float]:
        """
        Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´.
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚: (return_code, stdout, stderr, duration)
        """
        if not filepath or not Path(filepath).exists():
            return 1, "", "Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", 0.0
        
        # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ÑĞ·Ñ‹Ğº
        if not language:
            language = detect_language(filepath)
        
        lang_config = LANGUAGES.get(language, {})
        run_cmd = lang_config.get("run_command")
        
        if not run_cmd:
            return 1, "", f"Ğ—Ğ°Ğ¿ÑƒÑĞº {language} Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ", 0.0
        
        # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ
        path = Path(filepath)
        cmd = run_cmd.replace("{file}", str(path.absolute()))
        cmd = cmd.replace("{name}", path.stem)
        cmd = cmd.replace("{dir}", str(path.parent.absolute()))
        
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼
        start_time = time.time()
        
        try:
            # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‡ÑƒÑ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ
            cwd = str(path.parent)
            
            result = subprocess.run(
                cmd,
                shell=True,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=300  # 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚
            )
            
            duration = time.time() - start_time
            
            self.last_output = result.stdout
            self.last_error = result.stderr
            self.last_return_code = result.returncode
            self.last_duration = duration
            
            return result.returncode, result.stdout, result.stderr, duration
            
        except subprocess.TimeoutExpired:
            return 124, "", "ĞŸÑ€ĞµĞ²Ñ‹ÑˆĞµĞ½Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ (5 Ğ¼Ğ¸Ğ½)", time.time() - start_time
        except Exception as e:
            return 1, "", str(e), time.time() - start_time
    
    def run_interactive(self, filepath: str, language: str = None):
        """Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ (Ğ² Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğµ)"""
        if not language:
            language = detect_language(filepath)
        
        lang_config = LANGUAGES.get(language, {})
        run_cmd = lang_config.get("run_command")
        
        if not run_cmd:
            return False, f"Ğ—Ğ°Ğ¿ÑƒÑĞº {language} Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ"
        
        path = Path(filepath)
        cmd = run_cmd.replace("{file}", str(path.absolute()))
        cmd = cmd.replace("{name}", path.stem)
        
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ² Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğµ
        try:
            # Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¸Ğ· curses
            curses.endwin()
            
            print(f"\n{'='*60}")
            print(f"ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº: {cmd}")
            print(f"{'='*60}\n")
            
            start_time = time.time()
            return_code = os.system(cmd)
            duration = time.time() - start_time
            
            print(f"\n{'='*60}")
            if return_code == 0:
                print(f"âœ… Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ Ğ·Ğ° {duration:.2f}Ñ")
            else:
                print(f"âŒ ĞšĞ¾Ğ´ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ°: {return_code}")
            print(f"{'='*60}")
            
            input("\nĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter Ğ´Ğ»Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ° Ğ² Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€...")
            
            return True, ""
            
        except Exception as e:
            return False, str(e)
    
    def get_repl(self, language: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ REPL Ğ´Ğ»Ñ ÑĞ·Ñ‹ĞºĞ°"""
        lang_config = LANGUAGES.get(language, {})
        return lang_config.get("repl")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ–¥ï¸ Ğ’Ğ¡Ğ¢Ğ ĞĞ•ĞĞĞ«Ğ™ Ğ¢Ğ•Ğ ĞœĞ˜ĞĞĞ›
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Terminal:
    """Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»"""
    
    def __init__(self):
        self.history: List[str] = []
        self.history_index = 0
        self.cwd = os.getcwd()
        self.env = os.environ.copy()
        self.output_lines: List[str] = []
        self.max_output_lines = 1000
        self._load_history()
    
    def _load_history(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´"""
        try:
            history_file = Config.HISTORY_FILE
            if history_file.exists():
                with open(history_file, 'r') as f:
                    data = json.load(f)
                    self.history = data.get("commands", [])[-100:]  # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 100
        except:
            pass
    
    def _save_history(self):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´"""
        try:
            history_file = Config.HISTORY_FILE
            history_file.parent.mkdir(parents=True, exist_ok=True)
            with open(history_file, 'w') as f:
                json.dump({"commands": self.history[-100:]}, f)
        except:
            pass
    
    def execute(self, command: str) -> Tuple[str, int]:
        """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ"""
        if not command.strip():
            return "", 0
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ
        if not self.history or self.history[-1] != command:
            self.history.append(command)
            self._save_history()
        
        self.history_index = len(self.history)
        
        # Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
        if command.strip() == "clear":
            self.output_lines.clear()
            return "", 0
        
        if command.strip().startswith("cd "):
            new_dir = command[3:].strip()
            try:
                if new_dir == "~":
                    new_dir = str(Path.home())
                elif new_dir == "-":
                    new_dir = self.env.get("OLDPWD", self.cwd)
                
                new_path = Path(new_dir)
                if not new_path.is_absolute():
                    new_path = Path(self.cwd) / new_path
                
                new_path = new_path.resolve()
                
                if new_path.exists() and new_path.is_dir():
                    self.env["OLDPWD"] = self.cwd
                    self.cwd = str(new_path)
                    os.chdir(self.cwd)
                    return "", 0
                else:
                    return f"cd: {new_dir}: ĞĞµÑ‚ Ñ‚Ğ°ĞºĞ¾Ğ³Ğ¾ ĞºĞ°Ñ‚Ğ°Ğ»Ğ¾Ğ³Ğ°", 1
            except Exception as e:
                return f"cd: {e}", 1
        
        if command.strip() == "pwd":
            return self.cwd, 0
        
        if command.strip() == "history":
            return "\n".join(f"{i+1}  {cmd}" for i, cmd in enumerate(self.history[-20:])), 0
        
        # Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
        try:
            result = subprocess.run(
                command,
                shell=True,
                cwd=self.cwd,
                env=self.env,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            output = result.stdout
            if result.stderr:
                output += result.stderr
            
            return output.rstrip(), result.returncode
            
        except subprocess.TimeoutExpired:
            return "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ¿Ñ€ĞµĞ²Ñ‹ÑĞ¸Ğ»Ğ° Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ (60Ñ)", 124
        except Exception as e:
            return str(e), 1
    
    def add_output(self, text: str):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ²Ğ¾Ğ´"""
        lines = text.split('\n')
        self.output_lines.extend(lines)
        
        # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑÑ‚Ñ€Ğ¾Ğº
        if len(self.output_lines) > self.max_output_lines:
            self.output_lines = self.output_lines[-self.max_output_lines:]
    
    def get_prompt(self) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸"""
        user = os.environ.get("USER", "user")
        short_cwd = self.cwd.replace(str(Path.home()), "~")
        return f"{user}@dipo:{short_cwd}$ "
    
    def previous_command(self) -> str:
        """ĞŸÑ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ¸Ğ· Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸"""
        if self.history and self.history_index > 0:
            self.history_index -= 1
            return self.history[self.history_index]
        return ""
    
    def next_command(self) -> str:
        """Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ¸Ğ· Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸"""
        if self.history_index < len(self.history) - 1:
            self.history_index += 1
            return self.history[self.history_index]
        self.history_index = len(self.history)
        return ""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ ĞŸĞ ĞĞ’ĞĞ”ĞĞ˜Ğš Ğ¤ĞĞ™Ğ›ĞĞ’ Ğ¡ DRAG & DROP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class FileItem:
    """Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ² Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
    
    def __init__(self, path: Path, level: int = 0):
        self.path = path
        self.level = level
        self.is_dir = path.is_dir()
        self.expanded = False
        self.selected = False
        self.cut = False  # Ğ”Ğ»Ñ Ğ²Ñ‹Ñ€ĞµĞ·Ğ°Ğ½Ğ¸Ñ
    
    @property
    def name(self) -> str:
        return self.path.name or str(self.path)
    
    @property
    def icon(self) -> str:
        if self.is_dir:
            return "ğŸ“‚" if self.expanded else "ğŸ“"
        
        # ĞŸĞ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
        ext = self.path.suffix.lower()
        
        for lang, config in LANGUAGES.items():
            if ext in config.get("extensions", []):
                return config.get("icon", "ğŸ“„")
        
        # Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
        special = {
            ".gitignore": "ğŸ™ˆ",
            ".env": "ğŸ”",
            "Makefile": "ğŸ”§",
            "Dockerfile": "ğŸ³",
            "docker-compose.yml": "ğŸ³",
            "package.json": "ğŸ“¦",
            "requirements.txt": "ğŸ“‹",
            "README.md": "ğŸ“–",
            "LICENSE": "ğŸ“œ",
            ".jpg": "ğŸ–¼ï¸", ".jpeg": "ğŸ–¼ï¸", ".png": "ğŸ–¼ï¸", ".gif": "ğŸ–¼ï¸",
            ".mp3": "ğŸµ", ".wav": "ğŸµ", ".ogg": "ğŸµ",
            ".mp4": "ğŸ¬", ".avi": "ğŸ¬", ".mkv": "ğŸ¬",
            ".zip": "ğŸ“¦", ".tar": "ğŸ“¦", ".gz": "ğŸ“¦", ".rar": "ğŸ“¦",
            ".pdf": "ğŸ“•",
            ".exe": "âš™ï¸", ".dll": "âš™ï¸",
        }
        
        if self.name in special:
            return special[self.name]
        if ext in special:
            return special[ext]
        
        return "ğŸ“„"


class FileExplorer:
    """ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ drag & drop"""
    
    def __init__(self, root_path: str = None):
        self.root_path = Path(root_path or os.getcwd()).resolve()
        self.items: List[FileItem] = []
        self.cursor = 0
        self.scroll = 0
        self.show_hidden = False
        
        # Clipboard Ğ´Ğ»Ñ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ/Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ
        self.clipboard: List[Path] = []
        self.clipboard_operation: str = ""  # "copy" Ğ¸Ğ»Ğ¸ "cut"
        
        # Drag & drop
        self.dragging: Optional[FileItem] = None
        self.drag_target_index: int = -1
        
        self.refresh()
    
    def refresh(self):
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
        self.items = []
        self._scan_directory(self.root_path, 0)
    
    def _scan_directory(self, path: Path, level: int, parent_expanded: bool = True):
        """Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ"""
        if not parent_expanded:
            return
        
        try:
            entries = sorted(path.iterdir(), key=lambda p: (not p.is_dir(), p.name.lower()))
            
            for entry in entries:
                # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ÑĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾
                if not self.show_hidden and entry.name.startswith('.'):
                    continue
                
                item = FileItem(entry, level)
                
                # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ expanded
                for old_item in self.items:
                    if old_item.path == entry:
                        item.expanded = old_item.expanded
                        break
                
                self.items.append(item)
                
                if item.is_dir and item.expanded:
                    self._scan_directory(entry, level + 1, True)
        except PermissionError:
            pass
    
    @property
    def current_item(self) -> Optional[FileItem]:
        """Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚"""
        if 0 <= self.cursor < len(self.items):
            return self.items[self.cursor]
        return None
    
    def move_up(self):
        """Ğ”Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒÑÑ Ğ²Ğ²ĞµÑ€Ñ…"""
        if self.cursor > 0:
            self.cursor -= 1
    
    def move_down(self):
        """Ğ”Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒÑÑ Ğ²Ğ½Ğ¸Ğ·"""
        if self.cursor < len(self.items) - 1:
            self.cursor += 1
    
    def toggle_expand(self):
        """Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ/ÑĞ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¿Ğ°Ğ¿ĞºÑƒ"""
        item = self.current_item
        if item and item.is_dir:
            item.expanded = not item.expanded
            self.refresh()
    
    def enter(self) -> Optional[Path]:
        """ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» Ğ¸Ğ»Ğ¸ Ğ²Ğ¾Ğ¹Ñ‚Ğ¸ Ğ² Ğ¿Ğ°Ğ¿ĞºÑƒ"""
        item = self.current_item
        if not item:
            return None
        
        if item.is_dir:
            self.toggle_expand()
            return None
        else:
            return item.path
    
    def go_up(self):
        """ĞŸĞ¾Ğ´Ğ½ÑÑ‚ÑŒÑÑ Ğ½Ğ° ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ²Ğ²ĞµÑ€Ñ…"""
        parent = self.root_path.parent
        if parent != self.root_path:
            self.root_path = parent
            self.cursor = 0
            self.refresh()
    
    def go_to(self, path: Path):
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½ÑƒÑ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ"""
        if path.is_dir():
            self.root_path = path.resolve()
            self.cursor = 0
            self.refresh()
    
    def toggle_hidden(self):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
        self.show_hidden = not self.show_hidden
        self.refresh()
    
    def toggle_select(self):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ"""
        item = self.current_item
        if item:
            item.selected = not item.selected
    
    def get_selected(self) -> List[Path]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹"""
        selected = [item.path for item in self.items if item.selected]
        if not selected and self.current_item:
            selected = [self.current_item.path]
        return selected
    
    def copy(self):
        """ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ"""
        self.clipboard = self.get_selected()
        self.clipboard_operation = "copy"
        
        for item in self.items:
            item.cut = False
    
    def cut(self):
        """Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ"""
        self.clipboard = self.get_selected()
        self.clipboard_operation = "cut"
        
        for item in self.items:
            item.cut = item.path in self.clipboard
    
    def paste(self) -> Tuple[bool, str]:
        """Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ"""
        if not self.clipboard:
            return False, "Ğ‘ÑƒÑ„ĞµÑ€ Ğ¿ÑƒÑÑ‚"
        
        dest_dir = self.current_item.path if self.current_item and self.current_item.is_dir else self.root_path
        
        try:
            for src in self.clipboard:
                dest = dest_dir / src.name
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚Ñ‹ Ğ¸Ğ¼Ñ‘Ğ½
                counter = 1
                original_dest = dest
                while dest.exists():
                    if src.is_dir():
                        dest = original_dest.parent / f"{original_dest.stem}_{counter}"
                    else:
                        dest = original_dest.parent / f"{original_dest.stem}_{counter}{original_dest.suffix}"
                    counter += 1
                
                if self.clipboard_operation == "copy":
                    if src.is_dir():
                        shutil.copytree(src, dest)
                    else:
                        shutil.copy2(src, dest)
                elif self.clipboard_operation == "cut":
                    shutil.move(str(src), str(dest))
            
            if self.clipboard_operation == "cut":
                self.clipboard.clear()
            
            self.refresh()
            return True, f"{'Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾' if self.clipboard_operation == 'copy' else 'ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¾'}"
            
        except Exception as e:
            return False, str(e)
    
    def delete(self) -> Tuple[bool, str]:
        """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ"""
        selected = self.get_selected()
        if not selected:
            return False, "ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾"
        
        try:
            for path in selected:
                if path.is_dir():
                    shutil.rmtree(path)
                else:
                    path.unlink()
            
            self.refresh()
            return True, f"Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾: {len(selected)} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²"
            
        except Exception as e:
            return False, str(e)
    
    def rename(self, new_name: str) -> Tuple[bool, str]:
        """ĞŸĞµÑ€ĞµĞ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚"""
        item = self.current_item
        if not item:
            return False, "ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾"
        
        try:
            new_path = item.path.parent / new_name
            item.path.rename(new_path)
            self.refresh()
            return True, f"ĞŸĞµÑ€ĞµĞ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² {new_name}"
        except Exception as e:
            return False, str(e)
    
    def create_file(self, name: str) -> Tuple[bool, str]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
        try:
            new_path = self.root_path / name
            new_path.touch()
            self.refresh()
            return True, f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½: {name}"
        except Exception as e:
            return False, str(e)
    
    def create_directory(self, name: str) -> Tuple[bool, str]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ"""
        try:
            new_path = self.root_path / name
            new_path.mkdir(parents=True)
            self.refresh()
            return True, f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ğ¿Ğ°Ğ¿ĞºĞ°: {name}"
        except Exception as e:
            return False, str(e)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Drag & Drop
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def start_drag(self):
        """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ"""
        self.dragging = self.current_item
    
    def drag_to(self, index: int):
        """ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚ÑŒ Ğº Ğ¸Ğ½Ğ´ĞµĞºÑÑƒ"""
        self.drag_target_index = index
    
    def drop(self) -> Tuple[bool, str]:
        """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ"""
        if not self.dragging or self.drag_target_index < 0:
            self.dragging = None
            self.drag_target_index = -1
            return False, "ĞĞµÑ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ"
        
        target_item = self.items[self.drag_target_index] if self.drag_target_index < len(self.items) else None
        
        if not target_item:
            self.dragging = None
            self.drag_target_index = -1
            return False, "ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ñ†ĞµĞ»ÑŒ"
        
        # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
        if target_item.is_dir:
            dest_dir = target_item.path
        else:
            dest_dir = target_item.path.parent
        
        try:
            src = self.dragging.path
            dest = dest_dir / src.name
            
            if src == dest or dest.is_relative_to(src):
                return False, "ĞĞµĞ»ÑŒĞ·Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ² ÑĞµĞ±Ñ"
            
            # ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°ĞµĞ¼
            shutil.move(str(src), str(dest))
            
            self.dragging = None
            self.drag_target_index = -1
            self.refresh()
            
            return True, f"ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¾ Ğ² {dest_dir.name}"
            
        except Exception as e:
            self.dragging = None
            self.drag_target_index = -1
            return False, str(e)
    
    def cancel_drag(self):
        """ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ"""
        self.dragging = None
        self.drag_target_index = -1


# ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ§Ğ°ÑÑ‚Ğ¸ 5...
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ–¥ï¸ Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ ĞšĞ›ĞĞ¡Ğ¡ Ğ Ğ•Ğ”ĞĞšĞ¢ĞĞ Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DipoEditor:
    """
    ğŸš€ Dipo Studio - Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğ°
    
    Ğ ĞµĞ²Ğ¾Ğ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°
    """
    
    VERSION = "3.0.0"
    
    def __init__(self, stdscr, files: List[str] = None):
        self.stdscr = stdscr
        self.running = True
        
        # ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
        self.config = Config()
        
        # Ğ‘ÑƒÑ„ĞµÑ€Ñ‹ (Ğ²ĞºĞ»Ğ°Ğ´ĞºĞ¸)
        self.buffers: List[TextBuffer] = []
        self.active_buffer_index = 0
        
        # ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹
        self.ai_manager = AIManager()
        self.smart_bot = SmartBot()
        self.git = GitManager()
        self.code_runner = CodeRunner()
        self.terminal = Terminal()
        self.file_explorer = FileExplorer()
        self.autocomplete = AutoCompleteEngine()
        self.linter = Linter()
        
        # UI ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
        self.mode = "normal"  # normal, command, search, replace, goto, ai, terminal, explorer
        self.message = ""
        self.message_type = "info"
        self.message_time = 0
        
        # Ğ¢ĞµĞ¼Ğ°
        self.theme_name = self.config.get("theme", "cosmos")
        self.theme = THEMES.get(self.theme_name, THEMES["cosmos"])
        
        # ĞŸĞ°Ğ½ĞµĞ»Ğ¸
        self.show_sidebar = False
        self.sidebar_width = 30
        self.show_terminal = False
        self.terminal_height = 10
        self.show_minimap = self.config.get("show_minimap", False)
        self.minimap_width = 15
        self.zen_mode = False
        
        # ĞŸĞ¾Ğ¸ÑĞº/Ğ·Ğ°Ğ¼ĞµĞ½Ğ°
        self.search_input = ""
        self.replace_input = ""
        self.search_case_sensitive = False
        self.search_whole_word = False
        self.search_regex = False
        
        # ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
        self.show_autocomplete = False
        self.autocomplete_items: List[CompletionItem] = []
        self.autocomplete_index = 0
        
        # ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°
        self.command_input = ""
        self.command_history: List[str] = []
        self.command_history_index = 0
        
        # AI Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³
        self.ai_input = ""
        self.ai_response = ""
        self.ai_loading = False
        
        # Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¸
        self.dialog_mode = ""  # save_as, open, new_file, confirm, etc.
        self.dialog_input = ""
        self.dialog_callback = None
        
        # Clipboard
        self.clipboard = ""
        self.clipboard_history: List[str] = []
        
        # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
        self.recent_files: List[str] = []
        self._load_recent_files()
        
        # ĞĞ²Ñ‚Ğ¾ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
        self.autosave_timer = 0
        self.last_autosave = time.time()
        
        # Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ curses
        self._init_curses()
        
        # ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ğ±ÑƒÑ„ĞµÑ€
        if files:
            for filepath in files:
                self.open_file(filepath)
        
        if not self.buffers:
            self.new_buffer()
        
        # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ
        self.show_message(f"ğŸš€ Dipo Studio v{self.VERSION} | F1 - Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° | F10 - AI", "success")
    
    def _init_curses(self):
        """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ curses"""
        try:
            # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑĞºÑ€Ğ°Ğ½Ğ°
            curses.curs_set(1)  # Ğ’Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ğ¹ ĞºÑƒÑ€ÑĞ¾Ñ€
            self.stdscr.keypad(True)
            self.stdscr.timeout(100)  # 100ms Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹
            
            # Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²
            ColorManager.init()
            
            # ĞœÑ‹ÑˆÑŒ (ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ)
            try:
                curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
            except:
                pass
            
        except Exception as e:
            pass
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“„ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ‘Ğ£Ğ¤Ğ•Ğ ĞĞœĞ˜
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @property
    def buffer(self) -> TextBuffer:
        """ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ±ÑƒÑ„ĞµÑ€"""
        if 0 <= self.active_buffer_index < len(self.buffers):
            return self.buffers[self.active_buffer_index]
        return self.buffers[0] if self.buffers else None
    
    def new_buffer(self, filepath: str = None) -> TextBuffer:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ±ÑƒÑ„ĞµÑ€"""
        buf = TextBuffer()
        if filepath:
            buf.load_file(filepath)
        self.buffers.append(buf)
        self.active_buffer_index = len(self.buffers) - 1
        return buf
    
    def close_buffer(self, index: int = None) -> bool:
        """Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ±ÑƒÑ„ĞµÑ€"""
        if index is None:
            index = self.active_buffer_index
        
        if index < 0 or index >= len(self.buffers):
            return False
        
        buf = self.buffers[index]
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½ĞµÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹
        if buf.modified:
            self.show_confirm_dialog(
                "Ğ¤Ğ°Ğ¹Ğ» Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ?",
                lambda yes: self._close_buffer_confirmed(index, yes)
            )
            return False
        
        return self._close_buffer_confirmed(index, False)
    
    def _close_buffer_confirmed(self, index: int, save: bool) -> bool:
        """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ñ‘Ğ½Ğ½Ğ¾Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ±ÑƒÑ„ĞµÑ€Ğ°"""
        if save and self.buffers[index].modified:
            self.save_file()
        
        del self.buffers[index]
        
        if not self.buffers:
            self.new_buffer()
        
        if self.active_buffer_index >= len(self.buffers):
            self.active_buffer_index = len(self.buffers) - 1
        
        return True
    
    def switch_buffer(self, index: int):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ±ÑƒÑ„ĞµÑ€"""
        if 0 <= index < len(self.buffers):
            self.active_buffer_index = index
            self.show_autocomplete = False
    
    def next_buffer(self):
        """Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ±ÑƒÑ„ĞµÑ€"""
        self.switch_buffer((self.active_buffer_index + 1) % len(self.buffers))
    
    def prev_buffer(self):
        """ĞŸÑ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ğ±ÑƒÑ„ĞµÑ€"""
        self.switch_buffer((self.active_buffer_index - 1) % len(self.buffers))
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“ Ğ¤ĞĞ™Ğ›ĞĞ’Ğ«Ğ• ĞĞŸĞ•Ğ ĞĞ¦Ğ˜Ğ˜
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def open_file(self, filepath: str = None):
        """ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
        if filepath:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ Ğ»Ğ¸ ÑƒĞ¶Ğµ
            for i, buf in enumerate(self.buffers):
                if buf.filepath and Path(buf.filepath).resolve() == Path(filepath).resolve():
                    self.switch_buffer(i)
                    self.show_message(f"ğŸ“„ Ğ¤Ğ°Ğ¹Ğ» ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚", "info")
                    return
            
            buf = self.new_buffer(filepath)
            success, msg = buf.load_file(filepath)
            
            if success:
                self._add_recent_file(filepath)
                self.show_message(f"ğŸ“„ {msg}", "success")
            else:
                self.show_message(f"âŒ {msg}", "error")
        else:
            # ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ„Ğ°Ğ¹Ğ»Ğ°
            self.mode = "explorer"
            self.file_explorer.go_to(Path.cwd())
    
    def save_file(self, filepath: str = None):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
        if not self.buffer:
            return
        
        if filepath:
            success, msg = self.buffer.save_file(filepath)
        elif self.buffer.filepath:
            success, msg = self.buffer.save_file()
        else:
            # ĞĞµÑ‚ Ğ¸Ğ¼ĞµĞ½Ğ¸ - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³
            self.show_input_dialog("Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº:", self._save_file_callback)
            return
        
        if success:
            self._add_recent_file(self.buffer.filepath)
            self.show_message(f"ğŸ’¾ {msg}", "success")
            
            # Ğ›Ğ¸Ğ½Ñ‚Ğ¸Ğ½Ğ³ Ğ¿Ğ¾ÑĞ»Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ
            if self.config.get("lint_on_save", True):
                self.linter.lint(self.buffer)
        else:
            self.show_message(f"âŒ {msg}", "error")
    
    def _save_file_callback(self, filename: str):
        """Callback Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        if filename:
            self.save_file(filename)
    
    def _add_recent_file(self, filepath: str):
        """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹"""
        if filepath in self.recent_files:
            self.recent_files.remove(filepath)
        self.recent_files.insert(0, filepath)
        self.recent_files = self.recent_files[:20]
        self._save_recent_files()
    
    def _load_recent_files(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹"""
        try:
            recent_file = Config.CONFIG_DIR / "recent_files.json"
            if recent_file.exists():
                with open(recent_file, 'r') as f:
                    self.recent_files = json.load(f)
        except:
            pass
    
    def _save_recent_files(self):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹"""
        try:
            recent_file = Config.CONFIG_DIR / "recent_files.json"
            with open(recent_file, 'w') as f:
                json.dump(self.recent_files, f)
        except:
            pass
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¨ Ğ Ğ•ĞĞ”Ğ•Ğ Ğ˜ĞĞ“
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def render(self):
        """Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¾Ñ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ¸"""
        try:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()
            
            if height < 5 or width < 20:
                self.stdscr.addstr(0, 0, "ĞĞºĞ½Ğ¾ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¾Ğµ")
                self.stdscr.refresh()
                return
            
            if self.zen_mode:
                self._render_zen_mode(height, width)
            else:
                # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ĞµĞ¹
                header_height = 1
                footer_height = 2
                terminal_h = self.terminal_height if self.show_terminal else 0
                sidebar_w = self.sidebar_width if self.show_sidebar else 0
                minimap_w = self.minimap_width if self.show_minimap else 0
                
                editor_height = height - header_height - footer_height - terminal_h
                editor_width = width - sidebar_w - minimap_w
                editor_start_x = sidebar_w
                editor_start_y = header_height
                
                # Ğ ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ¼ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹
                self._render_header(0, width)
                
                if self.show_sidebar:
                    self._render_sidebar(header_height, editor_height, sidebar_w)
                
                self._render_editor(editor_start_y, editor_height, editor_start_x, editor_width)
                
                if self.show_minimap:
                    self._render_minimap(editor_start_y, editor_height, width - minimap_w, minimap_w)
                
                if self.show_terminal:
                    self._render_terminal(height - footer_height - terminal_h, terminal_h, width)
                
                self._render_statusbar(height - 2, width)
                self._render_footer(height - 1, width)
            
            # ĞĞ²ĞµÑ€Ğ»ĞµĞ¸
            self._render_message(height, width)
            
            if self.show_autocomplete:
                self._render_autocomplete(height, width)
            
            # Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¸
            if self.mode == "search":
                self._render_search_dialog(height, width)
            elif self.mode == "replace":
                self._render_replace_dialog(height, width)
            elif self.mode == "goto":
                self._render_goto_dialog(height, width)
            elif self.mode == "command":
                self._render_command_palette(height, width)
            elif self.mode == "ai":
                self._render_ai_dialog(height, width)
            elif self.mode == "explorer":
                self._render_file_explorer_dialog(height, width)
            elif self.dialog_mode:
                self._render_dialog(height, width)
            
            self.stdscr.refresh()
            
        except curses.error:
            pass
        except Exception as e:
            try:
                self.stdscr.addstr(0, 0, f"Render error: {e}")
            except:
                pass
    
    def _render_header(self, y: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ°"""
        theme = self.theme
        header_attr = ColorManager.get_pair(
            theme["colors"].get("header_fg", "white"),
            theme["colors"].get("header_bg", "blue"),
            bold=True
        )
        
        # Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ñ„Ğ¾Ğ½
        try:
            self.stdscr.addstr(y, 0, " " * width, header_attr)
        except:
            pass
        
        # Ğ›Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿
        logo = "ğŸš€ Dipo"
        self.stdscr.addstr(y, 1, logo, header_attr)
        
        # Ğ’ĞºĞ»Ğ°Ğ´ĞºĞ¸
        tab_x = 10
        for i, buf in enumerate(self.buffers):
            if tab_x >= width - 20:
                break
            
            name = Path(buf.filepath).name if buf.filepath else "ĞĞ¾Ğ²Ñ‹Ğ¹"
            if len(name) > 15:
                name = name[:12] + "..."
            
            modified = "â—" if buf.modified else ""
            tab_text = f" {name}{modified} "
            
            if i == self.active_buffer_index:
                tab_attr = ColorManager.get_pair("black", "white", bold=True)
            else:
                tab_attr = header_attr
            
            try:
                self.stdscr.addstr(y, tab_x, tab_text, tab_attr)
                tab_x += len(tab_text) + 1
            except:
                break
        
        # ĞŸÑ€Ğ°Ğ²Ğ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ: ÑĞ·Ñ‹Ğº, git, Ñ‚ĞµĞ¼Ğ°
        right_info = []
        
        if self.buffer:
            lang_config = LANGUAGES.get(self.buffer.language, {})
            right_info.append(f"{lang_config.get('icon', 'ğŸ“„')} {lang_config.get('name', 'Text')}")
        
        if self.git.available and self.buffer and self.buffer.filepath:
            git_dir = str(Path(self.buffer.filepath).parent)
            if self.git.is_repo(git_dir):
                branch = self.git.get_branch(git_dir)
                right_info.append(f"ğŸŒ¿ {branch}")
        
        right_info.append(theme.get("name", "ğŸ¨"))
        
        right_text = " â”‚ ".join(right_info)
        right_x = width - len(right_text) - 2
        
        if right_x > tab_x:
            try:
                self.stdscr.addstr(y, right_x, right_text, header_attr)
            except:
                pass
    
    def _render_editor(self, start_y: int, height: int, start_x: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğ°"""
        if not self.buffer:
            return
        
        theme = self.theme
        buf = self.buffer
        
        # Ğ¨Ğ¸Ñ€Ğ¸Ğ½Ğ° Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ² ÑÑ‚Ñ€Ğ¾Ğº
        line_num_width = len(str(buf.total_lines)) + 2 if self.config.get("show_line_numbers", True) else 0
        text_width = width - line_num_width - 1
        
        if text_width < 1:
            return
        
        # ĞŸĞ¾Ğ´ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ¸
        visible_height = height
        
        if buf.cursor_line < buf.scroll_y:
            buf.scroll_y = buf.cursor_line
        elif buf.cursor_line >= buf.scroll_y + visible_height:
            buf.scroll_y = buf.cursor_line - visible_height + 1
        
        if buf.cursor_col < buf.scroll_x:
            buf.scroll_x = buf.cursor_col
        elif buf.cursor_col >= buf.scroll_x + text_width:
            buf.scroll_x = buf.cursor_col - text_width + 1
        
        # ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° ÑÑ‚Ñ€Ğ¾Ğº
        for screen_row in range(height):
            line_num = buf.scroll_y + screen_row
            screen_y = start_y + screen_row
            
            if screen_y >= curses.LINES - 2:
                break
            
            # ĞĞ¾Ğ¼ĞµÑ€ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ¸Ğ»Ğ¸ Ñ‚Ğ¸Ğ»ÑŒĞ´Ğ°
            if line_num >= len(buf.lines):
                if self.config.get("show_line_numbers", True):
                    try:
                        tilde = "~".rjust(line_num_width - 1) + " "
                        self.stdscr.addstr(screen_y, start_x, tilde,
                                          ColorManager.get_pair(theme["colors"].get("line_number", "cyan")))
                    except:
                        pass
                continue
            
            # ĞĞ¾Ğ¼ĞµÑ€ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            if self.config.get("show_line_numbers", True):
                is_current = line_num == buf.cursor_line
                num_color = theme["colors"].get("line_number_active" if is_current else "line_number", "cyan")
                num_attr = ColorManager.get_pair(num_color, bold=is_current)
                
                num_str = str(line_num + 1).rjust(line_num_width - 1) + " "
                try:
                    self.stdscr.addstr(screen_y, start_x, num_str, num_attr)
                except:
                    pass
            
            # ĞŸĞ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            if line_num == buf.cursor_line and self.config.get("highlight_current_line", True):
                current_line_attr = ColorManager.get_pair(
                    theme["colors"].get("fg", "white"),
                    theme["colors"].get("current_line", "236")
                )
                try:
                    self.stdscr.addstr(screen_y, start_x + line_num_width, " " * text_width, current_line_attr)
                except:
                    pass
            
            # Ğ¢ĞµĞºÑÑ‚ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ñ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ¾Ğ¹
            line = buf.lines[line_num]
            visible_line = line[buf.scroll_x:buf.scroll_x + text_width]
            
            # Ğ¢Ğ¾ĞºĞµĞ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ¸
            tokens = buf.highlighter.tokenize_line(line, line_num)
            
            # ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ²
            screen_col = start_x + line_num_width
            char_index = 0
            
            for token in tokens:
                token_start = token.start
                token_end = token.end
                
                # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ´Ğ¾ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾Ğ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸
                if token_end <= buf.scroll_x:
                    continue
                
                # ĞŸÑ€ĞµĞºÑ€Ğ°Ñ‰Ğ°ĞµĞ¼ ĞµÑĞ»Ğ¸ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ·Ğ° Ğ²Ğ¸Ğ´Ğ¸Ğ¼ÑƒÑ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ
                if token_start >= buf.scroll_x + text_width:
                    break
                
                # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼ÑƒÑ Ñ‡Ğ°ÑÑ‚ÑŒ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
                visible_start = max(token_start - buf.scroll_x, 0)
                visible_end = min(token_end - buf.scroll_x, text_width)
                
                if visible_start >= visible_end:
                    continue
                
                text_to_draw = line[buf.scroll_x + visible_start:buf.scroll_x + visible_end]
                
                attr = buf.highlighter.get_token_attr(token.type)
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ñ
                if buf.cursor.has_selection:
                    sel = buf.cursor.selection
                    # Ğ•ÑĞ»Ğ¸ Ñ‚Ğ¾ĞºĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ğ² Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ
                    for ci, char in enumerate(text_to_draw):
                        char_line_col = buf.scroll_x + visible_start + ci
                        pos = Position(line_num, char_line_col)
                        if sel.start <= pos <= sel.end or sel.end <= pos <= sel.start:
                            attr = ColorManager.get_pair("white", theme["colors"].get("selection", "blue"))
                
                try:
                    self.stdscr.addstr(screen_y, screen_col + visible_start, text_to_draw, attr)
                except:
                    pass
            
            # ĞŸĞ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ° Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğ¹
            for match_line, match_start, match_end in buf.search_matches:
                if match_line == line_num:
                    vis_start = max(match_start - buf.scroll_x, 0)
                    vis_end = min(match_end - buf.scroll_x, text_width)
                    
                    if vis_start < vis_end:
                        match_text = line[buf.scroll_x + vis_start:buf.scroll_x + vis_end]
                        match_attr = ColorManager.get_pair(
                            "black",
                            theme["colors"].get("search_match", "yellow"),
                            bold=True
                        )
                        try:
                            self.stdscr.addstr(screen_y, screen_col + vis_start, match_text, match_attr)
                        except:
                            pass
            
            # Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ°
            if line_num in buf.bookmarks:
                try:
                    self.stdscr.addstr(screen_y, start_x, "ğŸ”–", ColorManager.get_pair("yellow"))
                except:
                    pass
        
        # ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ ĞºÑƒÑ€ÑĞ¾Ñ€
        cursor_screen_y = start_y + buf.cursor_line - buf.scroll_y
        cursor_screen_x = start_x + line_num_width + buf.cursor_col - buf.scroll_x
        
        if 0 <= cursor_screen_y < start_y + height and 0 <= cursor_screen_x < start_x + width:
            try:
                self.stdscr.move(cursor_screen_y, cursor_screen_x)
            except:
                pass
    
    def _render_sidebar(self, start_y: int, height: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ğ±Ğ¾ĞºĞ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸ (Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº)"""
        theme = self.theme
        sidebar_attr = ColorManager.get_pair(
            theme["colors"].get("sidebar_fg", "cyan"),
            theme["colors"].get("sidebar_bg", "default")
        )
        
        # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº
        title = "ğŸ“‚ ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº"
        try:
            self.stdscr.addstr(start_y, 0, title[:width-1].ljust(width-1), 
                              ColorManager.get_pair("cyan", bold=True))
        except:
            pass
        
        # Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ
        for row in range(start_y, start_y + height):
            try:
                self.stdscr.addstr(row, width - 1, "â”‚", sidebar_attr)
            except:
                pass
        
        # Ğ¤Ğ°Ğ¹Ğ»Ñ‹
        explorer = self.file_explorer
        visible_items = height - 2
        
        # ĞŸĞ¾Ğ´ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ¸
        if explorer.cursor < explorer.scroll:
            explorer.scroll = explorer.cursor
        elif explorer.cursor >= explorer.scroll + visible_items:
            explorer.scroll = explorer.cursor - visible_items + 1
        
        for i in range(visible_items):
            item_idx = explorer.scroll + i
            screen_y = start_y + 1 + i
            
            if item_idx >= len(explorer.items):
                break
            
            item = explorer.items[item_idx]
            indent = "  " * item.level
            
            # Ğ˜ĞºĞ¾Ğ½ĞºĞ° Ğ¸ Ğ¸Ğ¼Ñ
            display = f"{indent}{item.icon} {item.name}"
            if len(display) > width - 2:
                display = display[:width - 5] + "..."
            
            # ĞÑ‚Ñ€Ğ¸Ğ±ÑƒÑ‚Ñ‹
            if item_idx == explorer.cursor:
                attr = ColorManager.get_pair("black", "cyan", bold=True)
            elif item.selected:
                attr = ColorManager.get_pair("yellow", bold=True)
            elif item.cut:
                attr = ColorManager.get_pair("red", dim=True)
            elif item.is_dir:
                attr = ColorManager.get_pair("blue", bold=True)
            else:
                attr = sidebar_attr
            
            try:
                self.stdscr.addstr(screen_y, 0, display.ljust(width - 2), attr)
            except:
                pass
    
    def _render_minimap(self, start_y: int, height: int, start_x: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ğ¼Ğ¸Ğ½Ğ¸-ĞºĞ°Ñ€Ñ‚Ñ‹"""
        if not self.buffer:
            return
        
        buf = self.buffer
        total_lines = len(buf.lines)
        
        if total_lines == 0:
            return
        
        # ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±: ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ñ€Ğ¾Ğº ĞºĞ¾Ğ´Ğ° Ğ½Ğ° Ğ¾Ğ´Ğ½Ñƒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ¼Ğ¸Ğ½Ğ¸ĞºĞ°Ñ€Ñ‚Ñ‹
        scale = max(1, total_lines // height)
        
        for screen_row in range(height):
            source_line = screen_row * scale
            
            if source_line >= total_lines:
                break
            
            # Ğ‘ĞµÑ€Ñ‘Ğ¼ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ñ€Ğ¾Ğº Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ "ÑĞ¶Ğ°Ñ‚Ğ¾Ğµ" Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
            minimap_chars = ""
            for offset in range(min(scale, total_lines - source_line)):
                line = buf.lines[source_line + offset]
                # Ğ¡Ğ¶Ğ¸Ğ¼Ğ°ĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ´Ğ¾ width ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
                if line.strip():
                    minimap_chars += "â–ˆ" * min(len(line.strip()) // 4 + 1, width)
            
            minimap_chars = minimap_chars[:width]
            
            # ĞŸĞ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ° Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾Ğ¹ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚Ğ¸
            is_visible = buf.scroll_y <= source_line < buf.scroll_y + height
            
            if is_visible:
                attr = ColorManager.get_pair("cyan", "236")
            else:
                attr = ColorManager.get_pair("240")
            
            try:
                self.stdscr.addstr(start_y + screen_row, start_x, minimap_chars.ljust(width), attr)
            except:
                pass
    
    def _render_terminal(self, start_y: int, height: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°"""
        theme = self.theme
        
        # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº
        title = "ğŸ–¥ï¸ Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»"
        try:
            self.stdscr.addstr(start_y, 0, title + " " + "â”€" * (width - len(title) - 1),
                              ColorManager.get_pair("cyan", bold=True))
        except:
            pass
        
        # Ğ’Ñ‹Ğ²Ğ¾Ğ´
        output_height = height - 2
        output_lines = self.terminal.output_lines[-(output_height):]
        
        for i, line in enumerate(output_lines):
            try:
                display = line[:width-1]
                self.stdscr.addstr(start_y + 1 + i, 0, display)
            except:
                pass
        
        # Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ°
        prompt = self.terminal.get_prompt()
        input_y = start_y + height - 1
        
        try:
            self.stdscr.addstr(input_y, 0, prompt, ColorManager.get_pair("green", bold=True))
            
            if self.mode == "terminal":
                self.stdscr.addstr(input_y, len(prompt), self.command_input[:width - len(prompt) - 1])
                self.stdscr.move(input_y, len(prompt) + len(self.command_input))
        except:
            pass
    
    def _render_statusbar(self, y: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°"""
        theme = self.theme
        status_attr = ColorManager.get_pair(
            theme["colors"].get("footer_fg", "white"),
            theme["colors"].get("footer_bg", "blue")
        )
        
        try:
            self.stdscr.addstr(y, 0, " " * width, status_attr)
        except:
            pass
        
        if not self.buffer:
            return
        
        buf = self.buffer
        
        # Ğ›ĞµĞ²Ğ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ
        position = f"ğŸ“ {buf.cursor_line + 1}:{buf.cursor_col + 1}"
        
        # Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ
        if buf.cursor.has_selection:
            sel_text = buf.get_selection_text()
            sel_lines = sel_text.count('\n') + 1
            sel_chars = len(sel_text)
            position += f" (sel: {sel_lines}L, {sel_chars}C)"
        
        stats = f"ğŸ“Š {buf.total_lines}L {buf.total_words}W"
        
        left_text = f" {position} â”‚ {stats}"
        
        # ĞŸÑ€Ğ°Ğ²Ğ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ
        right_parts = []
        
        # Ğ ĞµĞ¶Ğ¸Ğ¼
        if self.mode != "normal":
            mode_icons = {
                "search": "ğŸ” ĞŸĞĞ˜Ğ¡Ğš",
                "replace": "ğŸ”„ Ğ—ĞĞœĞ•ĞĞ",
                "command": "âŒ˜ ĞšĞĞœĞĞĞ”Ğ",
                "ai": "ğŸ¤– AI",
                "terminal": "ğŸ–¥ï¸ Ğ¢Ğ•Ğ ĞœĞ˜ĞĞĞ›",
                "explorer": "ğŸ“‚ Ğ¤ĞĞ™Ğ›Ğ«"
            }
            right_parts.append(mode_icons.get(self.mode, self.mode.upper()))
        
        # ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°
        right_parts.append(buf.encoding.upper())
        
        # ĞĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ ÑÑ‚Ñ€Ğ¾Ğº
        right_parts.append("LF" if buf.line_ending == "\n" else "CRLF")
        
        # ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ñ‹
        if len(buf.cursors) > 1:
            right_parts.append(f"ğŸ‘†{len(buf.cursors)}")
        
        right_text = " â”‚ ".join(right_parts) + " "
        
        try:
            self.stdscr.addstr(y, 0, left_text, status_attr)
            self.stdscr.addstr(y, width - len(right_text), right_text, status_attr)
        except:
            pass
    
    def _render_footer(self, y: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·Ğ¾Ğº"""
        hints = "^S Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ â”‚ ^Q Ğ’Ñ‹Ğ¹Ñ‚Ğ¸ â”‚ ^F ĞŸĞ¾Ğ¸ÑĞº â”‚ F5 Ğ—Ğ°Ğ¿ÑƒÑĞº â”‚ F6 Ğ¤Ğ°Ğ¹Ğ»Ñ‹ â”‚ F10 AI â”‚ F1 Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ°"
        
        try:
            self.stdscr.addstr(y, 0, " " * width, ColorManager.get_pair("cyan"))
            self.stdscr.addstr(y, 1, hints[:width - 2], ColorManager.get_pair("cyan"))
        except:
            pass
    
    def _render_zen_mode(self, height: int, width: int):
        """Ğ ĞµĞ¶Ğ¸Ğ¼ Zen - Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ"""
        if not self.buffer:
            return
        
        buf = self.buffer
        
        # ĞÑ‚ÑÑ‚ÑƒĞ¿Ñ‹
        margin_x = max(10, (width - 80) // 2)
        text_width = min(80, width - margin_x * 2)
        margin_y = 2
        text_height = height - margin_y * 2 - 2
        
        # ĞŸĞ¾Ğ´ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ¸
        if buf.cursor_line < buf.scroll_y:
            buf.scroll_y = buf.cursor_line
        elif buf.cursor_line >= buf.scroll_y + text_height:
            buf.scroll_y = buf.cursor_line - text_height + 1
        
        # ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ°
        for i in range(text_height):
            line_num = buf.scroll_y + i
            screen_y = margin_y + i
            
            if line_num >= len(buf.lines):
                continue
            
            line = buf.lines[line_num][:text_width]
            
            # ĞŸĞ¾Ğ´ÑĞ²ĞµÑ‚ĞºĞ°
            tokens = buf.highlighter.tokenize_line(line, line_num)
            
            screen_x = margin_x
            for token in tokens:
                if token.end <= 0 or token.start >= text_width:
                    continue
                
                text = token.text[:text_width]
                attr = buf.highlighter.get_token_attr(token.type)
                
                try:
                    self.stdscr.addstr(screen_y, screen_x + token.start, text, attr)
                except:
                    pass
        
        # ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ²Ğ½Ğ¸Ğ·Ñƒ
        status = f"Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° {buf.cursor_line + 1} â”‚ {buf.total_words} ÑĞ»Ğ¾Ğ² â”‚ ESC - Ğ²Ñ‹Ñ…Ğ¾Ğ´"
        try:
            self.stdscr.addstr(height - 1, width - len(status) - 2, status,
                              ColorManager.get_pair("cyan"))
        except:
            pass
        
        # ĞšÑƒÑ€ÑĞ¾Ñ€
        cursor_y = margin_y + buf.cursor_line - buf.scroll_y
        cursor_x = margin_x + min(buf.cursor_col, text_width)
        
        if margin_y <= cursor_y < height - 2:
            try:
                self.stdscr.move(cursor_y, cursor_x)
            except:
                pass
    
    def _render_message(self, height: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ"""
        if not self.message or time.time() - self.message_time > 4:
            return
        
        colors = {
            "info": "white",
            "success": "green", 
            "warning": "yellow",
            "error": "red"
        }
        
        color = colors.get(self.message_type, "white")
        attr = ColorManager.get_pair(color, bold=True)
        
        msg = self.message[:width - 4]
        x = (width - len(msg)) // 2
        y = height // 2 if self.dialog_mode or self.mode != "normal" else height - 4
        
        try:
            self.stdscr.addstr(y, x, msg, attr)
        except:
            pass
    
    def _render_autocomplete(self, height: int, width: int):
        """ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ"""
        if not self.autocomplete_items:
            return
        
        buf = self.buffer
        if not buf:
            return
        
        # ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¼ĞµĞ½Ñ
        line_num_width = len(str(buf.total_lines)) + 2
        menu_x = (self.sidebar_width if self.show_sidebar else 0) + line_num_width + buf.cursor_col - buf.scroll_x + 1
        menu_y = buf.cursor_line - buf.scroll_y + 2
        
        # Ğ Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ Ğ¼ĞµĞ½Ñ
        menu_width = 35
        menu_height = min(len(self.autocomplete_items), 10)
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹
        if menu_x + menu_width > width:
            menu_x = width - menu_width - 1
        if menu_y + menu_height > height - 3:
            menu_y = buf.cursor_line - buf.scroll_y - menu_height
        
        # Ğ Ğ°Ğ¼ĞºĞ°
        border_attr = ColorManager.get_pair("cyan")
        try:
            self.stdscr.addstr(menu_y - 1, menu_x, "â”Œ" + "â”€" * (menu_width - 2) + "â”", border_attr)
            for i in range(menu_height):
                self.stdscr.addstr(menu_y + i, menu_x, "â”‚", border_attr)
                self.stdscr.addstr(menu_y + i, menu_x + menu_width - 1, "â”‚", border_attr)
            self.stdscr.addstr(menu_y + menu_height, menu_x, "â””" + "â”€" * (menu_width - 2) + "â”˜", border_attr)
        except:
            pass
        
        # Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
        for i, item in enumerate(self.autocomplete_items[:menu_height]):
            y = menu_y + i
            
            if i == self.autocomplete_index:
                attr = ColorManager.get_pair("black", "cyan", bold=True)
            else:
                attr = ColorManager.get_pair("white", "236")
            
            text = f" {item.icon} {item.text}"
            if item.detail:
                text += f" - {item.detail}"
            text = text[:menu_width - 3].ljust(menu_width - 3)
            
            try:
                self.stdscr.addstr(y, menu_x + 1, text, attr)
            except:
                pass
    
    def _render_search_dialog(self, height: int, width: int):
        """Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
        dialog_width = min(60, width - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = 2
        
        self._draw_dialog_box(dialog_y, dialog_x, 5, dialog_width, "ğŸ” ĞŸĞ¾Ğ¸ÑĞº")
        
        # ĞŸĞ¾Ğ»Ğµ Ğ²Ğ²Ğ¾Ğ´Ğ°
        try:
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, "ĞĞ°Ğ¹Ñ‚Ğ¸: ")
            self.stdscr.addstr(dialog_y + 2, dialog_x + 9, self.search_input[:dialog_width - 12],
                              ColorManager.get_pair("white", bold=True))
        except:
            pass
        
        # ĞĞ¿Ñ†Ğ¸Ğ¸
        options = []
        if self.search_case_sensitive:
            options.append("[Aa]")
        if self.search_whole_word:
            options.append("[W]")
        if self.search_regex:
            options.append("[.*]")
        
        options_text = " ".join(options) if options else "F2-Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ F3-ÑĞ»Ğ¾Ğ²Ğ¾ F4-regex"
        try:
            self.stdscr.addstr(dialog_y + 3, dialog_x + 2, options_text[:dialog_width - 4],
                              ColorManager.get_pair("cyan"))
        except:
            pass
        
        # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹
        if self.buffer and self.buffer.search_matches:
            count_text = f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾: {len(self.buffer.search_matches)}"
            try:
                self.stdscr.addstr(dialog_y + 3, dialog_x + dialog_width - len(count_text) - 2,
                                  count_text, ColorManager.get_pair("green"))
            except:
                pass
        
        # ĞšÑƒÑ€ÑĞ¾Ñ€
        try:
            self.stdscr.move(dialog_y + 2, dialog_x + 9 + len(self.search_input))
        except:
            pass
    
    def _render_replace_dialog(self, height: int, width: int):
        """Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ·Ğ°Ğ¼ĞµĞ½Ñ‹"""
        dialog_width = min(60, width - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = 2
        
        self._draw_dialog_box(dialog_y, dialog_x, 6, dialog_width, "ğŸ”„ ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¸ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ")
        
        try:
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, "ĞĞ°Ğ¹Ñ‚Ğ¸:   ")
            self.stdscr.addstr(dialog_y + 2, dialog_x + 11, self.search_input[:dialog_width - 14],
                              ColorManager.get_pair("white", bold=True))
            
            self.stdscr.addstr(dialog_y + 3, dialog_x + 2, "Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ:")
            self.stdscr.addstr(dialog_y + 3, dialog_x + 11, self.replace_input[:dialog_width - 14],
                              ColorManager.get_pair("yellow", bold=True))
            
            self.stdscr.addstr(dialog_y + 4, dialog_x + 2, "Enter-Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ â”‚ ^A-Ğ²ÑĞµ â”‚ ESC-Ğ²Ñ‹Ñ…Ğ¾Ğ´",
                              ColorManager.get_pair("cyan"))
        except:
            pass
        
        # ĞšÑƒÑ€ÑĞ¾Ñ€ Ğ½Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ğ»Ğµ
        # (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ - Ğ²ÑĞµĞ³Ğ´Ğ° Ğ½Ğ° Ğ¿Ğ¾Ğ»Ğµ Ğ·Ğ°Ğ¼ĞµĞ½Ñ‹)
        try:
            self.stdscr.move(dialog_y + 3, dialog_x + 11 + len(self.replace_input))
        except:
            pass
    
    def _render_goto_dialog(self, height: int, width: int):
        """Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ° Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ"""
        dialog_width = 40
        dialog_x = (width - dialog_width) // 2
        dialog_y = height // 3
        
        self._draw_dialog_box(dialog_y, dialog_x, 4, dialog_width, "ğŸ“ ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ")
        
        try:
            max_line = self.buffer.total_lines if self.buffer else 0
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, f"Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° (1-{max_line}): ")
            self.stdscr.addstr(dialog_y + 2, dialog_x + 18, self.search_input,
                              ColorManager.get_pair("white", bold=True))
            self.stdscr.move(dialog_y + 2, dialog_x + 18 + len(self.search_input))
        except:
            pass
    
    def _render_command_palette(self, height: int, width: int):
        """ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°"""
        dialog_width = min(70, width - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = 2
        
        self._draw_dialog_box(dialog_y, dialog_x, 15, dialog_width, "âŒ˜ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°")
        
        try:
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, "> ")
            self.stdscr.addstr(dialog_y + 2, dialog_x + 4, self.command_input[:dialog_width - 6],
                              ColorManager.get_pair("white", bold=True))
        except:
            pass
        
        # Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ (Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ²Ğ²Ğ¾Ğ´Ñƒ)
        commands = self._get_filtered_commands()
        
        for i, (name, desc, key) in enumerate(commands[:10]):
            y = dialog_y + 4 + i
            
            try:
                self.stdscr.addstr(y, dialog_x + 2, name[:20].ljust(20),
                                  ColorManager.get_pair("cyan", bold=True))
                self.stdscr.addstr(y, dialog_x + 24, desc[:dialog_width - 40],
                                  ColorManager.get_pair("white"))
                if key:
                    self.stdscr.addstr(y, dialog_x + dialog_width - len(key) - 2, key,
                                      ColorManager.get_pair("yellow"))
            except:
                pass
        
        try:
            self.stdscr.move(dialog_y + 2, dialog_x + 4 + len(self.command_input))
        except:
            pass
    
    def _get_filtered_commands(self) -> List[Tuple[str, str, str]]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´"""
        all_commands = [
            ("save", "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»", "Ctrl+S"),
            ("save-as", "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº...", "Ctrl+Shift+S"),
            ("open", "ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»", "Ctrl+O"),
            ("new", "ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»", "Ctrl+N"),
            ("close", "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ĞºĞ»Ğ°Ğ´ĞºÑƒ", "Ctrl+W"),
            ("quit", "Ğ’Ñ‹Ğ¹Ñ‚Ğ¸", "Ctrl+Q"),
            ("find", "ĞŸĞ¾Ğ¸ÑĞº", "Ctrl+F"),
            ("replace", "ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¸ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", "Ctrl+H"),
            ("goto", "ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ", "Ctrl+G"),
            ("run", "Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´", "F5"),
            ("terminal", "Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»", "Ctrl+`"),
            ("explorer", "ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²", "F6"),
            ("ai", "AI Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº", "F10"),
            ("theme", "Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞ¼Ñƒ", "F4"),
            ("zen", "Ğ ĞµĞ¶Ğ¸Ğ¼ Zen", "F2"),
            ("git-status", "Git ÑÑ‚Ğ°Ñ‚ÑƒÑ", ""),
            ("git-commit", "Git commit", ""),
            ("format", "Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´", "Ctrl+Shift+I"),
            ("comment", "ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", "Ctrl+/"),
            ("duplicate", "Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ", "Ctrl+D"),
            ("delete-line", "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ", "Ctrl+Shift+K"),
            ("move-up", "ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²Ğ²ĞµÑ€Ñ…", "Alt+â†‘"),
            ("move-down", "ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²Ğ½Ğ¸Ğ·", "Alt+â†“"),
            ("select-all", "Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘", "Ctrl+A"),
            ("undo", "ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", "Ctrl+Z"),
            ("redo", "ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ", "Ctrl+Y"),
            ("bookmark", "Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ°", "Ctrl+B"),
            ("settings", "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸", ""),
        ]
        
        if not self.command_input:
            return all_commands
        
        query = self.command_input.lower()
        return [(n, d, k) for n, d, k in all_commands if query in n.lower() or query in d.lower()]
    
    def _render_ai_dialog(self, height: int, width: int):
        """Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³ AI"""
        dialog_width = min(80, width - 4)
        dialog_height = min(25, height - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = 2
        
        self._draw_dialog_box(dialog_y, dialog_x, dialog_height, dialog_width, "ğŸ¤– AI ĞŸĞ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº")
        
        # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ AI
        if self.ai_manager.config.is_configured():
            provider_name = self.ai_manager.config.provider_name
            model = self.ai_manager.config.model
            status = f"âœ… {provider_name}: {model}"
            status_color = "green"
        else:
            status = "âŒ AI Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'S' Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸"
            status_color = "red"
        
        try:
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, status[:dialog_width - 4],
                              ColorManager.get_pair(status_color))
        except:
            pass
        
        # ĞŸĞ¾Ğ»Ğµ Ğ²Ğ²Ğ¾Ğ´Ğ°
        try:
            self.stdscr.addstr(dialog_y + 4, dialog_x + 2, "Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ: ",
                              ColorManager.get_pair("cyan", bold=True))
            
            # ĞœĞ½Ğ¾Ğ³Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ğ²Ğ²Ğ¾Ğ´ (ÑƒĞ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ¾ - Ğ¾Ğ´Ğ½Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ°)
            self.stdscr.addstr(dialog_y + 4, dialog_x + 10, self.ai_input[:dialog_width - 14],
                              ColorManager.get_pair("white", bold=True))
        except:
            pass
        
        # ĞÑ‚Ğ²ĞµÑ‚ AI
        if self.ai_loading:
            try:
                frame = LOADING_FRAMES[int(time.time() * 10) % len(LOADING_FRAMES)]
                self.stdscr.addstr(dialog_y + 6, dialog_x + 2, f"{frame} Ğ”ÑƒĞ¼Ğ°Ñ...",
                                  ColorManager.get_pair("yellow"))
            except:
                pass
        elif self.ai_response:
            response_lines = self.ai_response.split('\n')
            for i, line in enumerate(response_lines[:dialog_height - 10]):
                try:
                    self.stdscr.addstr(dialog_y + 6 + i, dialog_x + 2, line[:dialog_width - 4])
                except:
                    pass
        
        # ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸
        hints = "Enter-Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ â”‚ S-Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ â”‚ E-Ğ¾Ğ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´ â”‚ F-Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ â”‚ ESC-Ğ²Ñ‹Ñ…Ğ¾Ğ´"
        try:
            self.stdscr.addstr(dialog_y + dialog_height - 2, dialog_x + 2, hints[:dialog_width - 4],
                              ColorManager.get_pair("cyan"))
        except:
            pass
        
        try:
            self.stdscr.move(dialog_y + 4, dialog_x + 10 + len(self.ai_input))
        except:
            pass
    
    def _render_file_explorer_dialog(self, height: int, width: int):
        """Ğ”Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸ĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
        dialog_width = min(70, width - 4)
        dialog_height = min(25, height - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = 2
        
        self._draw_dialog_box(dialog_y, dialog_x, dialog_height, dialog_width, 
                             f"ğŸ“‚ {self.file_explorer.root_path}")
        
        explorer = self.file_explorer
        visible_items = dialog_height - 5
        
        # ĞŸĞ¾Ğ´ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ¸
        if explorer.cursor < explorer.scroll:
            explorer.scroll = explorer.cursor
        elif explorer.cursor >= explorer.scroll + visible_items:
            explorer.scroll = explorer.cursor - visible_items + 1
        
        for i in range(visible_items):
            item_idx = explorer.scroll + i
            y = dialog_y + 2 + i
            
            if item_idx >= len(explorer.items):
                break
            
            item = explorer.items[item_idx]
            indent = "  " * item.level
            
            display = f"{indent}{item.icon} {item.name}"
            if len(display) > dialog_width - 6:
                display = display[:dialog_width - 9] + "..."
            
            if item_idx == explorer.cursor:
                attr = ColorManager.get_pair("black", "cyan", bold=True)
            elif item.selected:
                attr = ColorManager.get_pair("yellow", bold=True)
            elif item.is_dir:
                attr = ColorManager.get_pair("blue", bold=True)
            else:
                attr = ColorManager.get_pair("white")
            
            try:
                self.stdscr.addstr(y, dialog_x + 2, display.ljust(dialog_width - 4), attr)
            except:
                pass
        
        # ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸
        hints = "Enter-Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ â”‚ â†-Ğ½Ğ°Ğ·Ğ°Ğ´ â”‚ N-Ğ½Ğ¾Ğ²Ñ‹Ğ¹ â”‚ D-ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ â”‚ R-Ğ¿ĞµÑ€ĞµĞ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ñ‚ÑŒ â”‚ H-ÑĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ â”‚ ESC"
        try:
            self.stdscr.addstr(dialog_y + dialog_height - 2, dialog_x + 2, hints[:dialog_width - 4],
                              ColorManager.get_pair("cyan"))
        except:
            pass
    
    def _render_dialog(self, height: int, width: int):
        """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³"""
        dialog_width = min(50, width - 4)
        dialog_x = (width - dialog_width) // 2
        dialog_y = height // 3
        
        title = self.dialog_mode.replace("_", " ").title()
        self._draw_dialog_box(dialog_y, dialog_x, 5, dialog_width, title)
        
        try:
            self.stdscr.addstr(dialog_y + 2, dialog_x + 2, "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ: ")
            self.stdscr.addstr(dialog_y + 2, dialog_x + 11, self.dialog_input[:dialog_width - 14],
                              ColorManager.get_pair("white", bold=True))
            self.stdscr.move(dialog_y + 2, dialog_x + 11 + len(self.dialog_input))
        except:
            pass
    
    def _draw_dialog_box(self, y: int, x: int, height: int, width: int, title: str):
        """ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ¼ĞºÑƒ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ°"""
        border_attr = ColorManager.get_pair("cyan", bold=True)
        bg_attr = ColorManager.get_pair("white", "236")
        
        try:
            # Ğ’ĞµÑ€Ñ…Ğ½ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ñ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¾Ğ¼
            top_line = "â•”â•" + f" {title} ".center(width - 4, "â•") + "â•â•—"
            self.stdscr.addstr(y, x, top_line[:width], border_attr)
            
            # Ğ‘Ğ¾ĞºĞ¾Ğ²Ñ‹Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ Ğ¸ Ñ„Ğ¾Ğ½
            for row in range(1, height - 1):
                self.stdscr.addstr(y + row, x, "â•‘" + " " * (width - 2) + "â•‘", border_attr)
                # Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ñ„Ğ¾Ğ½
                self.stdscr.addstr(y + row, x + 1, " " * (width - 2), bg_attr)
            
            # ĞĞ¸Ğ¶Ğ½ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°
            bottom_line = "â•š" + "â•" * (width - 2) + "â•"
            self.stdscr.addstr(y + height - 1, x, bottom_line[:width], border_attr)
        except:
            pass


# ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ§Ğ°ÑÑ‚Ğ¸ 6...
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # âŒ¨ï¸ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ Ğ’Ğ’ĞĞ”Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def handle_input(self):
        """Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ğ²Ğ¾Ğ´Ğ°"""
        try:
            key = self.stdscr.getch()
        except:
            return
        
        if key == -1:
            # ĞĞµÑ‚ Ğ²Ğ²Ğ¾Ğ´Ğ° - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ°Ğ²Ñ‚Ğ¾ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
            self._check_autosave()
            return
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¼Ñ‹ÑˆĞ¸
        if key == curses.KEY_MOUSE:
            self._handle_mouse()
            return
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ°
        if self.mode == "normal":
            self._handle_normal_input(key)
        elif self.mode == "search":
            self._handle_search_input(key)
        elif self.mode == "replace":
            self._handle_replace_input(key)
        elif self.mode == "goto":
            self._handle_goto_input(key)
        elif self.mode == "command":
            self._handle_command_input(key)
        elif self.mode == "ai":
            self._handle_ai_input(key)
        elif self.mode == "terminal":
            self._handle_terminal_input(key)
        elif self.mode == "explorer":
            self._handle_explorer_input(key)
        elif self.dialog_mode:
            self._handle_dialog_input(key)
    
    def _handle_normal_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ² Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ"""
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if self.show_autocomplete:
            if key == curses.KEY_UP:
                self.autocomplete_index = max(0, self.autocomplete_index - 1)
                return
            elif key == curses.KEY_DOWN:
                self.autocomplete_index = min(len(self.autocomplete_items) - 1, 
                                              self.autocomplete_index + 1)
                return
            elif key in (10, 9, curses.KEY_ENTER):  # Enter Ğ¸Ğ»Ğ¸ Tab
                self._apply_autocomplete()
                return
            elif key == 27:  # Escape
                self.show_autocomplete = False
                return
            else:
                self.show_autocomplete = False
                # ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ¸ F1-F12
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if key == curses.KEY_F1:
            self._show_help()
            return
        elif key == curses.KEY_F2:
            self.zen_mode = not self.zen_mode
            self.show_message("ğŸ§˜ Ğ ĞµĞ¶Ğ¸Ğ¼ Zen " + ("Ğ²ĞºĞ»ÑÑ‡Ñ‘Ğ½" if self.zen_mode else "Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½"), "info")
            return
        elif key == curses.KEY_F3:
            if self.buffer and self.buffer.search_matches:
                self.buffer.find_next()
            return
        elif key == curses.KEY_F4:
            self._cycle_theme()
            return
        elif key == curses.KEY_F5:
            self._run_code()
            return
        elif key == curses.KEY_F6:
            self.show_sidebar = not self.show_sidebar
            if self.show_sidebar:
                # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ğ½Ğ° Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ°
                if self.buffer and self.buffer.filepath:
                    self.file_explorer.go_to(Path(self.buffer.filepath).parent)
            return
        elif key == curses.KEY_F7:
            self._run_linter()
            return
        elif key == curses.KEY_F8:
            self._show_lint_errors()
            return
        elif key == curses.KEY_F9:
            self._toggle_bookmark()
            return
        elif key == curses.KEY_F10:
            self.mode = "ai"
            self.ai_input = ""
            self.ai_response = ""
            return
        elif key == curses.KEY_F11:
            # ĞŸĞ¾Ğ»Ğ½Ğ¾ÑĞºÑ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼ (Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸)
            self.show_sidebar = False
            self.show_terminal = False
            self.show_minimap = False
            return
        elif key == curses.KEY_F12:
            self._goto_definition()
            return
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ctrl ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # Ctrl+A - Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘
        if key == 1:
            if self.buffer:
                self.buffer.select_all()
            return
        
        # Ctrl+B - Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ°
        if key == 2:
            self._toggle_bookmark()
            return
        
        # Ctrl+C - ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        if key == 3:
            self._copy()
            return
        
        # Ctrl+D - Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ / Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ½Ğ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ
        if key == 4:
            if self.buffer:
                if self.buffer.cursor.has_selection:
                    self.buffer.add_cursor_at_next_occurrence()
                    self.show_message(f"ğŸ‘† ĞšÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ²: {len(self.buffer.cursors)}", "info")
                else:
                    self.buffer.duplicate_line()
                    self.show_message("ğŸ“‹ Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°", "info")
            return
        
        # Ctrl+E - ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº (ĞºĞ°Ğº Ctrl+Shift+E Ğ² VS Code)
        if key == 5:
            self.mode = "explorer"
            return
        
        # Ctrl+F - ĞŸĞ¾Ğ¸ÑĞº
        if key == 6:
            self.mode = "search"
            self.search_input = ""
            return
        
        # Ctrl+G - ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ
        if key == 7:
            self.mode = "goto"
            self.search_input = ""
            return
        
        # Ctrl+H - ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¸ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ
        if key == 8:
            self.mode = "replace"
            self.search_input = ""
            self.replace_input = ""
            return
        
        # Ctrl+I - ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ / Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ (Ñ Shift)
        if key == 9:
            # Tab Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾
            pass
        
        # Ctrl+J - ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
        if key == 10:
            # Enter Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾
            pass
        
        # Ctrl+K - Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ ĞºĞ¾Ğ½Ñ†Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸ / Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ (Ctrl+Shift+K)
        if key == 11:
            if self.buffer:
                self.buffer.delete_line()
                self.show_message("ğŸ—‘ï¸ Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°", "info")
            return
        
        # Ctrl+L - Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
        if key == 12:
            if self.buffer:
                self.buffer.select_line()
            return
        
        # Ctrl+M - ĞœĞ¸Ğ½Ğ¸-ĞºĞ°Ñ€Ñ‚Ğ°
        if key == 13:
            # Enter - Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ°Ğº Ğ½Ğ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°
            pass
        
        # Ctrl+N - ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
        if key == 14:
            self.new_buffer()
            self.show_message("ğŸ“„ ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»", "success")
            return
        
        # Ctrl+O - ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»
        if key == 15:
            self.mode = "explorer"
            return
        
        # Ctrl+P - ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°
        if key == 16:
            self.mode = "command"
            self.command_input = ""
            return
        
        # Ctrl+Q - Ğ’Ñ‹Ğ¹Ñ‚Ğ¸
        if key == 17:
            self._quit()
            return
        
        # Ctrl+R - ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»
        if key == 18:
            self._reload_file()
            return
        
        # Ctrl+S - Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ
        if key == 19:
            self.save_file()
            return
        
        # Ctrl+T - ĞĞ¾Ğ²Ğ°Ñ Ğ²ĞºĞ»Ğ°Ğ´ĞºĞ°
        if key == 20:
            self.new_buffer()
            self.show_message("ğŸ“„ ĞĞ¾Ğ²Ğ°Ñ Ğ²ĞºĞ»Ğ°Ğ´ĞºĞ°", "success")
            return
        
        # Ctrl+U - ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ / Ğ’ĞµÑ€Ñ…Ğ½Ğ¸Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€
        if key == 21:
            if self.buffer and len(self.buffer.cursors) > 1:
                self.buffer.cursors.pop()
                self.show_message(f"ğŸ‘† ĞšÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ²: {len(self.buffer.cursors)}", "info")
            return
        
        # Ctrl+V - Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ
        if key == 22:
            self._paste()
            return
        
        # Ctrl+W - Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ĞºĞ»Ğ°Ğ´ĞºÑƒ
        if key == 23:
            self.close_buffer()
            return
        
        # Ctrl+X - Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ
        if key == 24:
            self._cut()
            return
        
        # Ctrl+Y - ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ
        if key == 25:
            if self.buffer and self.buffer.redo():
                self.show_message("â†ªï¸ ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ĞµĞ½Ğ¾", "info")
            return
        
        # Ctrl+Z - ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ
        if key == 26:
            if self.buffer and self.buffer.undo():
                self.show_message("â†©ï¸ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾", "info")
            return
        
        # Ctrl+/ - ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        if key == 31:
            if self.buffer:
                self.buffer.toggle_comment()
            return
        
        # Ctrl+] - Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿
        if key == 29:
            if self.buffer:
                self.buffer.indent_line()
            return
        
        # Ctrl+[ - Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿
        if key == 27:
            # Escape - Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ½Ğ¸Ğ¶Ğµ
            pass
        
        # Ctrl+` - Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»
        if key == 96:
            self.show_terminal = not self.show_terminal
            if self.show_terminal:
                self.mode = "terminal"
            return
        
        # Ctrl+Space - ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
        if key == 0:
            self._trigger_autocomplete()
            return
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Escape
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if key == 27:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Alt-ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
            self.stdscr.timeout(50)
            next_key = self.stdscr.getch()
            self.stdscr.timeout(100)
            
            if next_key == -1:
                # ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Escape
                self._handle_escape()
                return
            elif next_key == curses.KEY_UP:
                # Alt+Up - ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ²Ğ²ĞµÑ€Ñ…
                if self.buffer:
                    self.buffer.move_line_up()
                return
            elif next_key == curses.KEY_DOWN:
                # Alt+Down - ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ²Ğ½Ğ¸Ğ·
                if self.buffer:
                    self.buffer.move_line_down()
                return
            elif next_key == ord('w') or next_key == ord('W'):
                # Alt+W - Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ĞºĞ»Ğ°Ğ´ĞºÑƒ
                self.close_buffer()
                return
            elif next_key == ord('1'):
                self.switch_buffer(0)
                return
            elif next_key == ord('2'):
                self.switch_buffer(1)
                return
            elif next_key == ord('3'):
                self.switch_buffer(2)
                return
            # ... Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Alt-ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¹
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if key == curses.KEY_UP:
            self._move_cursor_up()
            return
        elif key == curses.KEY_DOWN:
            self._move_cursor_down()
            return
        elif key == curses.KEY_LEFT:
            self._move_cursor_left()
            return
        elif key == curses.KEY_RIGHT:
            self._move_cursor_right()
            return
        elif key == curses.KEY_HOME:
            self._move_cursor_home()
            return
        elif key == curses.KEY_END:
            self._move_cursor_end()
            return
        elif key == curses.KEY_PPAGE:  # Page Up
            self._move_page_up()
            return
        elif key == curses.KEY_NPAGE:  # Page Down
            self._move_page_down()
            return
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.buffer:
                self.buffer.delete_char_backward()
            return
        
        if key == curses.KEY_DC:  # Delete
            if self.buffer:
                self.buffer.delete_char_forward()
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            if self.buffer:
                self.buffer.insert_newline()
            return
        
        if key == 9:  # Tab
            self._handle_tab()
            return
        
        if key == curses.KEY_BTAB:  # Shift+Tab
            if self.buffer:
                self.buffer.unindent_line()
            return
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²ĞºĞ»Ğ°Ğ´Ğ¾Ğº
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # Ctrl+Tab Ğ¸Ğ»Ğ¸ Ctrl+PageDown - ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ Ğ²ĞºĞ»Ğ°Ğ´ĞºĞ°
        if key == curses.KEY_SNEXT or key == 353:
            self.next_buffer()
            return
        
        # Ctrl+Shift+Tab Ğ¸Ğ»Ğ¸ Ctrl+PageUp - Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ°Ñ Ğ²ĞºĞ»Ğ°Ğ´ĞºĞ°
        if key == curses.KEY_SPREVIOUS or key == 393:
            self.prev_buffer()
            return
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ĞŸĞµÑ‡Ğ°Ñ‚Ğ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if 32 <= key <= 126:
            char = chr(key)
            if self.buffer:
                self.buffer.insert_char(char)
                self._handle_auto_pairs(char)
                self._maybe_show_autocomplete()
            return
        
        # Unicode ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ (ĞºĞ¸Ñ€Ğ¸Ğ»Ğ»Ğ¸Ñ†Ğ° Ğ¸ Ñ‚.Ğ´.)
        if key > 127:
            try:
                char = chr(key)
                if self.buffer:
                    self.buffer.insert_char(char)
            except:
                pass
            return
    
    def _handle_search_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            self._perform_search()
            return
        
        if key == curses.KEY_F2:
            self.search_case_sensitive = not self.search_case_sensitive
            self._perform_search()
            return
        
        if key == curses.KEY_F3:
            self.search_whole_word = not self.search_whole_word
            self._perform_search()
            return
        
        if key == curses.KEY_F4:
            self.search_regex = not self.search_regex
            self._perform_search()
            return
        
        if key == curses.KEY_DOWN:
            if self.buffer:
                self.buffer.find_next()
            return
        
        if key == curses.KEY_UP:
            if self.buffer:
                self.buffer.find_prev()
            return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.search_input:
                self.search_input = self.search_input[:-1]
                self._perform_search()
            return
        
        if 32 <= key <= 126:
            self.search_input += chr(key)
            self._perform_search()
            return
    
    def _handle_replace_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ·Ğ°Ğ¼ĞµĞ½Ñ‹"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter - Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ
            if self.buffer:
                self.buffer.replace(self.replace_input)
                self.show_message("ğŸ”„ Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½Ğ¾", "success")
            return
        
        if key == 1:  # Ctrl+A - Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘
            if self.buffer:
                count = self.buffer.replace_all(self.replace_input)
                self.show_message(f"ğŸ”„ Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½Ğ¾: {count}", "success")
                self.mode = "normal"
            return
        
        if key == 9:  # Tab - Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğµ
            # ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ - Ğ¿Ğ¾Ğ»Ñ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ°ÑÑ‚ÑÑ
            pass
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.replace_input:
                self.replace_input = self.replace_input[:-1]
            elif self.search_input:
                self.search_input = self.search_input[:-1]
            return
        
        if 32 <= key <= 126:
            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² replace_input (ÑƒĞ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ¾)
            self.replace_input += chr(key)
            return
    
    def _handle_goto_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ° Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            try:
                line_num = int(self.search_input) - 1
                if self.buffer and 0 <= line_num < len(self.buffer.lines):
                    self.buffer.cursor_line = line_num
                    self.buffer.cursor_col = 0
                    self.show_message(f"ğŸ“ Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° {line_num + 1}", "success")
                else:
                    self.show_message("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€ ÑÑ‚Ñ€Ğ¾ĞºĞ¸", "error")
            except ValueError:
                self.show_message("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾", "error")
            self.mode = "normal"
            return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.search_input:
                self.search_input = self.search_input[:-1]
            return
        
        if 48 <= key <= 57:  # Ğ¦Ğ¸Ñ„Ñ€Ñ‹
            self.search_input += chr(key)
            return
    
    def _handle_command_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ñ‹"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            self._execute_command(self.command_input)
            self.mode = "normal"
            return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.command_input:
                self.command_input = self.command_input[:-1]
            return
        
        if 32 <= key <= 126:
            self.command_input += chr(key)
            return
    
    def _handle_ai_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° AI Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ°"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            if self.ai_input.strip():
                self._query_ai(self.ai_input)
            return
        
        if key == ord('s') or key == ord('S'):
            if not self.ai_input:  # S Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ğ²Ğ²Ğ¾Ğ´
                self._setup_ai()
                return
        
        if key == ord('e') or key == ord('E'):
            if not self.ai_input:  # E Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ°
                self._ai_explain_code()
                return
        
        if key == ord('f') or key == ord('F'):
            if not self.ai_input:  # F Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
                self._ai_find_bugs()
                return
        
        if key == ord('o') or key == ord('O'):
            if not self.ai_input:  # O Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
                self._ai_optimize_code()
                return
        
        if key == ord('d') or key == ord('D'):
            if not self.ai_input:  # D Ğ´Ğ»Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ğ¸
                self._ai_generate_docs()
                return
        
        if key == ord('t') or key == ord('T'):
            if not self.ai_input:  # T Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
                self._ai_generate_tests()
                return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.ai_input:
                self.ai_input = self.ai_input[:-1]
            return
        
        if 32 <= key <= 126:
            self.ai_input += chr(key)
            return
    
    def _handle_terminal_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°"""
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            if self.command_input.strip():
                output, code = self.terminal.execute(self.command_input)
                self.terminal.add_output(f"{self.terminal.get_prompt()}{self.command_input}")
                if output:
                    self.terminal.add_output(output)
                self.command_input = ""
            return
        
        if key == curses.KEY_UP:
            self.command_input = self.terminal.previous_command()
            return
        
        if key == curses.KEY_DOWN:
            self.command_input = self.terminal.next_command()
            return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.command_input:
                self.command_input = self.command_input[:-1]
            return
        
        if 32 <= key <= 126:
            self.command_input += chr(key)
            return
    
    def _handle_explorer_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸ĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²"""
        explorer = self.file_explorer
        
        if key == 27:  # Escape
            self.mode = "normal"
            return
        
        if key == curses.KEY_UP:
            explorer.move_up()
            return
        
        if key == curses.KEY_DOWN:
            explorer.move_down()
            return
        
        if key == curses.KEY_LEFT:
            # Ğ¡Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¿Ğ°Ğ¿ĞºÑƒ Ğ¸Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ñ€Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            item = explorer.current_item
            if item and item.is_dir and item.expanded:
                item.expanded = False
                explorer.refresh()
            else:
                explorer.go_up()
            return
        
        if key == curses.KEY_RIGHT:
            # Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¿Ğ°Ğ¿ĞºÑƒ
            item = explorer.current_item
            if item and item.is_dir:
                item.expanded = True
                explorer.refresh()
            return
        
        if key == 10 or key == curses.KEY_ENTER:
            path = explorer.enter()
            if path:
                self.open_file(str(path))
                self.mode = "normal"
            return
        
        if key == ord('h') or key == ord('H'):
            explorer.toggle_hidden()
            self.show_message(f"Ğ¡ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹: {'Ğ²ĞºĞ»' if explorer.show_hidden else 'Ğ²Ñ‹ĞºĞ»'}", "info")
            return
        
        if key == ord('n') or key == ord('N'):
            self.dialog_mode = "new_file"
            self.dialog_input = ""
            return
        
        if key == ord('d') or key == ord('D'):
            success, msg = explorer.delete()
            self.show_message(f"{'âœ…' if success else 'âŒ'} {msg}", 
                            "success" if success else "error")
            return
        
        if key == ord('r') or key == ord('R'):
            if explorer.current_item:
                self.dialog_mode = "rename"
                self.dialog_input = explorer.current_item.name
            return
        
        if key == ord('c') or key == ord('C'):
            explorer.copy()
            self.show_message(f"ğŸ“‹ Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾: {len(explorer.clipboard)}", "info")
            return
        
        if key == ord('x') or key == ord('X'):
            explorer.cut()
            self.show_message(f"âœ‚ï¸ Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ğ½Ğ¾: {len(explorer.clipboard)}", "info")
            return
        
        if key == ord('v') or key == ord('V'):
            success, msg = explorer.paste()
            self.show_message(f"{'âœ…' if success else 'âŒ'} {msg}", 
                            "success" if success else "error")
            return
        
        if key == ord(' '):  # Space - Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ
            explorer.toggle_select()
            explorer.move_down()
            return
        
        if key == curses.KEY_BACKSPACE or key == 127:
            explorer.go_up()
            return
    
    def _handle_dialog_input(self, key: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ°"""
        if key == 27:  # Escape
            self.dialog_mode = ""
            return
        
        if key == 10 or key == curses.KEY_ENTER:  # Enter
            self._process_dialog()
            return
        
        if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
            if self.dialog_input:
                self.dialog_input = self.dialog_input[:-1]
            return
        
        if 32 <= key <= 126:
            self.dialog_input += chr(key)
            return
    
    def _handle_mouse(self):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¼Ñ‹ÑˆĞ¸"""
        try:
            _, mx, my, _, bstate = curses.getmouse()
            
            # ĞšĞ»Ğ¸Ğº - Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€
            if bstate & curses.BUTTON1_CLICKED:
                self._mouse_click(mx, my)
            
            # Ğ”Ğ²Ğ¾Ğ¹Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ¸Ğº - Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ğ²Ğ¾
            elif bstate & curses.BUTTON1_DOUBLE_CLICKED:
                self._mouse_double_click(mx, my)
            
            # ĞšĞ¾Ğ»ĞµÑĞ¾ Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ¸
            elif bstate & curses.BUTTON4_PRESSED:  # Scroll up
                if self.buffer:
                    self.buffer.scroll_y = max(0, self.buffer.scroll_y - 3)
            elif bstate & curses.BUTTON5_PRESSED:  # Scroll down
                if self.buffer:
                    self.buffer.scroll_y = min(len(self.buffer.lines) - 1, 
                                               self.buffer.scroll_y + 3)
        except:
            pass
    
    def _mouse_click(self, mx: int, my: int):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ»Ğ¸ĞºĞ° Ğ¼Ñ‹ÑˆĞ¸"""
        if not self.buffer:
            return
        
        # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² Ñ‚ĞµĞºÑÑ‚Ğµ
        header_height = 1
        sidebar_w = self.sidebar_width if self.show_sidebar else 0
        line_num_width = len(str(self.buffer.total_lines)) + 2
        
        text_x = mx - sidebar_w - line_num_width
        text_y = my - header_height
        
        if text_x >= 0 and text_y >= 0:
            line = self.buffer.scroll_y + text_y
            col = self.buffer.scroll_x + text_x
            
            if line < len(self.buffer.lines):
                self.buffer.cursor_line = line
                self.buffer.cursor_col = min(col, len(self.buffer.lines[line]))
    
    def _mouse_double_click(self, mx: int, my: int):
        """Ğ”Ğ²Ğ¾Ğ¹Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ¸Ğº - Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ğ²Ğ¾"""
        self._mouse_click(mx, my)
        if self.buffer:
            self.buffer.select_word()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”§ ĞšĞĞœĞĞĞ”Ğ« Ğ˜ Ğ”Ğ•Ğ™Ğ¡Ğ¢Ğ’Ğ˜Ğ¯
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _handle_escape(self):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Escape"""
        if self.buffer:
            # ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ
            self.buffer.cursor.clear_selection()
            # ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€Ñ‹
            if len(self.buffer.cursors) > 1:
                self.buffer.clear_extra_cursors()
        
        self.show_autocomplete = False
        self.mode = "normal"
        
        if self.zen_mode:
            self.zen_mode = False
    
    def _handle_tab(self):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Tab"""
        if not self.buffer:
            return
        
        # ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚
        line = self.buffer.lines[self.buffer.cursor_line]
        before_cursor = line[:self.buffer.cursor_col]
        
        # Ğ˜Ñ‰ĞµĞ¼ ÑĞ»Ğ¾Ğ²Ğ¾ Ğ¿ĞµÑ€ĞµĞ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼
        match = re.search(r'(\w+)$', before_cursor)
        if match:
            word = match.group(1)
            lang_config = LANGUAGES.get(self.buffer.language, {})
            snippets = lang_config.get("snippets", {})
            
            if word in snippets:
                self._expand_snippet(word, snippets[word])
                return
        
        # Ğ•ÑĞ»Ğ¸ Ğ½Ğµ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚ - Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Tab
        if self.config.get("use_spaces", True):
            self.buffer.insert_char(" " * self.config.get("tab_size", 4))
        else:
            self.buffer.insert_char("\t")
    
    def _expand_snippet(self, trigger: str, template: str):
        """Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚"""
        if not self.buffer:
            return
        
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ñ‚Ñ€Ğ¸Ğ³Ğ³ĞµÑ€
        line = self.buffer.lines[self.buffer.cursor_line]
        start = self.buffer.cursor_col - len(trigger)
        
        self.buffer.lines[self.buffer.cursor_line] = line[:start] + line[self.buffer.cursor_col:]
        self.buffer.cursor_col = start
        
        # Ğ Ğ°Ğ·Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚
        expanded = self.autocomplete.expand_snippet(template, self.buffer)
        self.buffer.insert_text(expanded)
        
        self.show_message(f"ğŸ“ Ğ¡Ğ½Ğ¸Ğ¿Ğ¿ĞµÑ‚: {trigger}", "success")
    
    def _handle_auto_pairs(self, char: str):
        """ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ ÑĞºĞ¾Ğ±Ğ¾Ğº"""
        if not self.buffer or not self.config.get("auto_pairs", True):
            return
        
        lang_config = LANGUAGES.get(self.buffer.language, {})
        auto_pairs = lang_config.get("auto_pairs", {})
        
        if char in auto_pairs:
            closing = auto_pairs[char]
            line = self.buffer.lines[self.buffer.cursor_line]
            
            # ĞĞµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞµÑĞ»Ğ¸ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¶Ğµ
            if self.buffer.cursor_col < len(line) and line[self.buffer.cursor_col] == closing:
                return
            
            # Ğ”Ğ»Ñ ĞºĞ°Ğ²Ñ‹Ñ‡ĞµĞº - Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞµÑĞ»Ğ¸ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ ÑĞ»Ğ¾Ğ²Ğ°
            if char in '"\'`':
                if self.buffer.cursor_col > 1:
                    prev_char = line[self.buffer.cursor_col - 2]
                    if prev_char.isalnum():
                        return
            
            self.buffer.insert_char(closing)
            self.buffer.cursor_col -= 1
    
    def _trigger_autocomplete(self):
        """Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ"""
        if not self.buffer:
            return
        
        self.autocomplete_items = self.autocomplete.get_completions(
            self.buffer,
            trigger_char=None
        )
        
        if self.autocomplete_items:
            self.show_autocomplete = True
            self.autocomplete_index = 0
        else:
            self.show_message("ĞĞµÑ‚ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹", "info")
    
    def _maybe_show_autocomplete(self):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾"""
        if not self.buffer or not self.autocomplete.enabled:
            return
        
        self.autocomplete_items = self.autocomplete.get_completions(self.buffer)
        
        if self.autocomplete_items:
            self.show_autocomplete = True
            self.autocomplete_index = 0
        else:
            self.show_autocomplete = False
    
    def _apply_autocomplete(self):
        """ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ"""
        if not self.autocomplete_items or not self.buffer:
            return
        
        item = self.autocomplete_items[self.autocomplete_index]
        line = self.buffer.lines[self.buffer.cursor_line]
        
        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°
        col = self.buffer.cursor_col
        start = col
        while start > 0 and (line[start - 1].isalnum() or line[start - 1] == '_'):
            start -= 1
        
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ»Ğ¾Ğ²Ğ¾ Ğ¸ Ğ²ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ
        self.buffer.lines[self.buffer.cursor_line] = line[:start] + item.insert_text + line[col:]
        self.buffer.cursor_col = start + len(item.insert_text)
        self.buffer.modified = True
        
        # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚ - Ñ€Ğ°Ğ·Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼
        if item.kind == "snippet" and "${" in item.insert_text:
            # Ğ Ğ°Ğ·Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ»ĞµĞ¹ÑÑ…Ğ¾Ğ»Ğ´ĞµÑ€Ñ‹
            pass
        
        self.show_autocomplete = False
        self.autocomplete_items = []
    
    def _perform_search(self):
        """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº"""
        if self.buffer and self.search_input:
            self.buffer.find(
                self.search_input,
                case_sensitive=self.search_case_sensitive,
                whole_word=self.search_whole_word,
                regex=self.search_regex
            )
    
    def _execute_command(self, command: str):
        """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ Ğ¸Ğ· Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ñ‹"""
        cmd = command.lower().strip()
        
        commands = {
            "save": lambda: self.save_file(),
            "save-as": lambda: self.show_input_dialog("Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº:", self._save_file_callback),
            "open": lambda: setattr(self, 'mode', 'explorer'),
            "new": lambda: self.new_buffer(),
            "close": lambda: self.close_buffer(),
            "quit": lambda: self._quit(),
            "find": lambda: setattr(self, 'mode', 'search'),
            "replace": lambda: setattr(self, 'mode', 'replace'),
            "goto": lambda: setattr(self, 'mode', 'goto'),
            "run": lambda: self._run_code(),
            "terminal": lambda: self._toggle_terminal(),
            "explorer": lambda: setattr(self, 'show_sidebar', not self.show_sidebar),
            "ai": lambda: setattr(self, 'mode', 'ai'),
            "theme": lambda: self._cycle_theme(),
            "zen": lambda: setattr(self, 'zen_mode', not self.zen_mode),
            "git-status": lambda: self._show_git_status(),
            "git-commit": lambda: self._git_commit(),
            "format": lambda: self._format_code(),
            "comment": lambda: self.buffer.toggle_comment() if self.buffer else None,
            "duplicate": lambda: self.buffer.duplicate_line() if self.buffer else None,
            "delete-line": lambda: self.buffer.delete_line() if self.buffer else None,
            "select-all": lambda: self.buffer.select_all() if self.buffer else None,
            "undo": lambda: self.buffer.undo() if self.buffer else None,
            "redo": lambda: self.buffer.redo() if self.buffer else None,
            "bookmark": lambda: self._toggle_bookmark(),
            "minimap": lambda: setattr(self, 'show_minimap', not self.show_minimap),
            "reload": lambda: self._reload_file(),
            "settings": lambda: self._open_settings(),
        }
        
        if cmd in commands:
            commands[cmd]()
        else:
            self.show_message(f"âŒ ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°: {cmd}", "error")
    
    def _process_dialog(self):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³"""
        if self.dialog_mode == "new_file":
            if self.dialog_input:
                success, msg = self.file_explorer.create_file(self.dialog_input)
                self.show_message(f"{'âœ…' if success else 'âŒ'} {msg}",
                                "success" if success else "error")
        
        elif self.dialog_mode == "new_folder":
            if self.dialog_input:
                success, msg = self.file_explorer.create_directory(self.dialog_input)
                self.show_message(f"{'âœ…' if success else 'âŒ'} {msg}",
                                "success" if success else "error")
        
        elif self.dialog_mode == "rename":
            if self.dialog_input:
                success, msg = self.file_explorer.rename(self.dialog_input)
                self.show_message(f"{'âœ…' if success else 'âŒ'} {msg}",
                                "success" if success else "error")
        
        elif self.dialog_mode == "save_as":
            if self.dialog_input:
                self.save_file(self.dialog_input)
        
        self.dialog_mode = ""
        self.dialog_input = ""
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“ ĞĞĞ’Ğ˜Ğ“ĞĞ¦Ğ˜Ğ¯
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _move_cursor_up(self):
        if not self.buffer:
            return
        if self.buffer.cursor_line > 0:
            self.buffer.cursor_line -= 1
            # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ preferred_col
            self.buffer.cursor_col = min(self.buffer.cursor.preferred_col, 
                                        len(self.buffer.lines[self.buffer.cursor_line]))
    
    def _move_cursor_down(self):
        if not self.buffer:
            return
        if self.buffer.cursor_line < len(self.buffer.lines) - 1:
            self.buffer.cursor_line += 1
            self.buffer.cursor_col = min(self.buffer.cursor.preferred_col,
                                        len(self.buffer.lines[self.buffer.cursor_line]))
    
    def _move_cursor_left(self):
        if not self.buffer:
            return
        if self.buffer.cursor_col > 0:
            self.buffer.cursor_col -= 1
        elif self.buffer.cursor_line > 0:
            self.buffer.cursor_line -= 1
            self.buffer.cursor_col = len(self.buffer.lines[self.buffer.cursor_line])
    
    def _move_cursor_right(self):
        if not self.buffer:
            return
        line_len = len(self.buffer.lines[self.buffer.cursor_line])
        if self.buffer.cursor_col < line_len:
            self.buffer.cursor_col += 1
        elif self.buffer.cursor_line < len(self.buffer.lines) - 1:
            self.buffer.cursor_line += 1
            self.buffer.cursor_col = 0
    
    def _move_cursor_home(self):
        if not self.buffer:
            return
        line = self.buffer.lines[self.buffer.cursor_line]
        first_non_space = len(line) - len(line.lstrip())
        
        if self.buffer.cursor_col == first_non_space:
            self.buffer.cursor_col = 0
        else:
            self.buffer.cursor_col = first_non_space
    
    def _move_cursor_end(self):
        if not self.buffer:
            return
        self.buffer.cursor_col = len(self.buffer.lines[self.buffer.cursor_line])
    
    def _move_page_up(self):
        if not self.buffer:
            return
        height = self.stdscr.getmaxyx()[0] - 4
        self.buffer.cursor_line = max(0, self.buffer.cursor_line - height)
        self.buffer.cursor_col = min(self.buffer.cursor_col, 
                                    len(self.buffer.lines[self.buffer.cursor_line]))
    
    def _move_page_down(self):
        if not self.buffer:
            return
        height = self.stdscr.getmaxyx()[0] - 4
        self.buffer.cursor_line = min(len(self.buffer.lines) - 1, 
                                     self.buffer.cursor_line + height)
        self.buffer.cursor_col = min(self.buffer.cursor_col,
                                    len(self.buffer.lines[self.buffer.cursor_line]))
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“‹ Ğ‘Ğ£Ğ¤Ğ•Ğ  ĞĞ‘ĞœĞ•ĞĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _copy(self):
        if not self.buffer:
            return
        
        if self.buffer.cursor.has_selection:
            self.clipboard = self.buffer.get_selection_text()
        else:
            # ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
            self.clipboard = self.buffer.lines[self.buffer.cursor_line] + "\n"
        
        if self.clipboard:
            self.clipboard_history.insert(0, self.clipboard)
            self.clipboard_history = self.clipboard_history[:20]
            self.show_message("ğŸ“‹ Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾", "success")
    
    def _cut(self):
        if not self.buffer:
            return
        
        self._copy()
        
        if self.buffer.cursor.has_selection:
            self.buffer.delete_selection()
        else:
            self.buffer.delete_line()
        
        self.show_message("âœ‚ï¸ Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ğ½Ğ¾", "success")
    
    def _paste(self):
        if not self.buffer or not self.clipboard:
            return
        
        self.buffer.insert_text(self.clipboard)
        self.show_message("ğŸ“‹ Ğ’ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾", "success")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”§ Ğ£Ğ¢Ğ˜Ğ›Ğ˜Ğ¢Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _toggle_bookmark(self):
        if self.buffer:
            added = self.buffer.toggle_bookmark()
            self.show_message(f"ğŸ”– Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ° {'Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°' if added else 'ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°'}", "info")
    
    def _cycle_theme(self):
        """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞ¼Ñƒ"""
        themes = list(THEMES.keys())
        current_idx = themes.index(self.theme_name) if self.theme_name in themes else 0
        next_idx = (current_idx + 1) % len(themes)
        
        self.theme_name = themes[next_idx]
        self.theme = THEMES[self.theme_name]
        self.config.set("theme", self.theme_name)
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ highlighter
        if self.buffer:
            self.buffer.highlighter.set_theme(self.theme_name)
        
        self.show_message(f"ğŸ¨ Ğ¢ĞµĞ¼Ğ°: {self.theme.get('name', self.theme_name)}", "success")
    
    def _toggle_terminal(self):
        self.show_terminal = not self.show_terminal
        if self.show_terminal:
            self.mode = "terminal"
            self.command_input = ""
    
    def _reload_file(self):
        if self.buffer and self.buffer.filepath:
            success, msg = self.buffer.load_file(self.buffer.filepath)
            self.show_message(f"{'ğŸ”„' if success else 'âŒ'} {msg}",
                            "success" if success else "error")
    
    def _quit(self):
        """Ğ’Ñ‹Ñ…Ğ¾Ğ´ Ğ¸Ğ· Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğ°"""
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½ĞµÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
        unsaved = [b for b in self.buffers if b.modified]
        
        if unsaved:
            self.show_message(f"âš ï¸ {len(unsaved)} Ñ„Ğ°Ğ¹Ğ»(Ğ¾Ğ²) Ğ½Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾! Ctrl+S Ğ¸Ğ»Ğ¸ Ctrl+Q ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·", "warning")
            # Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼ Ñ„Ğ»Ğ°Ğ³ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ°
            if hasattr(self, '_quit_confirmed') and self._quit_confirmed:
                self.running = False
            else:
                self._quit_confirmed = True
        else:
            self.running = False
    
    def _check_autosave(self):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ"""
        if not self.config.get("auto_save", True):
            return
        
        interval = self.config.get("auto_save_interval", 60)
        
        if time.time() - self.last_autosave > interval:
            for buf in self.buffers:
                if buf.modified and buf.filepath:
                    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ backup
                    backup_dir = Config.BACKUPS_DIR
                    backup_name = f"{Path(buf.filepath).name}.{int(time.time())}.autosave"
                    backup_path = backup_dir / backup_name
                    
                    try:
                        with open(backup_path, 'w', encoding=buf.encoding) as f:
                            f.write('\n'.join(buf.lines))
                    except:
                        pass
            
            self.last_autosave = time.time()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸš€ Ğ—ĞĞŸĞ£Ğ¡Ğš ĞšĞĞ”Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _run_code(self):
        """Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        if not self.buffer:
            self.show_message("âŒ ĞĞµÑ‚ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°", "error")
            return
        
        if not self.buffer.filepath:
            self.show_message("âš ï¸ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ»", "warning")
            return
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ¾Ğ¼
        if self.buffer.modified:
            self.save_file()
        
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾
        curses.endwin()
        
        success, error = self.code_runner.run_interactive(
            self.buffer.filepath,
            self.buffer.language
        )
        
        # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ curses
        self.stdscr = curses.initscr()
        self._init_curses()
        
        if not success:
            self.show_message(f"âŒ {error}", "error")
    
    def _run_linter(self):
        """Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ½Ñ‚ĞµÑ€"""
        if not self.buffer:
            return
        
        errors = self.linter.lint(self.buffer)
        
        if errors:
            self.show_message(f"âš ï¸ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {len(errors)} Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼ (F8 - Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€)", "warning")
        else:
            self.show_message("âœ… ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾", "success")
    
    def _show_lint_errors(self):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ»Ğ¸Ğ½Ñ‚ĞµÑ€Ğ°"""
        if not self.linter.messages:
            self.show_message("âœ… ĞÑˆĞ¸Ğ±Ğ¾Ğº Ğ½ĞµÑ‚", "success")
            return
        
        curses.endwin()
        
        print("\n" + "=" * 60)
        print("âš ï¸ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ« ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ˜")
        print("=" * 60)
        
        for msg in self.linter.messages[:30]:
            print(f"\n{msg.icon} Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° {msg.line + 1}:{msg.col + 1}")
            print(f"   {msg.message}")
            if msg.code:
                print(f"   ĞšĞ¾Ğ´: {msg.code}")
        
        if len(self.linter.messages) > 30:
            print(f"\n... Ğ¸ ĞµÑ‰Ñ‘ {len(self.linter.messages) - 30} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹")
        
        print("\n" + "=" * 60)
        input("ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter...")
        
        self.stdscr = curses.initscr()
        self._init_curses()
    
    def _format_code(self):
        """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        if not self.buffer:
            return
        
        formatted = self.smart_bot.format_code(
            '\n'.join(self.buffer.lines),
            self.buffer.language
        )
        
        self.buffer.lines = formatted.split('\n')
        self.buffer.modified = True
        self.show_message("âœ¨ ĞšĞ¾Ğ´ Ğ¾Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½", "success")
    
    def _goto_definition(self):
        """ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ (Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°)"""
        self.show_message("ğŸ” ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğº Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ (Ğ² Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ)", "info")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŒ¿ GIT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _show_git_status(self):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Git"""
        if not self.git.available:
            self.show_message("âŒ Git Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½", "error")
            return
        
        path = str(Path(self.buffer.filepath).parent) if self.buffer and self.buffer.filepath else os.getcwd()
        
        curses.endwin()
        
        status = self.git.get_status(path)
        
        print("\n" + "=" * 60)
        print("ğŸŒ¿ GIT Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡")
        print("=" * 60)
        
        if "error" in status:
            print(f"\nâŒ {status['error']}")
        else:
            print(f"\nğŸŒ¿ Ğ’ĞµÑ‚ĞºĞ°: {status['branch']}")
            print(f"ğŸ“Š Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾: {status['modified']}, Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {status['added']}, Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾: {status['deleted']}")
            
            if status['files']:
                print("\nĞ¤Ğ°Ğ¹Ğ»Ñ‹:")
                for f in status['files'][:20]:
                    icons = {"modified": "âœï¸", "added": "â•", "deleted": "â–", "untracked": "â“"}
                    icon = icons.get(f['status'], "â€¢")
                    print(f"  {icon} {f['status_code']} {f['filename']}")
        
        print("\n" + "=" * 60)
        input("ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter...")
        
        self.stdscr = curses.initscr()
        self._init_curses()
    
    def _git_commit(self):
        """Git commit"""
        if not self.git.available:
            self.show_message("âŒ Git Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½", "error")
            return
        
        path = str(Path(self.buffer.filepath).parent) if self.buffer and self.buffer.filepath else os.getcwd()
        
        curses.endwin()
        
        message = input("Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ°: ").strip()
        
        if message:
            self.git.stage(path)
            success, result = self.git.commit(path, message)
            print(f"\n{'âœ…' if success else 'âŒ'} {result}")
        else:
            print("âŒ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼")
        
        input("\nĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter...")
        
        self.stdscr = curses.initscr()
        self._init_curses()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¤– AI
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _query_ai(self, prompt: str):
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº AI"""
        if not self.ai_manager.config.is_configured():
            self.show_message("âŒ AI Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'S' Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸", "error")
            return
        
        self.ai_loading = True
        self.ai_response = ""
        self.render()
        
        context = '\n'.join(self.buffer.lines) if self.buffer else ""
        
        success, response = self.ai_manager.query(prompt, context)
        
        self.ai_loading = False
        
        if success:
            self.ai_response = response
        else:
            self.ai_response = f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {response}"
    
    def _setup_ai(self):
        """ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° AI"""
        curses.endwin()
        
        print("\n" + "=" * 60)
        print("ğŸ¤– ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ AI")
        print("=" * 60)
        
        providers = list(AIConfig.PROVIDERS.items())
        
        print("\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ°:\n")
        for i, (key, info) in enumerate(providers, 1):
            print(f"  [{i}] {info['icon']} {info['name']}")
        print(f"  [0] ĞÑ‚Ğ¼ĞµĞ½Ğ°")
        
        try:
            choice = input("\nĞ’Ñ‹Ğ±Ğ¾Ñ€: ").strip()
            idx = int(choice) - 1
            
            if 0 <= idx < len(providers):
                provider_key, provider_info = providers[idx]
                
                print(f"\n{provider_info['icon']} {provider_info['name']}")
                print("-" * 40)
                
                if provider_key == "ollama":
                    print("Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ Ñ‡Ñ‚Ğ¾ Ollama Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°: ollama serve")
                    api_key = ""
                else:
                    print(f"Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ ĞºĞ»ÑÑ‡Ğ°: {provider_info['key_hint']}")
                    api_key = input("API ĞºĞ»ÑÑ‡: ").strip()
                
                print(f"\nĞœĞ¾Ğ´ĞµĞ»Ğ¸: {', '.join(provider_info['models'])}")
                model = input(f"ĞœĞ¾Ğ´ĞµĞ»ÑŒ [{provider_info['default_model']}]: ").strip()
                model = model or provider_info['default_model']
                
                self.ai_manager.config.set_provider(provider_key, api_key, model)
                self.ai_manager.reload_provider()
                
                print("\nâœ… ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹!")
                
                # Ğ¢ĞµÑÑ‚
                print("ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑÑ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ...")
                provider = self.ai_manager.provider
                if provider:
                    success, msg = provider.test_connection()
                    print(f"{'âœ…' if success else 'âŒ'} {msg}")
                
        except (ValueError, IndexError):
            print("ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
        
        input("\nĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter...")
        
        self.stdscr = curses.initscr()
        self._init_curses()
    
    def _ai_explain_code(self):
        """AI: Ğ¾Ğ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        if not self.buffer:
            return
        
        code = self.buffer.get_selection_text() if self.buffer.cursor.has_selection else '\n'.join(self.buffer.lines)
        
        self.ai_input = ""
        self.ai_loading = True
        self.render()
        
        success, response = self.ai_manager.explain_code(code)
        
        self.ai_loading = False
        self.ai_response = response if success else f"âŒ {response}"
    
    def _ai_find_bugs(self):
        """AI: Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸"""
        if not self.buffer:
            return
        
        self.ai_input = ""
        self.ai_loading = True
        self.render()
        
        code = '\n'.join(self.buffer.lines)
        success, response = self.ai_manager.find_bugs(code)
        
        self.ai_loading = False
        self.ai_response = response if success else f"âŒ {response}"
    
    def _ai_optimize_code(self):
        """AI: Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ´"""
        if not self.buffer:
            return
        
        self.ai_input = ""
        self.ai_loading = True
        self.render()
        
        code = '\n'.join(self.buffer.lines)
        success, response = self.ai_manager.optimize_code(code)
        
        self.ai_loading = False
        
        if success:
            # ĞŸÑ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
            self.ai_response = response + "\n\n[Enter - Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ]"
        else:
            self.ai_response = f"âŒ {response}"
    
    def _ai_generate_docs(self):
        """AI: ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ"""
        if not self.buffer:
            return
        
        self.ai_input = ""
        self.ai_loading = True
        self.render()
        
        code = '\n'.join(self.buffer.lines)
        success, response = self.ai_manager.generate_docs(code)
        
        self.ai_loading = False
        self.ai_response = response if success else f"âŒ {response}"
    
    def _ai_generate_tests(self):
        """AI: ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµÑÑ‚Ñ‹"""
        if not self.buffer:
            return
        
        self.ai_input = ""
        self.ai_loading = True
        self.render()
        
        code = '\n'.join(self.buffer.lines)
        success, response = self.ai_manager.generate_tests(code, self.buffer.language)
        
        self.ai_loading = False
        self.ai_response = response if success else f"âŒ {response}"
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“– Ğ¡ĞŸĞ ĞĞ’ĞšĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _show_help(self):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¿Ñ€Ğ°Ğ²ĞºÑƒ"""
        curses.endwin()
        
        print(SPLASH_SCREEN)
        
        help_text = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                           âŒ¨ï¸ Ğ“ĞĞ Ğ¯Ğ§Ğ˜Ğ• ĞšĞ›ĞĞ’Ğ˜Ğ¨Ğ˜                                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                              â•‘
â•‘  ğŸ“ Ğ¤ĞĞ™Ğ›Ğ«                          ğŸ” ĞŸĞĞ˜Ğ¡Ğš Ğ˜ ĞĞĞ’Ğ˜Ğ“ĞĞ¦Ğ˜Ğ¯                      â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€                           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â•‘
â•‘  Ctrl+N   ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»               Ctrl+F   ĞĞ°Ğ¹Ñ‚Ğ¸                            â•‘
â•‘  Ctrl+O   ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ                  Ctrl+H   ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¸ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ                 â•‘
â•‘  Ctrl+S   Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ                Ctrl+G   ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑÑ‚Ñ€Ğ¾ĞºĞµ                 â•‘
â•‘  Ctrl+W   Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ĞºĞ»Ğ°Ğ´ĞºÑƒ          F3       Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ             â•‘
â•‘  Ctrl+Q   Ğ’Ñ‹Ğ¹Ñ‚Ğ¸                    Ctrl+D   Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ Ğ²Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¾Ğ²Ğ°        â•‘
â•‘                                                                              â•‘
â•‘  âœï¸ Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•                 ğŸ¨ Ğ˜ĞĞ¢Ğ•Ğ Ğ¤Ğ•Ğ™Ğ¡                              â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â•‘
â•‘  Ctrl+Z   ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ                 F1       Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ°                          â•‘
â•‘  Ctrl+Y   ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚ÑŒ                F2       Ğ ĞµĞ¶Ğ¸Ğ¼ Zen                        â•‘
â•‘  Ctrl+C   ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ               F4       Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞ¼Ñƒ                     â•‘
â•‘  Ctrl+X   Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ                 F5       Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´                    â•‘
â•‘  Ctrl+V   Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ                 F6       ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²                 â•‘
â•‘  Ctrl+D   Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ       F7       ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞºĞ¾Ğ´Ğ°                    â•‘
â•‘  Ctrl+/   ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ           F9       Ğ—Ğ°ĞºĞ»Ğ°Ğ´ĞºĞ°                         â•‘
â•‘  Tab      ĞÑ‚ÑÑ‚ÑƒĞ¿ / Ğ¡Ğ½Ğ¸Ğ¿Ğ¿ĞµÑ‚         F10      AI Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº                      â•‘
â•‘  Alt+â†‘/â†“  ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ       Ctrl+`   Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»                         â•‘
â•‘                                    Ctrl+P   ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°                â•‘
â•‘                                                                              â•‘
â•‘  ğŸ¤– AI ĞŸĞĞœĞĞ©ĞĞ˜Ğš (F10)              ğŸŒ¿ GIT (Ğ² ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğµ)              â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â•‘
â•‘  S   ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° AI                  git-status    Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ                      â•‘
â•‘  E   ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´                 git-commit    ĞšĞ¾Ğ¼Ğ¼Ğ¸Ñ‚                      â•‘
â•‘  F   ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸                  git-push      ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ                   â•‘
â•‘  O   ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ                git-pull      ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ                    â•‘
â•‘  D   Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ                                                            â•‘
â•‘  T   Ğ¢ĞµÑÑ‚Ñ‹                                                                   â•‘
â•‘                                                                              â•‘
â•‘  ğŸ’¡ ĞŸĞĞ”Ğ¡ĞšĞĞ—ĞšĞ˜                                                                â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                â•‘
â•‘  â€¢ ĞŸĞµÑ‡Ğ°Ñ‚Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ½Ğ¸Ğ¿Ğ¿ĞµÑ‚Ğ° Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Tab (def, for, if, class...)       â•‘
â•‘  â€¢ Ctrl+Space Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ                                             â•‘
â•‘  â€¢ Ctrl+P Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ»ÑĞ±Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğµ                              â•‘
â•‘  â€¢ AI Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ ĞºĞ¾Ğ´ Ğ¿Ñ€ÑĞ¼Ğ¾ Ğ² Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğµ (Ñ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ)         â•‘
â•‘                                                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“± Telegram: @MARADANIL         ğŸ”— https://t.me/DIPO_OFFICIAL               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        print(help_text)
        input("\nĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter Ğ´Ğ»Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ° Ğ² Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€...")
        
        self.stdscr = curses.initscr()
        self._init_curses()
    
    def _open_settings(self):
        """ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸"""
        config_file = str(Config.CONFIG_FILE)
        self.open_file(config_file)
        self.show_message("âš™ï¸ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹", "info")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ’¬ Ğ”Ğ˜ĞĞ›ĞĞ“Ğ˜
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def show_message(self, message: str, msg_type: str = "info"):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ"""
        self.message = message
        self.message_type = msg_type
        self.message_time = time.time()
    
    def show_input_dialog(self, title: str, callback: Callable):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ²Ğ²Ğ¾Ğ´Ğ°"""
        self.dialog_mode = title.lower().replace(" ", "_").replace(":", "").replace(".", "")
        self.dialog_input = ""
        self.dialog_callback = callback
    
    def show_confirm_dialog(self, message: str, callback: Callable):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ"""
        # Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
        curses.endwin()
        response = input(f"{message} (y/n): ").strip().lower()
        callback(response == 'y')
        self.stdscr = curses.initscr()
        self._init_curses()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”„ Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ›
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def run(self):
        """Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğ°"""
        while self.running:
            try:
                self.render()
                self.handle_input()
            except KeyboardInterrupt:
                self._quit()
            except Exception as e:
                self.show_message(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}", "error")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Ğ¢ĞĞ§ĞšĞ Ğ’Ğ¥ĞĞ”Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def show_splash():
    """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑÑ‚Ğ°Ğ²ĞºÑƒ"""
    print(SPLASH_SCREEN)
    time.sleep(0.5)


def main():
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="ğŸš€ Dipo Studio - Ğ ĞµĞ²Ğ¾Ğ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ´Ğ°",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:
  dipo                    ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€
  dipo file.py            ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»
  dipo file1.py file2.js  ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
  dipo .                  ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´Ğ½Ğ¸Ğº Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ Ğ¿Ğ°Ğ¿ĞºĞµ

Ğ“Ğ¾Ñ€ÑÑ‡Ğ¸Ğµ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ¸:
  F1        Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ°
  Ctrl+S    Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ
  Ctrl+Q    Ğ’Ñ‹Ğ¹Ñ‚Ğ¸
  F5        Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´
  F10       AI Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº

ğŸ“± Telegram: {__telegram__}
ğŸ”— {__telegram_link__}
"""
    )
    
    parser.add_argument('files', nargs='*', help='Ğ¤Ğ°Ğ¹Ğ»Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ')
    parser.add_argument('--version', '-v', action='version', version=f'Dipo Studio v{__version__}')
    parser.add_argument('--no-splash', action='store_true', help='ĞĞµ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ·Ğ°ÑÑ‚Ğ°Ğ²ĞºÑƒ')
    parser.add_argument('--theme', '-t', help='Ğ¢ĞµĞ¼Ğ° Ğ¾Ñ„Ğ¾Ñ€Ğ¼Ğ»ĞµĞ½Ğ¸Ñ')
    parser.add_argument('--ai-setup', action='store_true', help='ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ AI')
    
    args = parser.parse_args()
    
    # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° AI
    if args.ai_setup:
        config = AIConfig()
        providers = list(AIConfig.PROVIDERS.items())
        
        print("\nğŸ¤– ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ AI\n")
        
        for i, (key, info) in enumerate(providers, 1):
            print(f"  [{i}] {info['icon']} {info['name']}")
        
        try:
            choice = int(input("\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ°: ")) - 1
            if 0 <= choice < len(providers):
                provider_key, provider_info = providers[choice]
                
                if provider_key != "ollama":
                    api_key = input(f"API ĞºĞ»ÑÑ‡ ({provider_info['key_hint']}): ").strip()
                else:
                    api_key = ""
                
                model = input(f"ĞœĞ¾Ğ´ĞµĞ»ÑŒ [{provider_info['default_model']}]: ").strip()
                model = model or provider_info['default_model']
                
                config.set_provider(provider_key, api_key, model)
                print("\nâœ… ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹!")
        except:
            print("\nâŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾")
        
        return
    
    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°ÑÑ‚Ğ°Ğ²ĞºÑƒ
    if not args.no_splash and not args.files:
        show_splash()
    
    # Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞ¼Ñƒ ĞµÑĞ»Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°
    if args.theme:
        Config().set("theme", args.theme)
    
    # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€
    def run_editor(stdscr):
        editor = DipoEditor(stdscr, args.files)
        editor.run()
    
    try:
        locale.setlocale(locale.LC_ALL, '')
        curses.wrapper(run_editor)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\nâŒ ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
        traceback.print_exc()
        print(f"\nğŸ“± Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ¸Ñ‚Ğµ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ: {__telegram_link__}")
        sys.exit(1)
    
    # ĞŸÑ€Ğ¾Ñ‰Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    print(f"\nğŸš€ Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Dipo Studio!")
    print(f"ğŸ“± Telegram: {__telegram__}")
    print(f"ğŸ”— {__telegram_link__}\n")


if __name__ == "__main__":
    main()
    
